using Format, Units, Math, IO;

include "English";
include "Spanish";
include "Library";
include "Languages";
include "LanguageTree";
include "IPA";
include "Rules";
include "Style";
include "References";
//include "WordForms";
include "../Data/Swadesh/WordLists";
include "Tables";
include "RevBayes";
//======================================================================

// No spaces in the name below!
// RevBayes has a problem with folder names that contain spaces...

ShowOutput = "Output2";

Main.Documents = new DocumentViewClass(null) {
  new PaperViewClass(ShowOutput);
  new DiagnosticsViewClass(ShowOutput);
};

void Main.Run {
  new ComputeClass(ShowOutput).Calculate;
}
//======================================================================

enum ConceptsList {
  Sun,
  Moon,
  Star,
  Water,
  Rain,
  River,
  Lake,
  Sea,
  Salt,
  Stone,
  Sand,
}

with Info {
  Generations = 3000;

  PaperTitle  = "White Paper";
  Journal     = "Transactions of the Beysian Society";
  Publisher   = "The Baysian Society";
  Title       = Lang.SimulatedSegments;
  PriorTree   = GetTreeNodes(LanguageBranches.Romance);

  AuthorList = Span {
    Separator: ", ";
    LastSeparator: " {0} "(Lang.And);
    Style.Author(each Authors);
  };
}
//======================================================================

with Abstract {
  Title = Lang.Abstract;
  Body  = Block {
    Style.BodyPar {
      "Linguistically phylogenies are standardly inferred on the basis of cognate relationships, which are discrete representations of ancestry. Although inference on the basis of such datasets has yielded important results, it suffers from an obvious fault: it ignores the phylogenetic signal in the segmental form of words. In this paper, we infer the phylogeny of Romance on the basis of segmental data...";
    };
  };
}
//======================================================================

with Content.Introduction {
  Title = Lang.Introduction;
  Body  = Block {
    Style.BodyPar {
      "In this paper, we attempt to do the impossible!";
    };
  };
}
//======================================================================

with Content.Methods {
  Title = Lang.Methods;
  Body  = Block {
    Style.BodyPar {
      "We use ancestral classes, in which the descendant forms are segmentally aligned. "
      "It is important to note that our definition of cognate refers only to segmental descent. "
      "It takes no account of semantics whatsoever. "
      "So the lexical items for 'ear' in Romance are paired with the Latin word " Style.Word("auricula")
      " which is the diminute form of 'ear'. "
    };
    Style.BodyPar {
      "Other things we have to mention: "
    };
    Style.NumberList {
      "The data are surface forms, not underlying forms.";
      "We used the accusative singular for nouns in Latin.";
    };
  };
}
//======================================================================

with Content.Conclusion {
  Title = Lang.Conclusion;
  Body  = Block {
    Paragraph {
      "Vene Vidi Vici";
    };
  };
}
//======================================================================

Main.Configurations = [
  new ConfigurationClass("United States") {
    Language: ConfigurationClass.Languages.English;
    PaperSystem: ConfigurationClass.PaperSystems.US;
    UnitSystem: ConfigurationClass.UnitSystems.Imperial;
  },

  new ConfigurationClass("Spain") {
    Language: ConfigurationClass.Languages.Spanish;
    PaperSystem: ConfigurationClass.PaperSystems.A;
    UnitSystem: ConfigurationClass.UnitSystems.Metric;
  },
];
//======================================================================

abstract class BaseViewClass: DocumentViewClass {
  var OutFolder;

  Constructor(name, outfolder) {
    OutFolder = outfolder;
    super.Constructor(name Space outfolder, name outfolder);
  }

  override GetDocument {
   var compute = new ComputeClass(OutFolder);

   return Style.WhitePaper {
      Title: Info.Title;
      Author: Info.AuthorList;
    //  Description: "Test Description";
    //  Comment: "Test Comment";
    //  Subject: "Test Subject";
    //  Keywords: "Test Keywords";

      GetContent(compute);
    }
  }

  abstract GetContent(compute);
}
//======================================================================

class PaperViewClass: BaseViewClass {
  Constructor(outfolder) {
    super.Constructor("White Paper", outfolder);
  }

  GetAppendices(compute) = [
    new AppendixClass("Options File", compute.GetOptionsSource),
    new AppendixClass("Program Output", compute.ShowLanguageTrees),
  ];

  override GetContent(compute) = {
    var appendices = GetAppendices(compute);
    Style.PageSection {
      Header: Style.NormalHeader(Info.Journal) {
        Distance: 0.125 inches;
        MarginT: 0.125 inch;
        Even: Style.NormalHeader(Info.Journal);
        First: Block;
      };

      Paragraph {
        ParAlignment: ParAlignments.Center;
        Logo;
      };
      Style.Title(Info.Title);
      Paragraph {
        ParAlignment: ParAlignments.Center;
        Info.AuthorList;
      };

      Style.HeaderCentered(Abstract.Title);
      Abstract.Body;

      Style.ShowContent(each Content);
      Style.ShowAuthors(Authors);

      Style.HeaderCentered(Lang.Appendices);
      Style.AppendixRow(each appendices);

      Style.ShowReferences(References);
    };
    Style.ShowAppendix(each appendices);
  };
}
//======================================================================

class DiagnosticsViewClass: BaseViewClass {
  Constructor(outfolder) {
    super.Constructor("Diagnostics", outfolder);
  }

  GetAppendices(compute) = [
    new AppendixClass("Transition Matrix", compute.ShowTransitionMatrix),
    new AppendixClass("RevBayes Source File", compute.RevBayesSource),
    new AppendixClass("Character File", Nexus.CharacterFile(2)),
    new AppendixClass("TKF Input Files", Nexus.TKFFiles),
    new AppendixClass(Lang.ConceptsUsed, AllWords.ShowTable),
    new AppendixClass("Segments used in the word list", DisplayCharacters.ShowTable),
    new AppendixClass("Feature change in first segment", IPA.DriftSection),
    new AppendixClass("Word Lists by Language", DisplayWords.ShowTable),
    new AppendixClass("Segment Groups", MatchingConsonants.ShowTables),
    new AppendixClass("Euler Feature Diagram", IPA.FeatureChart),
    new AppendixClass(Lang.IPAFullName, IPA.SegmentTable),
    new AppendixClass("Feature Tree", SegmentTree.ShowTree),
    new AppendixClass(Lang.Diacritics, MatchingDiacritics.ShowTable),
  //  new AppendixClass(Lang.NytrilSourceCode, Style.SourceFile(each System.SourceList)),
  ];

  override GetContent(compute) = {
    var appendices = GetAppendices(compute);
    Style.ShowAppendix(each appendices);
  };
}

//======================================================================



