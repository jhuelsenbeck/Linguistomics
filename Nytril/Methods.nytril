using Format, Units, Defs, Equations, WorldLanguages, References, PaperStyle;

//======================================================================

readonly PartitionAssignmentsClass Figures.PartitionAssignments = new(MainResults.Data.Rule);

class PartitionAssignmentsClass: ContentClass {
  var RuleClass Rule;

  Constructor(RuleClass rule) {
    super.Constructor(Lang.PartitionRules);
    Rule = rule;
  }

  override GetCaption(ContentStyleClass style) = Rule.GetCaption(style);

  override GetBody(ContentStyleClass style, title) = Rule.ShowPartitions;
}

//======================================================================

readonly ExperimentalRunsClass Figures.ExperimentalRuns = new;

class ExperimentalRunsClass: ContentClass {
  Constructor {
    super.Constructor("Experimental Runs");
  }

  ShowTrees(ContentStyleClass style, ModelClass model) = Block {
    var anytree = false;
    foreach (var r in model.Run) {
      if (r.ResultTree is not null) {
        anytree = true;
        break;
      }
    }

    if (anytree) {
      style.FirstPar {
        Lang.Model;
        ColonSpace;
        model.Name;
      };

      foreach (var r in model.Run) {
        if (r.ResultTree is not null)
          ShowTree(style, r.ResultTree, 100%, "Run {0}"(each1));
      }
    }
  };

  override GetCaption(ContentStyleClass style) = Span {
    Lang.Experiment;
    Space;
    each1;
    Space;
    style.DQuote {MainResults.Data.Name};
  };

  override GetBody(ContentStyleClass style, title) = Block {
    var data = MainResults.Data;

    Span {
      foreach (var tree in TreeExamples.PriorTrees)
        ShowTree(style, tree, 30%, Lang.Tree+each1);
    };

    foreach (var treeset in data.TreeSets) {
      style.Heading3 {
        Lang.Tree;
        each1;
      };
      ShowTrees(style, each treeset.Models);
    }
  };
}

//======================================================================

readonly ModelTrees Figures.ModelTreesUsed = new;

class ModelTrees: ContentClass {
  Constructor {
    super.Constructor("Model trees");
  }

  override GetCaption(ContentStyleClass style) = Span {
    "Model trees used in all analyses";
  };

  override GetBody(ContentStyleClass style, title) = VBox {
    foreach (var tree in TreeExamples.PriorTrees)
      ShowTreeHorizontal(style, tree, 80%, Lang.Tree + Space + each1);
  };
}

//======================================================================

readonly TransitionRatesClass Figures.TransitionRates = new;

class TransitionRatesClass: ContentClass {
  Constructor {
    super.Constructor("Transition Rates between Partitions");
  }

  override GetCaption(ContentStyleClass style) = Span {
    "The area of the circles is proportional to the estimated equilibrium frequencies. ";
    "The width of the lines is proportional to the estimated rates. ";
  };

  override GetBody(ContentStyleClass style, title) = new CalcRatesClass(MainResults.Data, MainResults.MainRun).PartitionDiagram(style);
}

//======================================================================

readonly AlignmentChartClass AlignmentResults = new(MainResults.Data, MainResults.MainRun);

readonly AlignmentsClass Figures.Alignments = new;

class AlignmentsClass: ContentClass {
  Constructor {
    super.Constructor("Alignments");
  }

  override GetCaption(ContentStyleClass style) = Span {
    ResultsClass.CutoffPercent;
    " credible set of alignments";
  };

  override GetBody(ContentStyleClass style, title) = Block {
    AlignmentResults.ShowChart(style, new(ExtentWidth, ExtentHeight - 1 inch));
  };
}

//======================================================================

readonly AllAlignmentsClass Figures.AllAlignments = new;

class AllAlignmentsClass: ContentClass {
  Constructor {
    super.Constructor("All Alignments");
  }

  override GetCaption(ContentStyleClass style) = Span {
    ResultsClass.CutoffPercent;
    " credible set of alignments";
  };

  override GetBody(ContentStyleClass style, title) = AlignmentResults.ShowAll;
}

//======================================================================

class AlignmentExamplesClass: ContentClass {
  var CognateIdClass[] Examples;

  Constructor(name, CognateIdClass[] examples) {
    super.Constructor(name);
    Examples = examples;
  }

  override GetCaption(ContentStyleClass style) = "Credible sets for cognate alignments";

  override GetBody(ContentStyleClass style, title) = AlignmentResults.ShowSet(Examples, true);
}

readonly AlignmentExamplesClass Figures.AlignmentExamples = new(
  "Alignment Examples",
  [new("Moon", null, 5, 5), new("One", null, 8, 8), new("Tooth", null, 3, 5)]
);

//======================================================================

class SingleAlignmentClass: AlignmentExamplesClass {
  Constructor(count, row, name) {
    super.Constructor("Highest probability alignments for '{0}'"(name), [new(name, null, count, row)]);
  }

  override GetCaption(ContentStyleClass style) = Span {
    "Segments are colored according to the "; NaturalModelName; ". Dashes denote gaps where there is no homologous segment for the alignment position. ";
    "The alignments are ordered from the highest posterior probability (top-left alignment) to the lowest posterior probability (bottom-right alignment) in row order. ";
  };

  override GetBody(ContentStyleClass style, title) = AlignmentResults.ShowSet(Examples, false);
}

readonly SingleAlignmentClass Figures.AlignmentExample1 = new(16, 4, "Flower");

//======================================================================

class ModelCompareClass {
  var SymbolClass     Symbol;
  var double          Posterior;
  var int             TotalCount;
  var RunResultsClass Run;
  var                 Name;

  Constructor(RunResultsClass run, SymbolClass s, CognateIdClass e, int maxcount) {
    Symbol = s;
    Name   = s.Name;
    Run    = run;

    var    align = e.FindAlignment(Run);
    var    a     = align.Alignments;
    double sum   = 0;
    for (int i = 0; i < maxcount; ++i)
      sum += a[i].Prob;
    Posterior  = sum;
    TotalCount = align.TotalCount;
  }

  override GetLayoutSpan = Span {
    Tip: Symbol;
    Name;
  };

  ModelName = Span {
    Symbol; " ("; GetLayoutSpan; " model)";
  };

  ShowAlignmentNumber = Span {
    TotalCount; " alignments under the "; GetLayoutSpan;
  };
}

//======================================================================

class GappinessSignificanceClass {
  var double TestStatistic;

  Constructor(RunResultsClass run) {
    var   spectrum = run.GapSpectrum;
    double n       = 0;
    double lnL1    = 0.0;
    double lnL0    = 0.0;

    VectorClass<double> statistic = new(spectrum.Length, 0.0);
    VectorClass<double> countVals = new(spectrum[0].Length, 0.0);
    foreach (var gap in spectrum) {
      var ni = Math.Sum(gap);
      n += ni;
      foreach (var value in gap) {
        if (value != 0)
          lnL1 += value * Math.Log(value / ni);
      }
      statistic.SetValue(each0, n);
      foreach (var value in gap)
        countVals.AddValue(each0, value);
    }

    foreach (var value in countVals) {
      if (value != 0)
        lnL0 += value * Math.Log(value/n);
    }
    TestStatistic = -2.0 * (lnL0 - lnL1);
  }
}

//======================================================================

class AlignmentCompareClass: ContentClass {
  const string Concept  = "Sky";

  var ModelCompareClass   Poisson,
                          NaturalClass;
  var ModelCompareClass[] Models;
  var CognateIdClass      Example;
  var int                 MaxCount;

  Constructor(maxcount, row) {
    super.Constructor("Alignment comparison");
    MaxCount     = maxcount;
    Example      = new(Concept, null, MaxCount, row);
    Poisson      = new(MainResults.Poisson, PoissonModel, Example, MaxCount);
    NaturalClass = new(MainResults.NaturalClass, NaturalClassModel, Example, MaxCount);
    Models       = [Poisson, NaturalClass];
  }

  override GetCaption(ContentStyleClass style) = Span {
    "Alignments of highest posterior probability of the cognate for the concept ";
    Span {
      TextCase: TextCases.AllLower;
      style.SQuoteEnd{Concept};
    };

    foreach (var m in Models) {
      Span {
        "The "; Enumerators.Cardinal(MaxCount); " alignments under the "; m.ModelName; " account for ";
        Span {
          TextDigits: 3;
          TextSignificant: true;
          m.Posterior;
        };
        " posterior probability. ";
      };
    }
  };

  override GetBody(ContentStyleClass style, title) = VBox {
    var data = MainResults.Data;
    foreach (var m in Models) {
      Paragraph {
        TextHeight: 20 pts;
        m.Symbol;
        " — ";
        m.Name;
      };
      var chart = new AlignmentChartClass(data, m.Run);
      chart.ShowSet([Example], false);
    }
  };
}

readonly AlignmentCompareClass Figures.AlignmentExample2 = new(8, 4);

//======================================================================

readonly ExchangeabilityTableClass Figures.ExchangeabilityTable = new;

class ExchangeabilityTableClass: ContentClass {
  Constructor {
    super.Constructor(Lang.Exchangeability);
  }

  override GetBody(ContentStyleClass style, title) = Block {
    var th = ExtentWidth * 0.015;
    style.SansSerif;
    TextHeight: th;

    var results    = MainResults;
    var stats      = results.MainRun.TransitionStats;
    var count      = stats.Length;
    var partitions = results.Data.Rule.Partitions;
    var dy         = 2 pts;
    var left       = 1 inch;
    var w          = (ExtentWidth - 1 inch) / count;

    Table(PadR(4 pts), null, [left] + [w] * count) {
      HAlign: Center;
      TextDigits: 3;

      Row {
        Empty;

        foreach (var p in partitions) {
          Frame(w) {
            ParAlignment: Center;
            TextHeight: th*0.8;
            TextColor: p.Color;
            p.Name.Split(Space);
          };
        }
      };

      for (int i = 0; i < count; ++i) {
        Row {
          VAlign: Center;
          Frame(w) {
            ParAlignment: Right;
            var p = partitions[i];
            TextColor: p.Color;
            p;
          };

          for (int j = 0; j < count; ++j) {
            var c = stats[i, j];
            if (c is valid)
              c.ShowBox {Margin: PadT(dy)};
            else
              "-";
          }
        };
      }
    };
  };
}

//======================================================================

readonly NaturalClassRateChartClass Figures.RateChart = new;

class NaturalClassRateChartClass: ContentClass {
  Constructor {
    super.Constructor(NaturalClassName + " Rates");
  }

  private ShowRight(number) = HBox {
    Space*2;
    TextHeight: 80%;
    TextColor: Colors.Gray;
    number;
  };

  override GetCaption(ContentStyleClass style) = Span {
    "The average rates of change between and within the ten segment groups of the "; NaturalModelName; DotSpace;
    "Circle area is proportional to the rate of change between groups ("; Defs.qij; "). ";
    "Shaded area represents the 95% credible interval. ";
  };

  override GetBody(ContentStyleClass style, title) = Block {
    style.SansSerif;
    TextHeight: ExtentWidth * 0.015;

    var partitions = MainResults.Data.Rule.Partitions;
    var stats      = MainResults.MainRun.NCQRates;
    var bx         = 20 pts;
    var tx         = 60 pts + bx;
    var size       = Math.Min(ExtentWidth, ExtentHeight);
    var dy         = size / (partitions.Length + 1);
    var d          = Math.Min(dy, (size  - tx) / partitions.Length);

    var max = 0.0;
    foreach (var pi in partitions) {
      foreach (var pj in partitions) {
        var c = stats[pi.Index, pj.Index];
        if (c is valid and c.Upper > max)
          max = c.Upper;
      }
    }

    HBox {
     TextHeight: 10 pts;
      VBox {
        HAlign: Right;
        VAlignment: VAligns.Bottom;

        foreach (var p in partitions) {
          HBox(null, d, PadR(2)) {
            VAlign: Center;
            TextColor: p.Color;
            p;
          }
        }
      };

      VBox {
        HAlign: Left;
        Canvas {
          HAlignment: HAligns.Right;
          VAlign: Bottom;
          foreach (var p in partitions) {
            HBox(null, d, PadR(0 pts)) {
              X: d * (each0 + 0.3);
              TextColor: p.Color;
              Transform: TransformClass.Rotate(-90 degrees);
              TransformFit: true;
              p;
            };
          }
        };

        VBox {
          var factor = 1.0 / max;

          foreach (var pi in partitions) {
            HBox {
              foreach (var pj in partitions) {
                var c = stats[pi.Index, pj.Index];
                Canvas(d, d) {
                  if (c is valid) {

                    Tip: c;
                    var center = new PointClass(d * 0.5);
                    var x      = d  * Math.Sqrt(c.Upper * factor);
                    Shape(90%) {
                      EllipsePath(new(new(center.X - x*0.5 , center.Y - x*0.5), x));
                      x = d * Math.Sqrt(c.Lower * factor);
                      EllipsePath(new(new(center.X - x*0.5 , center.Y - x*0.5), x));
                    };

                    Shape(null, 1) {
                      x = d * Math.Sqrt(c.Mean * factor);
                      EllipsePath(new(new(center.X - x*0.5 , center.Y - x*0.5), x));
                    };
                  }
                };
              }
            };
          }
        }
      };
    };
  };
}

//======================================================================

readonly EquilibriumFrequencyChartClass Figures.EquilibriumCharts = new;

class EquilibriumFrequencyChartClass: ContentClass {
  Constructor {
    super.Constructor("Equilibrium frequency chart");
  }

  override GetCaption(ContentStyleClass style) = Span {
    "The equilibrium frequencies "; Defs.EquilibriumDistribution; " of each natural class";
  };

  override GetBody(ContentStyleClass style, title) = Chart(100%, 3 inches) {
    ChartType: ChartTypes.Bar;
    style.SansSerif;
    TextHeight: 11 pts;

    ValueLabel: Span {
      TextHeight: 20 pts;
      Defs.EquilibriumDistribution;
    };

    var partitions = MainResults.Data.Rule.Partitions.Reverse;
    var stats      = MainResults.MainRun.NCQFreqs;

    XAxis: ChartAxis(null, null, PadR(8)) {
      foreach (var p in partitions) {
        Span {
          Tip: p;
          TextColor: p.Color;
          p.Name;
        }
      }
    };

    ChartSeries {
      foreach (var p in partitions) {
        var c = stats[p.Index];
        new DataPointClass(each0, c.Mean) {
          ErrorLo: c.Mean - c.Lower;
          ErrorHi: c.Upper - c.Mean;
          Reference: c;
          Fill: p.Color;
        }
      }
    };
  };
}

//======================================================================

readonly GappinessChartClass Figures.GappinessChart = new;

readonly GappinessSignificanceClass GapInfo = new(MainResults.MainRun);

class GappinessChartClass: ContentClass {
  Constructor {
    super.Constructor("Gap frequency comparison chart");
  }

  override GetCaption(ContentStyleClass style) = Span {
    "The number of gaps observed across the "; MainResults.Data.UsedCognates.Length; " cognate sets analyzed in this study at the word-initial segment (top), word-internal segment(s) (middle), and word-final segment (bottom). ";
    "Nine languages were analyzed in this study, so it is not possible for there to be nine gaps. Deletion events that led to a gap for all the languages would not be included in an alignment, and is explicitly conditioned on in Lunter et al."; Citation{Lunter2003}; DotSpace;
    "There is a clear, and statistically significant, pattern of an increasing number of gaps as one moves from the initial to the final segment of the word. ";
    "(A likelihood ratio test of the null hypothesis that the distributions are the same at the initial, internal, and final segments is highly significant, with a test statistic of ";
    Span {
      TextDigits: 2;
       GapInfo.TestStatistic;
     };
     "; ";
     Equation {Defs.DegreesFreedom; Tex.Equals; 16};
     CommaSpace;
     Equation {Defs.PValue; Tex.lt; 0.001};
     ".)";
  };

  override GetBody(ContentStyleClass style, title) = HBox {
    style.SansSerif;
    VAlign: Center;
    PaperStyle.ValueLabel {
      TextHeight: 12 pts;
      "Proportion of Alignments"
    };
    var gaps        = MainResults.MainRun.GapSpectrum;
    var chartheight = (ExtentHeight - 40 pts) / gaps.Length;
    VBox {
      HAlign: Center;
      foreach (var gap in gaps) {
        Chart(ExtentWidth - 20 pts, Math.Min(chartheight, 1.5 inches)) {
          ChartType: ChartTypes.Column;

// Possible alternate look
//          ChartType: ChartTypes.Area;
//          Smoothing: 70%;
//          Marker: Markers.Circle;

          ValueLabel: PaperStyle.ValueLabel {
            TextHeight: 8 pts;
            ["Word-initial segment", "Word-internal Segment(s)", "Word-final Segment"][each0]
          };

          ValueAxis: ChartAxis {
            TextHeight: 7 pts;
            Start: 0;
            Stop: 1.0;
          };

          XAxis: ChartAxis {
            each (0..<gap.Length step 1) as string;
          };

          ChartSeries {
            var factor = 1.0 / Math.Sum(gap);
            foreach (var value in gap)
              new DataPointClass(each0, value * factor);
          };
        }
      }
      Span {
        TextHeight: 12 pts;
        "Number of Gaps"
      };
    };
  };
}

//======================================================================

readonly FractionGapsChartClass Figures.FractionGapsChart  = new;

class FractionGapsChartClass: ContentClass {
  Constructor {
    super.Constructor("Deletions at the right edge");
  }

  override GetBody(ContentStyleClass style, title) = Block {
    style.SansSerif;
    "To be completed";
  };
}

//======================================================================

const int TopCount = 15;

//======================================================================

readonly QRatesMatrixClass Figures.QRatesMatrix = new;

class QRatesMatrixClass: ContentClass {
  Constructor {
    super.Constructor("Rate Matrix " Defs.RateMatrix);
  }

  override GetBody(ContentStyleClass style, title) = MainResults.MainRun.QRates.PartitionBox(style, ExtentSize);
}

//======================================================================

readonly QRatesDiagonalClass Figures.QRatesDiagonal = new;

class QRatesDiagonalClass: ContentClass {
  Constructor {
    super.Constructor("Rate of segmental change");
  }

  override GetCaption(ContentStyleClass style) = Span {
    "The rate of change when in a particular segmental state (or "; -Defs.qii; ")"
  };

  override GetBody(ContentStyleClass style, title) = new DiagonalClass(MainResults.Data.Rule, MainResults.MainRun.QRates).Display(style);
}

//======================================================================

readonly TreeContentClass Figures.PriorTree = new("Tree topology", TreeExamples.PriorTrees.FirstElement);

//======================================================================

readonly LanguageDistributionClass  Figures.LanguageDistribution = new;

class LanguageDistributionClass: ContentClass {
  Constructor {
    super.Constructor("Ggeographic distribution of languages");
  }

  override GetCaption(ContentStyleClass style) = Span {
    "Approximate geographic distribution of the Romance languages examined in this study.";
  };

  override GetBody(ContentStyleClass style, title) = Paragraph {
    ParAlignment: Center;
    HBox {
      VAlign: Center;
      style.SansSerif;
      Separation: 10 pts;
      FitBox(IO.Read(res "Images/areas.png"), 80%, null, 0.5 pt) {
        BorderRadius: 1 pts;
      };
      VBox {
        Separation: 4 pts;
        foreach (var l in MainResults.Data.LanguageSet) {
          if (l != WorldLanguages.Latin) {
            HBox {
              Separation: 2 pts;
              Canvas(8 pts, 8 pts, 0.5 pts) {
                Baseline: 85%;
                BorderRadius: 2 pts;
                Background: l.MapColor;
              };
              l;
            };
          }
        }
      };
    };
  };
}

//======================================================================

readonly AverageAllClass Figures.AverageAll = new;

class AverageAllClass: ContentClass {
  Constructor {
    super.Constructor("All Rates");
  }

  override GetBody(ContentStyleClass style, title) = MainResults.MainRun.QRates.ShowAllRates;
}

//======================================================================

readonly AverageSortedClass Figures.AverageSorted = new;

class AverageSortedClass: ContentClass {
  Constructor {
    super.Constructor("Rate vs. Direction");
  }

  override GetBody(ContentStyleClass style, title) = MainResults.MainRun.QRates.ShowRateDirected;
}

//======================================================================

readonly RateDirectionClass Figures.RateDirection = new;

class RateDirectionClass: ContentClass {
  Constructor {
    super.Constructor("Directionality");
  }

  override GetBody(ContentStyleClass style, title) = MainResults.MainRun.QRates.ShowDirection;
}

//======================================================================

readonly SpecificRatesClass Figures.SpecificRates = new;

class SpecificRatesClass: ContentClass {
  Constructor {
    super.Constructor("Specific Rates");
  }

  static bool Predicate(RateClass a) = a.IsPair("p", "f") or a.IsPair("s", "h") or a.IsPair("k", "ʧ");

  override GetBody(ContentStyleClass style, title) = MainResults.MainRun.QRates.Pairs(-1, @Predicate);
}

TransitionTitle(type) = "The top {0} {1} transitions"(TopCount, type);

//======================================================================

readonly QRatesTopClass Figures.QRatesTop = new;

class QRatesTopClass: ContentClass {
  Constructor {
    super.Constructor(TransitionTitle("segmental"));
  }

  override GetBody(ContentStyleClass style, title) = MainResults.MainRun.QRates.Extrema(TopCount, true);
}

//======================================================================

readonly QRatesConsonantConsonantClass Figures.QRatesConsonantConsonant = new;

class QRatesConsonantConsonantClass: ContentClass {
  Constructor {
    super.Constructor(TransitionTitle("Consonant-Consonant"));
  }

  static bool Predicate(RateClass a) = a.F0.HasFlagMask(SegmentFeatures.Vowel, SegmentFeatures.NoFeature) and
                                       a.F1.HasFlagMask(SegmentFeatures.Vowel, SegmentFeatures.NoFeature);

  override GetBody(ContentStyleClass style, title) = MainResults.MainRun.QRates.Pairs(TopCount, @Predicate);
}

//======================================================================

readonly QRatesOneWayClass Figures.QRatesOneWay = new;

class QRatesOneWayClass: ContentClass {
  Constructor {
    super.Constructor(TransitionTitle("highly directed"));
  }

  override GetBody(ContentStyleClass style, title) = MainResults.MainRun.QRates.ShowChartPairs(TopCount, MainResults.MainRun.QRates.SortByDirection);
}

//======================================================================

readonly AllSegmentFrequenciesClass Figures.AllSegmentFrequencies = new;

class AllSegmentFrequenciesClass: ContentClass {
  var SegmentDisplayClass Display;

  Constructor {
    super.Constructor("Segment occurrance rates for all languages");
    Display = new SegmentDisplayClass(MainResults.Data);
  }

  override GetCaption(ContentStyleClass style) = "The frequency of occurrance of each segment for all languages";

  override GetBody(ContentStyleClass style, title) = Block {
    Display.FrequencyChart(style, new(ExtentWidth, Math.Min(ExtentHeight, 5 inches)));
  };
}

//======================================================================

readonly ConsensusTreeClass Figures.ConsensusTree = new;

class ConsensusTreeClass: ContentClass {
  Constructor {
    super.Constructor(Lang.ConsensusTree);
  }

  override GetBody(ContentStyleClass style, title) = PaperStyle.ShowTree(style, MainResults.MainRun.Run.ResultTree, ExtentWidth);
}

//======================================================================

readonly SegmentOccuranceCaption = Span {
  var l0 = MainResults.Data.Taxa[0].Language;

  "Comparison of occurance rates of segments in each language. Segments are sorted by the rates in ";
  l0;
  ". Bars are normalized to the rate of the most frequently ocurring segment in each language. ";
  "Languages are ordered by their Euclidian distance from "; l0; " indicated by the red line.";
};

readonly SegmentOccuranceRatesClass Figures.SegmentOccuranceRates = new;

class SegmentOccuranceRatesClass: ContentClass {
  Constructor {
    super.Constructor("Segment Occurance Rates");
  }

  override GetCaption(ContentStyleClass style) = SegmentOccuranceCaption;

  override GetBody(ContentStyleClass style, title) = new SegmentFrequencyClass(MainResults.Data, false).ShowChart(style);
}

//======================================================================

readonly SegmentOccuranceGroupedClass Figures.SegmentOccuranceGrouped = new;

class SegmentOccuranceGroupedClass: ContentClass {
  Constructor {
    super.Constructor("Segment Occurance Rates (by partition)");
  }

  override GetBody(ContentStyleClass style, title) = new SegmentFrequencyClass(MainResults.Data, true).ShowChart(style);
}

//======================================================================

readonly PartitionFrequenciesClass Figures.PartitionFrequencies = new;

class PartitionFrequenciesClass: ContentClass {
  Constructor {
    super.Constructor("Partition Occurance Rates");
  }

  override GetCaption(ContentStyleClass style) = SegmentOccuranceCaption;

  override GetBody(ContentStyleClass style, title) = new PartitionFrequencyClass(MainResults.Data).ShowChart(style);
}

//======================================================================

namespace ExampleAnimals {
  Chimpanzee = "AAGCTTCACCGGCGCAATTATCCTCATAATCGCCCACGGACTTACATCCT";
  Gorilla    = "AAGCTTCACCGGCGCAGTTGTTCTTATAATTGCCCACGGACTTACATCAT";
  Human      = "AAGCTTCACCGGCGCAGTCATTCTCATAATCGCCCACGGGCTTACATCCT";
}

//=====================================================================

class ExampleConceptClass {
  var CognateClass    Cognate;
  var LanguageClass[] ExLanguages,
                      LangNames;
  var TaxonClass[]    TaxonList;
  var TaxonClass      Callout,
                      Taxon;
  var ConceptClass    Concept;
  var                 TaxonIndex,
                      Name,
                      CalloutSegment,
                      LangWord;

  Constructor(DataSetClass data, AttributeClass concept) {
    Concept        = new ConceptClass(concept);
    Cognate        = data.GetCognate(concept);
    TaxonIndex     = 0;
    Taxon          = data.Taxa[TaxonIndex];
    Callout        = data.Taxa[3];
    Name           = string.ToLower(Cognate.Concept.Name);
    ExLanguages    = [French, Portuguese, Catalan, Friulian, Romanian];
    TaxonList      = data.Taxa.FindSlice(t => ExLanguages.Contains(t.Language));
    LangNames      = (each TaxonList).Language;
    CalloutSegment = FirstLetter(Callout);
    LangWord       = Span {(each Cognate.Words[TaxonIndex].Segments).Ipa};
  }

  FirstLetter(TaxonClass taxon) = Cognate.Words[taxon.Index].Segments[0].ShowSegment;
  FirstLetters = FirstLetter(each TaxonList);
}

//======================================================================

readonly ExampleTreeClass Figures.ExampleTree = new;

class ExampleTreeClass: ContentClass {
  Constructor {
    super.Constructor("Example Tree");
  }

  override GetCaption(ContentStyleClass style) = Span {
    "An example tree showing the relationships of {0} languages."(SampledLanguages(MainResults.Data.LanguageSet.Length));
  };

  override GetBody(ContentStyleClass style, title) = PaperStyle.ShowTree(style, MainResults.Data.NumberedTree, 5 inches, null, null, false);
}

//======================================================================

readonly ExampleConceptsClass Figures.ExampleConcepts = new;

class ExampleConceptsClass: ContentClass {
  Constructor {
    super.Constructor(Lang.ConceptsExamples);
  }

  override GetBody(ContentStyleClass style, title) = AllWords.ShowTable(style, MainResults.Data, 11 pts, 2);
}

//======================================================================

readonly LanguagesUsedClass Figures.LanguagesUsed = new;

class LanguagesUsedClass: ContentClass {
  Constructor {
    super.Constructor(Lang.Languages);
  }

  override GetBody(ContentStyleClass style, title) = Block {
    var rows      = 2;
    var data      = MainResults.Data;
    var cols      = (data.Taxa.Length + 1) div rows;
    var taxagroup = data.Taxa / cols;
    var h         = 14 pts;
    var space     = 5 pts;
    var border    = 1 pts;
    var width     = ExtentWidth / cols - space;
    var height    = ExtentHeight / rows - space*(rows-1) - (border*2*rows);

    VBox {
      HAlign: Center;

      foreach (var group in taxagroup) {
        HBox(null, null, PadT(space)) {
          VAlign: Top;

          foreach (TaxonClass taxon in group) {
            var language = taxon.Language;
            VBox(width, height) {
              Margin: PadR(space);
              HAlign: Center;

              Paragraph {
                TextHeight: h;
                language.Name;
                var r = language.FindFirstFact(ReferenceClass);
                if (r is not null)
                  Span {TextHeight: 75%; Citation {r}};
              };

              var mh = height - h;
              HBox(width, mh, new EdgeClass(1, 0, 90%)) {
                VAlign: Center;
                BorderRadius: 20 pts;
                BorderClip: true;

                Span {
                  TipAction: language;
                  language.ShowMap(width, mh);
                }
              };
            }
          }
        }
      }
    }
  };
}

//======================================================================

readonly SegmentAssignmentsClass Figures.UniqueSegments = new(MainResults.Data);

//======================================================================

readonly AlignmentClass Figures.Alignment = new;

class AlignmentClass: ContentClass {
  const ArrowWidth  = 40;
  const Arrowhead   = 8 pts;
  const ArrowColor  = 80%;

  const HMap1 = [
    "001111101",
    "100011111",
    "100011101",
    "011011011",
    "101010101",
    "101010100",
    "101010000",
    "010011101",
    "101011101",
    "100111011",
  ];

  const HMap2 = [
    "1111100001",
    "1001111001",
    "0101011010",
    "0001111110",
    "1010101001",
    "0001010110",
    "0001001001",
    "1001110001",
    "1111001001",
    "0101100111",
  ];

  Constructor {
    super.Constructor(Lang.Alignment);
  }

  TName(ContentStyleClass style, TaxonClass taxon) = Span {
    style.SansSerif;
    taxon.Language;
  };

  SegmentTable(ContentStyleClass style, DataSetClass data, ExampleConceptClass example, aligned) = MatrixBox {
    VAlign: Center;
    foreach (var taxon in data.Taxa) {
      Row {
        TName(style, taxon);
        Cell {
          IPAFamily;
          Span {
            var word = example.Cognate.Words[taxon.Index];
            var segs = aligned ? word.Padded : word.Segments;
            (each segs).ShowBlock;
          }
        };
      }
    }
  };

  MapTable(ContentStyleClass style, DataSetClass data, ExampleConceptClass example, map, text) = Block {
    IPAFamily;
    foreach (var taxon in data.Taxa) {
      Paragraph(null, 60 pts) {
        TName(style, taxon);
        Tab;
        var t        = map[each0];
        var segments = example.Cognate.Words[taxon.Index].Segments;
        if (text) {
          var i        = 0;
          foreach (var c in t) {
            if (c == '1' and i < segments.Length)
              segments[i++].ShowBlock;
            else
              IPASegments.GapSegment.ShowBlock;
          }
        }
        else {
          int ones = 0;
          foreach (var c in t) {
            if (c == '1')
              ++ones;
            HBox(10 pts) {HAlign: Center; c}
          }
          System.Assert(ones == segments.Length, taxon.ShortName);
        }
      }
    }
  };

  LabelBox(label) = HBox {
    Margin: PadR(5);
    TextHeight: 18 pts;
    Bold;
    Equation {label};
  };

  ArrowFigure(SizeClass size) = Canvas(size.Width, size.Height) {
    Shape(null, new(1.5, ArrowColor)) {
      OpenPath(0) {
        QuadTo(new(size.Width*0.92, size.Height*0.4), new(size.Width - Arrowhead*0.5, size.Height - Arrowhead));
      };
    };
    Shape(ArrowColor) {
      ClosedPath(size.Width - Arrowhead, size.Height - Arrowhead) {
        LineTo(size.Width, size.Height - Arrowhead);
        LineTo(size.Width - Arrowhead * 0.5, size.Height);
      };
    };
    Canvas {
      Background: Colors.White;
      X: size.Width * 0.3;
      Y: (size.Height - 25 pts) * 0.5;
      TextHeight: 20 pts;
      TextColor: ArrowColor;
      Bold;
      Tex.Plus;
    };
  };

  HomBox(ContentStyleClass style, DataSetClass data, ExampleConceptClass example, num, EdgeClass edge, map) = VBox {
    HAlign: Center;
    HBox {
      VAlign: Top;
      HAlign: Center;

      LabelBox(HomologyMap sub num);
      HBox(null, null, edge) {
        MapTable(style, data, example, map, false);
      };
    };
    Canvas {

      TextColor: ArrowColor;
      TextHeight: 20 pts;
      HAlign: Center;
      Span {
        Tex.downarrow;
        X: 1 pts;
      };
      "=";
    };
    HBox {
      VAlign: Top;
      HAlign: Center;

      LabelBox(SegmentalAlignment sub num);
      HBox(null, null, edge) {
        MapTable(style, data, example, map, true);
      };
    };
  };

  override GetCaption(ContentStyleClass style) = Span {
    "Alignments (";
    SegmentalAlignment;
    ") are formed from the observed segments (";
    SegmentalInfo;
    ") and a homology map (";
    HomologyMap;
    "). ";
  };

  override GetBody(ContentStyleClass style, title)= VBox {
    TextHeight: 10 pts;
    Separation: 4 pts;
    Margin: PadB(5 pts);
    HAlign: Center;

    var data    = MainResults.Data;
    var example = new ExampleConceptClass(data, data.ExampleConcept);
    var edge    = new EdgeClass(0.5 pts, 2 pts, ArrowColor);


    HBox {
      VAlign: Bottom;
      var fsize = new SizeClass(ArrowWidth, data.Taxa.Length * 8 pts);

      ArrowFigure(fsize) {
        Transform: new TransformClass(-1, 0, 0, 1, fsize.Width, 0);
      };
      HBox {
        VAlign: Top;
        LabelBox(SegmentalInfo);
        HBox(null, null, edge) {
          SegmentTable(style, data, example, false);
        };
      };
      ArrowFigure(fsize);
    };
    HBox {
      HomBox(style, data, example, 1, edge, HMap1);
      Separation: 24 pts;
      HomBox(style, data, example, 2, edge, HMap2);
    }
  };
}

//======================================================================

namespace StateSection {
  MatrixRow(states, state) = {
    foreach (var s in states) {
      Cell {
        sym.q sub (state s);
      }
    }
  };

  StateRow(states, state) = Row {
    Cell(PadR(3 pts)) {
      HAlign: Right;
      Span {
        each0 == states.Length div 2 ? "From   " : Empty;
        state;
      }
    };
    MatrixRow(states, state);
  };

  GetStates(count) = 'A'..('A' + (count - 1)) step 1;

  StateTable(count) = Table(new ThicknessClass(1 pts, 1 pts, 3 pts, null), null, [new ColumnClass(56 pts, BorderR(PaperStyle.TableEdgeSize)), 32 pts]) {
    ParAlignment: Center;
    VAlign: Center;
    HAlign: Center;

    var states = GetStates(count);
    Row {
      Empty;
      Cell(null, states.Length) {
        Lang.To;
      };
    };
    Row(BorderB(PaperStyle.TableEdgeSize)) {
      Empty;
      states;
    };
    StateRow(states, each states);
  };

  StateMatrix(count) = MatrixBox(PadB(3)) {
    var states = GetStates(count);

    Bracket: Brackets.FlatRound;
    foreach (var state in states) {
      Row {
        MatrixRow(states, state);
      }
    }
  };
}

//======================================================================

readonly ResultsSectionClass PaperSections.Results = new;

class ResultsSectionClass: ContentClass {
  Constructor {
    super.Constructor("Results");
    AddContent(PaperSections.PhylogenyResults);
    AddContent(PaperSections.ModelComparison);
    AddContent(PaperSections.WordTransformation);
    AddContent(PaperSections.WordSegmentRelationships);
 }

  override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {

    };
  };
}

//======================================================================

readonly PhylogenyResultsClass PaperSections.PhylogenyResults = new;

class PhylogenyResultsClass: ContentClass {
  Constructor {
    super.Constructor("Phylogeny");
  }

  override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      "Our statistical analysis treats all model parameters as random variables with prior probability distributions. ";
      "The tree topology describing the relationships of the languages is also considered a random variable with a uniform prior probability in which all possible tree topologies are assigned equal prior probability. ";
      "As described in the Methods section, we use MCMC to numerically approximate the posterior probability distribution of the model parameters. ";
      "Our analyses consistently found a handful of topologies that best explained the data. Unfortunately, the MCMC poorly explored the tree space: ";
        "the MCMC algorithm would find a good tree then become stuck on it. ";
    };

    style.BodyPar {
      "In our MCMC implementation, parameters are updated in blocks. ";
      "A parameter is randomly selected and then updated. In a single MCMC cycle, either the tree topology or the alignment is updated, but not both simultaneously. ";
      "The tree topology and alignments are confounded. As the MCMC procedure found better trees, the alignments that were accepted by the MCMC procedure tended to fit the current tree in computer memory. ";
      "As the alignment becomes better adapted to the current tree in memory, it becomes more difficult for the MCMC procedure to accept alternative topologies, even if they would be sensible on a different alignment.";
    };

    style.BodyPar {
      var run = MainResults.MainRun;
      TextDigits: 3;
      "This problem was likely not encountered in the other implementations of the TKF91 model";
      Citation {Lunter2004}; ", which analyzed an alignment of amino acid sequences. ";
      "In our analysis of cognate data, the insertion and deletion rates were estimated to be quite high relative to the substitution rate: ";
      Equation {InsertionRate; Tex.Equals; run.InsertionRate}; " ("; run.InsertionRateLow; ", "; run.InsertionRateHigh; ") and ";
      Equation {DeletionRate; Tex.Equals; run.DeletionRate}; " ("; run.DeletionRateLow; ", "; run.DeletionRateHigh; ") ";
        "for the insertion and deletion rates, respectively. ";
      "(The credible intervals in the parentheses contain the true value of the parameter with probability {0}.) "(ResultsClass.CutoffProbability);
      "Roughly speaking, this means that for every two segmental transitions there was one insertion or deletion event. ";
      "Just like substitution events, insertion and deletion events can be informative about phylogeny. ";
      "Unlike the earlier analysis of amino acid sequence data, the insertion and deletion events were strongly informative about ";
         "specific tree topologies, and this tree support could change depending on the homology assignments for the alignment.";
    };

    style.BodyPar {
      "In all subsequent analyses, we use the three topologies presented in "
       style.FigureReference(Figures.ModelTreesUsed); ". ";
      "Although there is considerable debate about the topology of the Romance languages, in recent decades most specialists have converged on the view that the first two clades to ";
       "form are Sardinian followed by Romanian";
       Citation {Hall1950; Hall1976; Dardel1985; Swiggers2001; Vallejo2012; Buchi2015; Dworkin2016a}; DotSpace;
      "Since Sardinian is not in our study group, the clade containing Romanian is the first to form in each of the trees in ";
       style.FigureReference(Figures.ModelTreesUsed); DotSpace;
      "The sub-trees containing the remaining dialects differ in their topologies, but they all contain Spanish and Portuguese as a clade, as well as Catalan, French, and Walloon. ";
    };

    style.BodyPar {
      "There is extensive debate in the literature concerning the relationship between Classical Latin, Vulgar Latin, and the Romance languages"; Citation {Posner1996; Harris2003; Chang2015; Heggarty2023; Goldstein2024}; DotSpace;

      "The central question is whether Latin (be it Classical or Vulgar) is a sampled ancestor of the Romance languages or their sibling"; DotSpace;

      "In this study, we assume the latter as Latin is an outgroup to the Romance languages."; DotSpace;

      "This decision was motivated by practical considerations and not linguistic ones, as a tree model allowing sampled ancestry is more complicated than the one used in this paper"; DotSpace;
    };

    style.AddFigure(Figures.ModelTreesUsed, FigureOptions.Top | FigureOptions.Bottom, 70%);

  };
}

//======================================================================

class RatioClass {
  var int    Numerator,
             Denominator;
  var double Ratio;

  Constructor(int numerator, int denominator) {
    Numerator   = numerator;
    Denominator = denominator;
    Ratio       = Numerator / Denominator;
  }

  override GetLayoutSpan = Span {
    Span {
      TextDigits: 1;
      100.0 * Ratio;
    };
    "% (";
    Numerator;
    " out of ";
    Denominator;
    ")";
  };
}

//======================================================================

class PartitionValueClass {
  var double         Value;
  var PartitionClass Partition;

  Constructor(PartitionClass p, double value) {
    Partition = p;
    Value     = value;
  }

  static int CompareFunction(PartitionValueClass v1, PartitionValueClass v2) = v1.Value.Compare(v2.Value);

  override GetLayoutSpan = Span {
    Partition.ShowPlural;
    " (";
    Span {
      TextDigits: 3;
      TextSignificant: true;
      Value;
    };
    ")";
  };
}

//======================================================================

readonly SegmentModelsClass PaperSections.SegmentModels = new;

class SegmentModelsClass: ContentClass {
  Constructor {
    super.Constructor("Models of segmental change");
  }

  override GetBody(ContentStyleClass style, title) = Block {
    var data     = MainResults.Data;
    var rule     = data.Rule;
    var segments = data.UniqueSegments.Length - 1;
    var rp       = rule.Filters.Length;


    style.TitlePar(title) {
      "We consider three models of segmental change in this study: ";
      PoissonModel; ", a model isomorphic to the model of DNA sequence evolution first described by Jukes and Cantor";
      Citation {Jukes1969};
      " with equal rates between all pairs of states and in which the number of substitutions follows a Poisson distribution (hereafter referred to as the "; style.SQuote{Defs.PoissonModel.Name}; " model); ";
      UnequalModel; ", a model isomorphic to the model of DNA sequence evolution first described by Felsenstein";
      Citation {Felsenstein1981};
      " in which the rate of change between a pair of segments is proportional to the equilibrium frequency of the destination segment; ";
      "and "; NaturalClassModel; ", the "; NaturalModelName; ", in which segments that share articulatory properties are grouped together with different rates of change within and between these segmental classes. ";

    };

    style.BodyPar {
      "The number of estimated parameters varies across models. ";
      "The first model, "; PoissonModel; ", has no free parameters. ";
      "The second model, "; UnequalModel; ", has "; segments; " free parameters (one less than the number of segments). ";

      "The "; NaturalModelName; ", "; NaturalClassModel; ", has "; rp*(rp-1)/2 + rp; " additional segmental class rate parameters: ";
      Equation {segments; Tex.Plus; (rp*(rp-1)/2 + rp); Tex.Equals; segments + rp*(rp-1)/2 + rp}; " free parameters.";
    };
  };
}

//======================================================================

readonly ModelComparisonClass PaperSections.ModelComparison = new;

class ModelComparisonClass: ContentClass {
  Constructor {
    super.Constructor("Model Comparison");
  }

  SelfArrow(text) = Span {text; Tex.rightarrow; text};

  override GetBody(ContentStyleClass style, title) = Block {
    var data = MainResults.Data;
    var rule = data.Rule;
    var rp   = rule.Filters.Length;

    style.BodyPar {
      "We compared the fit of the three models described above in section 3 to the data using the Bayes factor. ";
      "The Bayes factor is the ratio of the marginal likelihoods, ";
    };

    style.AlignEquations {
      style.LineEquation(Equations.BayesFactorEq);
    };

    style.ResumePar {
      "with ratios greater than one favoring model "; ModelI; ". ";
      "As the models examined are nested, we could calculate the Bayes factor using the Savage-Dickey ratio";
        Citation {Dickey1971}; ", ";
        "which is the ratio of the posterior to prior densities evaluated at the restriction that makes the parameter-rich model equivalent to the simpler model. "
      "The "; NaturalModelName; " explains the data substantially better than the two simpler models, with log Bayes ";
      // TODO: Maybe update the log bayes factor numbers dynamically, though this will be more tricky.
      "factors of ";
      Equation {Tex.ln; BayesFactor12; Tex.Equals; -1074.2}; " and ";
      Equation {Tex.ln; BayesFactor23; Tex.Equals; -117.3};
      ", respectively, for a comparison of "; PoissonModel; " to "; UnequalModel; " and "; UnequalModel; " to "; NaturalClassModel; ". ";
      "This indicates overwhelming support for the more parameter-rich "; NaturalModelName;
      Citation {Jeffreys1939}; DotSpace;
    };

    style.AddFigure(Figures.QRatesDiagonal, FigureOptions.Top | FigureOptions.Bottom | FigureOptions.Full);


    var partitions = data.Rule.Partitions;
    var diagonal   = new ListClass<PartitionValueClass>(partitions.Length);

    style.BodyPar {
      style.FigureReference(Figures.RateChart);
      " shows the estimated rates of change between the "; rp; " groups of the "; NaturalModelName; DotSpace;
      "Rates of change are generally highest among segments in the same class. ";
      "The estimated rates of change from one segment to another under the "; NaturalModelName; " are ";

      var stats       = MainResults.MainRun.NCQRates;
      var numSegments = data.UniqueSegments.Length - 1;
      var smallOnes   = new ListClass<PartitionClass>(partitions.Length);
      var numClasses  = partitions.Length;
      var cntSame     = 0;
      var cntDiff     = 0;
      foreach (var pi in partitions) {
        diagonal.Add(new(pi, stats[pi.Index, pi.Index].Mean));
        foreach (var pj in partitions) {
          var val = stats[pi.Index, pj.Index].Mean * numSegments;
          if (val >= 1.0) {
            if (pi == pj)
              cntSame++;
            else
              cntDiff++;
          }
        }
      }

      style.TextList {
        TextDigits: 2;
        foreach (var p in partitions) {
          var val = stats[p.Index, p.Index].Mean * numSegments;
          if (val < 1.0)
            smallOnes.Add(p);
          val;
        }
      };

      " times higher than expected under an equal rates Poisson model for ";
      style.TextList {
        TextCase: TextCases.AllLower;
        (each partitions).ShowPlural;
      };
      ", respectively. ";

      "(In other words, the ";
      style.TextList {
        TextCase: TextCases.AllLower;
        SelfArrow(each smallOnes);
      };
      " rates were lower than would be expected if all rates of change were the same.) ";
      "Long vowels and diphthongs counter the general pattern as they transition more often to short vowels than to long vowels or diphthongs, a change ";
        "we discuss further below" DotSpace;

      var same = new RatioClass(cntSame, numClasses);
      var diff = new RatioClass(cntDiff, numClasses*(numClasses-1));

      if (same.Ratio > diff.Ratio) {
        "Note that "; same; " of the changes within a class are higher than expected under an equal rates model, whereas ";
        diff; " of the changes between different natural classes are higher than expected under an equal rates model, ";
        "supporting the pattern of a generally higher rate of change between segments assigned to the same natural class. ";
      }
      else
        System.Assert(false, "Inconsistency between text and data!");

      //"Second, short vowels exhibit the highest rates along the diagonal and diphthongs the lowest. ";
      //"Both characteristics are due to frequency, as short vowels are the most frequent class and diphthongs the least. ";
      //"Finally, the rate of change from nasal consonants to nasal vowels is a pathological trait of the model: ";
      //"it infers transitions from nasal consonants to nasal vowels (and vice versa) as opposed to oral vowels.";
    };

    style.BodyPar {
      style.FigureReference(Figures.EquilibriumCharts);
      " shows the estimated equilibrium frequencies of the "; NaturalModelName; " "; NaturalClassModel; DotSpace;
      "The equilibrium frequencies are used in two ways when calculating the probability of the observed data. ";
      "First, they are used as the probability of the segmental state at the root of the tree. ";
      "Second, they modify the rate of change between segments for models "; UnequalModel; " and "; NaturalClassModel;
      ", with the rate of change proportional to the frequency of the destination segment. ";
      "Indeed, the rates of change to ";
      style.TextList {
        TextCase: TextCases.AllLower;
        diagonal.ToSortedArray(true, @PartitionValueClass.CompareFunction)[0..2]
      };
      " are the highest as are the estimated equilibrium frequencies for those classes. ";
      "The estimated equilibrium frequency generally tracks the frequency of the segments in the data. ";
    };
 };
}

//======================================================================

readonly WordTransformationClass PaperSections.WordTransformation = new;

class WordTransformationClass: ContentClass {
  Constructor {
    super.Constructor("Segmental Change");
  }

  override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      style.FigureReference(Figures.QRatesDiagonal); " presents the absolute values of the diagonal elements of the rate matrix of the continuous-time Markov model describing phonemic ";
          "change estimated under the "; NaturalModelName; DotSpace;
      "These diagonal elements can be interpreted as a measure of segmental volatility, since they are the sum of the rates at which they transition to other segments. ";
      "When the process is in segment "; sym.i; ", "; -qii; " is the rate at which it changes to another segment. ";
      "The higher the rate, the more rapidly a change to another segment occurs on average. ";
      "The most striking aspect of "; style.FigureReference(Figures.QRatesDiagonal); " is the division between vowels and consonants. ";
      "With the exception of affricates, vowels are the most volatile segments and within this class diphthongs and long vowels are the least stable. ";
      "Overall, the most stable segments are all consonants, with the stops the most stable of all. ";
      "The rates of change are also remarkably similar within each class. ";
      "For instance, all the long vowels cluster together, as do the affricates, fricatives, short vowels, nasal vowels, fricatives, nasal consonants, and stops. ";
      "The only exceptions are the liquid "; IPASegments.r;
      " (which appears with the fricatives) and mid-front vowel "; IPASegments.ay; " (which appears among the nasal vowels).";
      //"In contrast to the rates in Figure [rate figure], those in ";
      //style.FigureReference(Figures.QRatesDiagonal); " assume the process is in segment "; sym.i;
      // " and measures the rate of flow away from it (to any other segment). ";
    };

    style.BodyPar {
      //style.FigureReference(Figures.QRatesTop); " presents the "; Enumerators.Cardinal(TopCount); " transitions with the highest instantaneous rates of change. ";
      //"In contrast to "; style.FigureReference(Figures.QRatesDiagonal); " above, the focus here is on individual sound changes. ";
      //"The results paint a similar picture, however. The input segments in ";
      //style.FigureReference(Figures.QRatesTop); " are either long vowels or diphthongs. ";
      //"The output segments are similarly restricted. ";
      //"Although there are eight transitions in the graph, there are only two output segments, the mid-high front vowel /e/ and the high back vowel /u/. ";
    };
  };
}

//======================================================================

readonly WordSegmentRelationshipsClass PaperSections.WordSegmentRelationships = new;

class WordSegmentRelationshipsClass: ContentClass {
  Constructor {
    super.Constructor("Segmental Alignments");
  }

  override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      var align1 = Figures.AlignmentExample1;
      var index1 = align1.Examples[0].FindAlignment(MainResults.MainRun);

      "Our method treats the homology relationships of segments between languages as a random variable. ";
      "We summarize the posterior distribution by constructing a credible set of alignments, where a credible set of alignments is constructed by ordering the alignments for a cognate from the highest to lowest posterior probability. ";
      "The alignments are then included in a credible set, starting with the alignment with the highest posterior probability, until the cumulative posterior probability is {0}. "(ResultsClass.CutoffProbability);
      style.FigureReference(align1); " shows alignments for the concept ";
      style.SQuote {
        TextCase: TextCases.AllLower;
        align1.Examples[0].Concept
      };
      ", which illustrates three key properties of all posterior alignments. ";
      "First, the distributions of credible sets are heavily weighted in favor of a single alignment with most of the posterior probability. ";
      "In this case, one alignment had a posterior probability of ";
      Span {
        TextDigits: 2;
        index1.Alignments[0].Prob;
      };
      DotSpace;
      "Second, insertions and deletions occur predominantly at word-end, where gaps are more frequent on average compared to other positions (";
         style.FigureReference(Figures.GappinessChart); "). ";
      "Finally, the alignments tend to assign segments from the same class to the same column in the alignment. ";
    };

    style.AddFigure(Figures.EquilibriumCharts, FigureOptions.Top | FigureOptions.Bottom);


    style.BodyPar {
      var align2 = Figures.AlignmentExample2;

      "Interestingly, the distribution of alignments depends on the model of segmental change. ";
      style.FigureReference(align2); " shows the {0} credible set of alignments for the concept "(ResultsClass.CutoffPercent);
      style.SQuote {
        TextCase: TextCases.AllLower;
        align2.Concept
      };
      " under the ";
      style.TextList {
        align2.Models;
      };
      " models. ";
      "The credible set contains ";
      align2.Poisson.ShowAlignmentNumber;
      " model, but only ";
      align2.NaturalClass.ShowAlignmentNumber;
      " model. ";
      "This difference makes sense given the rates estimated under the "
      align2.NaturalClass; " ("; style.FigureReference(Figures.RateChart); "). ";
      "For example, the rate of change between "; IPASegments.u; " and "; IPASegments.oh; " are estimated to be high, whereas the rate between consonants and "; IPASegments.oh; " is low. ";
      "The distribution of alignments under the ";
      align2.Poisson; " often makes consonants homologous with "; IPASegments.oh; ". ";
      "Under the "; align2.NaturalClass;
      " model, however, the same alignments are improbable, as the rates of substitution between those alignments are low.";
    };

    style.AddFigure(Figures.RateChart, FigureOptions.Top | FigureOptions.Full, 60%);
  };
}

//======================================================================

readonly DiscussionSectionClass PaperSections.DiscussionSection = new;

class DiscussionSectionClass: ContentClass {
  Constructor {
    super.Constructor("Discussion");
    AddContent(PaperSections.OtherApproaches);
    AddContent(PaperSections.InsightsSoundChange);
    AddContent(PaperSections.SegmentalSampling);
  }
}

//======================================================================

readonly OtherApproachesClass PaperSections.OtherApproaches = new;

class OtherApproachesClass: ContentClass {
  Constructor {
    super.Constructor("The TKF91 Framework Compared to Other Approaches");
  }

  override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      "Approaches to sound change in the linguistics literature vary. ";
      "One prominent view identifies phonemes as the basic units of change"; Citation {Bloomfield1933}; ", ";
      "according to which sound change is abrupt and non-independent. ";
      "It is abrupt in that there are no intermediary stages in a transition from "; IPASegments.ah; " to "; IPASegments.oh; ", for instance. ";
      "It is non-independent since the transition from one phoneme to another across all lexical items is regarded as a single event. ";
      "Other scholars have emphasized the role of acoustic and auditory phonetics in sound change";
      Citation {Blevins2004a; Ohala2003; Ohala2012};
      ", while yet another view contends that sound change occurs by gradually making its way through the lexicon in a process known as lexical diffusion"; Citation {Chen1975a; Phillips2015}; DotSpace;
    };

    style.BodyPar {
      "Our framework is not situated within any one of these traditions, but rather shares affinities with the phonemic approach and lexical diffusion. Since our observations are phonemic strings, it is phonemes that undergo insertions, deletions, and transitions. ";
      "In contrast to the standard assumption of historical linguistics, however, these changes are treated as independent. ";
      "For instance, a change from "; IPASegments.ah; " to "; IPASegments.oh; " is not modeled as a single transition across all word-forms in our study. ";
      "Instead, a rate of change is inferred based on the homologies of "; IPASegments.ah; " and "; IPASegments.oh; " in the data and how often the former transitions to the latter. ";
    };

    style.BodyPar {
      "The application of the TKF91 model to linguistic data is similar to the analysis of Bouchard-Côté et al. ";
      Citation{BouchardCote2013};
      ", who also treats cognate word-forms as observations. Their approach differs, however, in that they applied a string transducer model ";
      Citation{Holmes2001};
      " to characterize segmental transitions. The transducer model has the advantage that it can account for many of the processes that are known to influence segmental change, such as context dependence. Our method, as currently implemented, does not consider the environment of segmental changes. However, unlike the transducer model, the TKF91 model is a historical model with well-defined events that can transform a word. In fact, the likelihood accounts for all the histories of insertion, deletion, and segmental substitution that could have led to the observed words sampled from the ";
      Enumerators.Cardinal(MainResults.Data.Taxa.Length);
      " languages. ";
      "These events occur at rates that can be estimated. ";
      "Since the TKF91 model is event-based, it is a natural starting point for modeling sound change even if that starting point does not account for processes that are accommodated for in other models, such as the string transducer model. ";
    };

    style.BodyPar {
      "The complexity of the likelihood calculations under the TKF91 model is exponential in the number of taxa and word length. Specifically, the complexity is of order ";
      Equations.LikelihoodComplexity;
      " where "; NumTreeLeaves; " is the number of leaves on the tree and "; GMLength; " is the geometric mean of the word lengths ";
      Citation{Lunter2003}; DotSpace;
      "The application of the TKF91 model to linguistic data is not as problematic as it is for DNA sequence data because words are much shorter than DNA sequences, with ";
      Equations.TypicalWordLength; DotSpace;
      "That said, one can obtain likelihood calculations that are linear in the number of tips if one assumes that the insertion rate is independent of the word length, instead of the overall insertion rate being ";
      Equations.OverallInsertionRate; " as it is under the TKF91 model ";
      Citation{BouchardCote2013b}; DotSpace;
      "This model—the Poisson Indel Process (PIP)—could be applied to linguistic data sets that are composed of many more languages than we analyzed here. Since the alignments visited by the MCMC procedure are similar in length, the PIP model might be a sensible option for linguistic data. ";
    };
  };
}

//======================================================================

readonly InsightsSoundChangeClass PaperSections.InsightsSoundChange = new;

class InsightsSoundChangeClass: ContentClass {
  Constructor {
    super.Constructor("Insights into Sound Change");
  }

   override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      "In contrast to traditional historical phonology, which focuses on identifying sound changes and their relative chronologies, the TKF91 approach delivers insights into overarching trends in the evolution of sounds and segmental inventories" DotSpace;
     "We focus here on three measures that provide insights into both, specifically, the diagonal of the Q matrix, transition rates within and between natural classes, and equilibrium frequencies"; DotSpace;
     "Although other quantitative measures of sound change have beeen developed in recent years, these measures are a new addition to the field" DotSpace;
    };

    style.BodyPar {
      "As noted above in section 3, the diagonal of the Q matrix is the rate at which a particular segment transitions to any other and thus measures its diachronic stability"; DotSpace;

      "The prominent division between vowels and consonants in "; style.FigureReference(Figures.QRatesDiagonal); " is consistent with previous studies of Romance historical phonology"; DotSpace;

      "One of the major sound changes that distinguishes Latin from Romance is the loss of phonemic vowel length"; Citation{Janson1979; Loporcaro2015}; DotSpace;

      "In a similar vein, the diphthongs of Classical Latin start to undergo monophthongization within Latin itself"; Citation {new CitationClass(Posner1996, 106)};  DotSpace;

      "Our results are also consistent with the study of"; Citation{new CitationClass(Moran2021, 92..95)}; ", who find that vowels change faster than consonants in Indo-European"; DotSpace;

      "It is important to note that they are measuring the rate at which the size of segmental inventories changes, which is not what the diagonal of the Q matrix measures"; DotSpace;

      "In other words, their results suggest that in Indo-European vowel inventories are expanding at a faster rate compared to consonant inventories"; DotSpace;

      "By contrast, our results do not bear on the size of the vowel inventories per se"; DotSpace;

      "Our results are broadly consistent with the basic consonant inventory of Nikolaev and Grossman"; Citation{Nikolaev2020}; " and the primal consonants of Bybee and Easterday";
          Citation{Bybee2022}; ". ";

      "WHAT ARE THESE INVENTORIES";

    };

    style.BodyPar{
      "comparison with Moran2021 results re vowels vs. Cs in IE"; Citation {Marsico1999; Moran2021}; DotSpace;
    };

     style.BodyPar{
      "The average transition rates in "; style.FigureReference(Figures.RateChart); " profile a different aspect of segmental stability, as they include reference to both the input and output segments"; DotSpace;

      "In addition, the focus is not on transitions among individual segments, but rather transitions within and between natural classes" DotSpace;

      "For instance, the circles on the diagonal represent the average transition rate within each natural class"; DotSpace;

      "The liquids exhibit the highest rate and the diphthongs the lowest"; DotSpace;

      "The liquids are thus the class of sounds that are on average more prone to transition to other liquids compared to a segment from any other class"; DotSpace;

      "At the opposite end of the spectrum, when a diphthong changes it is unlikely to transition to another diphthong;" DotSpace;

      "Looking across the row for diphthongs in "; style.FigureReference(Figures.RateChart); " the highest rate of change is with the short vowels"; DotSpace;

      "These rates are driven by two common sound changes in the history of Latin and Romance, namely vowel breaking, whereby a monophthong becomes a diphthong, and monophthongization of diphthongs"; DotSpace;

      "The highest off-diagonal rates in "; style.FigureReference(Figures.RateChart); " all involve vowels, which is in line with the results discussed above" DotSpace;

      "In addition to diphthongs and short vowels, the highest rates are also found among short vowels and long vowels as well as nasal vowels and nasal consonants" DotSpace;

      "This latter trend is driven by the emergence of nasalized vowels in French and Portuguese"; DotSpace;

    };

     style.BodyPar{
       "The equilibrium frequencies presented in " style.FigureReference(Figures.EquilibriumCharts); " provide insights into phonemic constrasts that Romance languages rely on most"; DotSpace;

       "The combined frequency of short vowels and stop consonants is over 0.5, which means that half of the segments of a word on average will be either stops or consonants"; DotSpace;

       "This tendency is the result of the diachronic trends discussed above"; DotSpace;

       "With the reduction of diphthongs and long vowels, their functional load decreases while that of short vowels consequently increases"; DotSpace;
    };

     style.BodyPar{
      "something about model comparison and superior performance of the Nat Class model?"; DotSpace;
    };

  };
 }


//======================================================================

readonly SegmentalSamplingClass PaperSections.SegmentalSampling = new;

class SegmentalSamplingClass: ContentClass {
  Constructor {
    super.Constructor("Segmental Sampling");
  }

   override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      "Under our framework a new issue in linguistic phylogenetics emerges, segmental sampling"; Citation {References.Dockum2019}; DotSpace;
      "Certain segmental transitions can play a crucial role in topological inference, but under a sampling scheme such as ours, in which selection of concepts is guided by a Swadesh list, ";
      "there is no guarantee that the necessary segmental correspondences will be sampled. ";
      "There is the further question of the frequency distribution of segments in the dataset. ";
      "Some segments will be sampled more often than others simply because they are more frequent in a language. ";
      "The sampling can thus influence estimates of equilibrium frequencies and transition rates. ";
      "The principles that guide the creation of Swadesh sampling schemes (namely low rates of borrowing and lexical change) will likely have to be modified under our framework to take into account issues of segmental distribution. ";
    };
  };

 }


//======================================================================

readonly LimitationsClass PaperSections.Limitations = new;

class LimitationsClass: ContentClass {
  Constructor {
    super.Constructor("Limitations of the event-based model");
  }

  override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      "Our results are based on a unigram model of segmental transition in which the three possible events described above are applicable only to individual segments. ";
      "Certain patterns of sound change cannot therefore be captured under such a model. ";
      "For instance, metathesis, a change in which two segments exchange positions, is modeled as two separate transitions. ";
      "Friulian "; TextIpa{"tarɔnt"}; " ultimately descends from Latin "; TextIpa{"rotundum"}; Space; style.SQuote{"round"};
      ", with the initial sequence "; TextIpa{"rVt"}; " of Latin having metathesized to "; TextIpa{"tVr"}; DotSpace;
      "Under the TKF91 model, this single event becomes two, with one change from /r/ to /t/ and another from /t/ to /r/ (leaving aside the possibility of intermediate transitions). ";
      "A second limitation is that the context in which a segmental transition takes place plays no role in the estimation of transition rates. ";
      "It is well known that the evolution of phonemes can be sensitive to neighboring sounds. ";
      "Finally, there is currently no straightforward way to incorporate supersegmental features such as stress, although it plays a crucial role in the phonological history of the Romance languages. ";
    };
  };
}

//======================================================================

readonly AdvantagesClass PaperSections.Advantages = new;

class AdvantagesClass: ContentClass {
  Constructor {
    super.Constructor("Advantages of the event-based approach");
  }

  override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      "Our event-based approach to linguistic history has the power to transform the discipline by offering an inroad into questions that were previously intractable. For example, questions related to the relationship between phonological change and the phonemic inventory of a language can now be addressed. Does the frequency of a phoneme affect its diachronic stability? To what extent is phonemic change sensitive to the size and structure of the phonemic inventory of a language? What is the role of natural classes in sound change? This last question can be addressed through the comparison of models with different numbers of rate parameters.";
     };

    style.AddFigure(Figures.GappinessChart, FigureOptions.Top | FigureOptions.Bottom);

    style.BodyPar {
      "By casting the problem of language change in a statistical framework, we inherit the benefits of the statistical approach to estimate model parameters and, perhaps more importantly, to compare alternative models of language change to find the model that best explains the data. In this way, linguists can learn about language evolution by devising models that account for potential linguistic phenomena, then testing the model against models that do not account for the linguistic feature. This approach has proven successful in molecular evolution where models have been described and tested that account for many evolutionary processes of molecular change.";
    };

    style.AddFigure(Figures.AlignmentExample1, FigureOptions.Top | FigureOptions.Bottom | FigureOptions.Full);

    style.BodyPar {
      "The method can be extended to handle more complex segmental changes (such as those involving context dependency). Moreover, the event-based approach has the potential to improve divergence-time estinmation. Divergence-time estimation relies on estimating the number of events that occurred along the branches of the tree. When applied to abstract cognate relationships, it is not clear what exactly is being counted along the branches. By contrast, the possible events in our event-based approach are well defined: segmental transitions, insertions, or deletions.";
    };

    style.AddFigure(Figures.AlignmentExample2, FigureOptions.Top | FigureOptions.Bottom | FigureOptions.Full);

    style.BodyPar {
      "In sum, our approach offers not simply a new framework for linguistic phylogenetics, but one for computational historical linguistics in general, which can be expanded and refined in various ways. For example, it can be combined with methods of automatic cognate detection ";
      Citation {References.BouchardCote2013}; DotSpace;
      "It may be possible to extend the method to address more complicated questions, such as context-dependent changes and changes involving multiple segments (such as metathesis). ";
    };

    style.BodyPar {
                  "The code and data for this study are available on ";
      Span {
        TipAction: new URLClass("https://github.com/jhuelsenbeck/Linguistomics");
        TextColor: Colors.Blue;
        "GitHub";
      };
      DotSpace;
    };
  };
}

//======================================================================

readonly MethodsSummaryClass PaperSections.MethodsSection = new;

class MethodsSummaryClass: ContentClass {
  Constructor {
    super.Constructor(Lang.Methods);
    AddContent(PaperSections.ModelInference);
    AddContent(PaperSections.CognateWordForms);
    AddContent(PaperSections.SegmentModels);
    AddContent(PaperSections.DataCuration);
  }

  override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      "A detailed description of the model and analysis can be found in the Supplemental Material. ";
      "What follows is an outline, sufficient in detail to provide an understanding of the model and experiments performed in this study.";
    };
  };
}

//======================================================================

readonly ManualAlignmentClass TableFigures.ManualAlignment = new(MainResults.Data);

class ManualAlignmentClass: ContentClass {
  var DataSetClass Data;

  Constructor(DataSetClass data) {
    super.Constructor("An example of an aligned cognate set");
    Data = data;
  }

  WordDisplay(ContentStyleClass style) = style.SQuoteEnd {
    TextCase: AllLower;
    Data.FigureConcept.Name;
  };

  override GetCaption(ContentStyleClass style) = Span {
    "Manual alignment of the words for the concept ";
    WordDisplay(style);
  };

  override GetBody(ContentStyleClass style, title) = LanguageTable([ColumnClass.Fit(2 inch), ColumnClass.Fit(2 inch), ColumnClass.Fit(1 inch)]) {
    ParAlignment: Center;
    TextHeight: Math.Max(ExtentWidth * 0.02, 9 pts);

    var cognate = Data.GetCognate(Data.FigureConcept);
    LanguageTitleRow {
      Lang.Language;
      Lang.PhonemicRep;
      Lang.Alignment;
    };

    foreach (var word in cognate.Words) {
      Row {
        word.Language;
        TextIpa {word};
        Span {
          foreach (var segment in word.Padded)
            segment.ShowSegment;
        }
      };
    }
  };
}

//======================================================================

readonly WordCountTableClass TableFigures.WordCountTable = new(MainResults.Data);

class WordCountTableClass: ContentClass {
  var DataSetClass Data;

  Constructor(DataSetClass data) {
    super.Constructor("Manual Alignment");
    Data = data;
  }

  override GetCaption(ContentStyleClass style) = Span {
    "Manual alignment of the words for the concept ";
    style.SQuote {
      TextCase: AllLower;
      Data.FigureConcept.Name;
      DotSpace;
    };
  };

  override GetBody(ContentStyleClass style, title) = LanguageTable([1.5 inches]) {
    LanguageTitleRow {
      Lang.Language; Lang.WordForms; Lang.SegmentCount;
    };

    foreach (var taxon in Data.Taxa) {
      Row {
        taxon.Language;
        taxon.WordCount;
        Span {
          TextGroup: true;
          taxon.SegmentCount;
        }
      };
    }
  };
}

//======================================================================

readonly ModelInferenceClass PaperSections.ModelInference = new;

class ModelInferenceClass: ContentClass {
  Constructor {
    super.Constructor("Model and Statistical Inference");
  }

  InsertionLessThanDeletion = PaperStyle.Equation {InsertionRate; Tex.lt; DeletionRate};

  override GetBody(ContentStyleClass style, title) = Block {
    var rule = MainResults.Data.Rule;

    style.TitlePar(title) {
      "We assume that the languages under investigation are related to one another through an unknown phylogenetic tree, ";
      UnknownTree;
      ", that contains information on the relatedness of the languages ";
      SpanParens {Topology};
      " and the expected number of sound substitutions "; ExpectedEvents; " that occur along each branch of the tree. ";
      "Language evolves along the branches of the tree according to the TKF91 model"; Citation {Thorne1991}; " which allows either a segmental transition, insertion, or deletion to occur in an instant of time. ";
      "Insertions and deletions occur at rates "; InsertionRate; " and "; DeletionRate; " respectively, with "; InsertionLessThanDeletion; DotSpace;
      "Phonemic substitution is modeled as a continuous-time Markov model with phonemes as the states of the process (as noted above, our inventory consists of "; MainResults.Data.UniqueSegments.Length; " phonemes). ";
      "The rates of change between all pairs of states are contained in the rate matrix "; RateMatrix; ", which has parameters ";  RateMatrixParams; DotSpace;
    };

    style.AddTable(Figures.PartitionAssignments, FigureOptions.Top | FigureOptions.Bottom, 98%);

    style.BodyPar {
      "We perform estimation in a Bayesian framework, basing parameter estimates on the joint posterior probability distribution, ";
    };

    style.AlignEquations {
      style.LineEquation(Equations.BayesianEstimation);
    };

    style.ResumePar {
      "where "; SegmentalInfo; " are the observed segments for the cognate words. ";
      "The likelihood function, "; LiklihoodFunction;
      ", is calculated using the algorithm described by Lunter "; textit{"et al."}; Citation {Lunter2003}; DotSpace;
      "We use priors for the model parameters that are standard in phylogenetics, except for the rate parameters for the insertions and deletions, ";
      "which are assumed to follow independent and identically distributed exponential distributions with "; InsertionLessThanDeletion; DotSpace;
      "We numerically approximate the posterior distribution of the parameters using MCMC. ";
      "Specifically, we constructed a Markov chain that has as its states the parameters of the model and a stationary distribution that is the posterior distribution of interest. ";
      "Samples from this chain when at stationarity are valid, albeit dependent, samples from the posterior distribution. ";
      "Besides sampling the phylogenetic parameters of the model, the chain also samples segmental alignments"; Citation{Lunter2004}; DotSpace;
    };

    style.AddFigure(Figures.ConceptEncoding, FigureOptions.Top | FigureOptions.Bottom);

    style.BodyPar {
      var number = Enumerators.Cardinal(rule.Filters.Length);
      "Our model of segmental transitions is based on phonological natural classes, which are classes of segments that share phonetic properties. ";
      "The segmental inventory of our dataset was exhaustively partitioned into "; number; " classes, which are presented in ";
      style.TableReference(Figures.PartitionAssignments); DotSpace;
      "This "; style.SQuote{rule.Name}; " model allows different rates among the "; number; " classes of segments. ";
      " It has "; MainResults.Data.UniqueSegments.Length; " parameters for the equilibrium distribution and ";
      (rule.Filters.Length-1)^2-1; " parameters describing rates among natural classes. ";
      "The equilibrium frequencies are modeled as random variables drawn from a flat Dirichlet prior distribution. ";
    };
  };
}

//======================================================================

readonly ConceptEncodingClass Figures.ConceptEncoding = new(MainResults.Data, MainResults.Data.DataConcept);

class ConceptEncodingClass: ContentClass {
  var DataSetClass        Data;
  var ExampleConceptClass Concept;

  Constructor(DataSetClass data, AttributeClass concept) {
    super.Constructor("Concept Encoding");
    Data    = data;
    Concept = new(data, concept);
  }

  override GetCaption(ContentStyleClass style) = Span {
    "The concept "; style.SQuote{TextCase: TextCases.AllLower; Concept.Name}; " as coded in the data file.";
  };

  override GetBody(ContentStyleClass style, title) = Paragraph {
    ParAlignment: Center;
    Frame(2.5 inches) {
      SourcePar(Data, Concept.Concept)
    };
  };
}

//======================================================================

readonly SegmentEncodingClass Figures.SegmentEncoding = new;

class SegmentEncodingClass: ContentClass {
  Constructor {
    super.Constructor("Segment Encoding");
  }

  override GetCaption(ContentStyleClass style) = Span {
    "The IPA-Unicode encoding of a segment.";
  };

  override GetBody(ContentStyleClass style, title) = Paragraph {
    ParAlignment: Center;
    Frame {
      IPASegments.VlAlveolarNSAffricate.Display(null, 20 pts);
    }
  };
}

//======================================================================

readonly ConclusionClass PaperSections.Conclusion = new;

class ConclusionClass: ContentClass {
  Constructor {
    super.Constructor("Conclusion");
    AddContent(PaperSections.Limitations);
    AddContent(PaperSections.Advantages);
  }

  override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      revu "Here we sum it all up. ";

    }
  };
}

//======================================================================

readonly AcknowledgementsClass PaperSections.Acknowledgements = new;

class AcknowledgementsClass: ContentClass {
  Constructor {
    super.Constructor("Acknowledgements");
  }

  override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      style.ShowInitials(People.Huelsenbeck_John); " was supported through NSF (1759909) and the Koret Foundation. We thank "; style.ShowPerson(People.Lunter_Gerton); " for help with the TKF91 model.";
    }
  };
}

//======================================================================

readonly ContributionsClass PaperSections.Contributions = new;

class ContributionsClass: ContentClass {
  Constructor {
    super.Constructor("Author contributions statement");
  }

  override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      style.ShowInitials(People.Goldstein_David) " collected data, ";
      style.ShowInitials(People.Buchi_Éva); " reviewed it, ";
      style.ShowInitials(People.McCreight_Shawn); " developed the control software, and ";
      style.ShowInitials(People.Huelsenbeck_John); " developed the MCMC software. ";
      style.ShowInitials(People.Goldstein_David); CommaSpace;
      style.ShowInitials(People.McCreight_Shawn); ", and ";
      style.ShowInitials(People.Huelsenbeck_John); " wrote the manuscript. ";
    }
  };
}

//======================================================================

readonly MethodsClass PaperSections.Methods = new;

class MethodsClass: ContentClass {
  const StateCount = 5;

  Constructor {
    super.Constructor(Lang.Methods);
//    AddTable(Figures.PartitionAssignments);
  }

  override GetBody(ContentStyleClass style, title) = Block {
    var data = MainResults.Data;
    var ec   = new ExampleConceptClass(data, data.ExampleConcept);

    style.TitlePar(title) {
      "We describe the assumptions of the models, how their parameters are estimated, and how different models of segmental evolution can be compared in a statistical framework.";
    };

    style.BodyPar {
      BodyTitle {"Phylogeny relating languages"}; DotSpace;
      "We assume that the languages in our study group are related by an unknown evolutionary tree, called a ";
      style.SQuote {Phylogeny.Name}; ", which we denote "; Phylogeny; DotSpace;
      "The phylogeny contains information on the topological relationships among "; NumLanguages;
      " sampled languages, as well as the divergence times of the languages or the amount of change that occurred between the languages. ";
    };

    style.BodyPar {
      style.FigureReference(Figures.ExampleTree); " shows an example of a phylogeny for "; SampledLanguages(data.Taxa.Length); " languages. ";
      "In the terminology of evolutionary biology, the tree is composed of "; style.SQuote{"nodes"}; " and "; style.SQuoteEnd{"branches"};
      "(By contrast, mathematicians call nodes and branches "; style.SQuote{"vertices"} " and "; style.SQuote{"edges,"}; " respectively.) ";
      "The nodes represent the tips of the tree, each of which is assigned a language, and the points on the tree where languages diverge. ";
      "Each tip is labeled "; (TipLabelNumbers); ". ";
      "The interior nodes are labeled "; TipLabelInterior; " in preorder sequence (i.e., ordered sequentially from the tips to the root). ";
      "The root node is always assigned the label "; TipLastLabel; DotSpace;
      "We denote the ancestor of node "; NodeIndex; " as "; AncestorNode(NodeIndex); DotSpace;
      "In the tree of "; style.FigureReference(Figures.ExampleTree); ", the ancestor of node 3 is "; Equation {AncestorNode(3); Tex.Equals; 13}; DotSpace;
    };

    style.BodyPar {
      "The branches connect the nodes of the tree and are represented as lines in "; style.FigureReference(Figures.ExampleTree); DotSpace;
      "The branch is assigned the label from its descendant node. In "; style.FigureReference(Figures.ExampleTree);
      ", for instance, the branch connecting nodes 13 and 14 is labeled 15. ";
    };

    style.AddFigure(Figures.ExampleTree, FigureOptions.Bottom | FigureOptions.Full, 70%);


    style.BodyPar {
      "A phylogeny is an information-rich graph. ";
      "For one, it contains information on the relationships of the languages. ";
      "This topological information is denoted "; Topology; DotSpace;
      style.FigureReference(Figures.ExampleTree);
      " for example, suggests that "; French; " and ";  Walloon; " are each others’ closest relatives. ";
      "They are more closely related to each other than they are to any another language on the tree because they share a more recent common ancestor that is not shared with any other languages. ";
      "This common ancestor is the node numbered 12 in "; style.FigureReference(Figures.ExampleTree); DotSpace;
      "There are many possible ways in which the languages in our study group can be related to one another, with the tree of ";
      style.FigureReference(Figures.ExampleTree);
      " depicting only one of the possibilities. ";
      "In fact, for the case in which ";
      SampledLanguages(data.Taxa.Length);
      " languages are considered, there are "
      BranchFormula(data.Taxa.Length);
      " possible trees relating the languages. ";
      "In general, the number of possible rooted trees is the product of the odd numbers up to, and including, ";
      MaxBranch;
      ": ";
      PossibleTrees; DotSpace;
      "Each topology is given a unique label, ";
      Equation {
        EllipsisList {
          Topology sub 1;
          Topology sub 2;
          Topology sub BN;
        };
      }; DotSpace;
      "The number of possible tree topologies becomes quite large very quickly. ";
      "Given ";
      var langnumber = 60;
      SampledLanguages(langnumber);
      " languages, for example, there are ";
      Span {
        TextEquation: true;
        TextScientific: true;
        TextDigits: 2;
        BranchFormula(langnumber);
      };
      " possible topologies, each depicting a unique and different way the languages can be related. ";
      "For comparison, the number of atoms in the universe is on the order of "; 10 sup 80; DotSpace;
    };

    style.BodyPar {
     "The interior nodes of the tree represent language divergence events that occurred at specific times in the past and are denoted ";
     Equation {
       Span {Bold; Time};
       Tex.Equals;
       SpanParens {
         EllipsisList {
           Time sub (NumLanguages Tex.Plus 1);
           Time sub (NumLanguages Tex.Plus 2);
           Time sub TipLastLabel;
         };
       }
     }; DotSpace;

     "The tip nodes are all assigned the time ";
     Equation {
       Time; Tex.Equals; 0;
     }; DotSpace;

     "We discuss in more detail below a stochastic model of language change. ";
     "However, the model we use, along with every other stochastic model for phylogenies, has an all-important parameter that describes the rate at which the language changes. ";
     "This parameter is called the substitution rate and denoted "; SubstitutionRate; DotSpace;

     "Without external information to constrain the divergence times, such as one language divergence time that is considered known, it is impossible to estimate divergence times. ";
     "The problem is that one obtains the same net divergence between two languages from a high rate of language evolution and a short divergence time separating the languages, or a low rate of language evolution and a long time separating the languages. ";
     "In fact, the expected number of evolutionary events that occurred between two languages that diverged at time "; Time; " is ";
     Equation {
       ExpectedEvents;
       Tex.Equals;
       2;
       Time;
       SubstitutionRate;
     }; DotSpace;

     "(The factor of two is introduced because the path between the two languages is the time from one language to the common ancestor, and then back up the tree to the other language.) ";
     "In this paper, we allow each of the "; MaxBranches; " branches of the tree to have an independent substitution rate. ";
     "The expected number of evolutionary events on the "; Ith; " branch of the tree is ";
     ExpectedEventsPerBranch;
     DotSpace;
     "In this study, we do not estimate the divergence times on the tree, but rather the compound parameter representing the branch lengths ";
     Equation {ExpectedEvents sub sym.i};
     ", which are in units of expected number of substitutions per segment (as described below). ";
    };

    style.AddFigure(Figures.Alignment, FigureOptions.Top | FigureOptions.Bottom | FigureOptions.Full, 80%);

    style.BodyPar {
      BodyTitle {"Data"}; DotSpace;
      "The similarities of words from different languages are informative about how the languages are related. ";
      "In this study, we use statistical methods developed in the field of evolutionary biology to estimate the relationships of species based on either the morphological characteristics of the species or the DNA sequences sampled from the same gene and compared across the species. ";
      "The methods assume that the characteristics compared across species are homologous. ";
      "Homology, in evolutionary biology, is similarity in some characteristic that is caused by common ancestry. ";
      "Consider as an example the following DNA sequences sampled from three species,";
    };

    BodyTable([1 inch, 5 inches]) {
      foreach (var a in attribute(ExampleAnimals).Children) {
        Row {
          TextHeight: 10 pts;
          a.Name;
          Cell {
            Span {
              TextFixed: true;
              a.Value;
              Tex.ldots;
            };
          };
        };
      }
    };

    style.BodyPar {
      "These are partial mitochondrial sequences from Gojobori"; Citation {Hayasaka1988}; DotSpace;
      "In the original paper, the complete data had ";
      SampledLanguages(12);
      " primate species and the sequences were each 898 nucleotides in length. ";
      "In a phylogenetic analysis of DNA sequenes, homology is assumed at two levels. ";
      "First, one assumes that the sequences that are compared are homologous. ";
      "Typically, homology at this level is established by sequence similarity and synteny of the gene (i.e., the gene that is compared across species is in the same, or at least similar, position along the chromosome when compared across species, which is another way of saying the gene that is compared has the same neighboring genes in all the species in the analysis). "
    };

    style.BodyPar {
      "Not only must the DNA sequences be homologous, but the fine-scale homology of the sequences must also be established. ";
      "The DNA sequences above are in an aligned form in which the fine-scale homology has been established; ";
      "each column of the alignment is considered to be homologous. ";
      "So, for example, the first column of the alignment which happens to be the nucleotide A in all three species is assumed to be homologous. ";
      "It is assumed that the common ancestor of gorillas, chimpanzees, and humans had the same gene, which also had a position that was homologous to the first column in the alignment. ";
      "Fine-scale homology is established using computer programs in a process called "; style.SQuoteEnd{"alignment"};
      "Importantly, phylogenetic methods assume that the homology established by the alignment program is correct.";
    };

    style.BodyPar {
      "Our approach to the underyling data for phylogenetic inference is novel within linguistics. ";
      "Like others, we concentrate on the so-called "; style.SQuote{"basic vocabulary"}; " of a language ";
      Citation{Swadesh1952; Chang2015; Greenhill2021; Auderset2023; Heggarty2023;};
      ", since the lexical items that instantiate concepts in this domain are less prone to horizontal transmission (i.e., linguistic borrowing). ";
      "In contrast to every study of linguistic phylogenetics that we are aware of, however, our investigation draws inferences directly from word-forms. ";
      "For each concept in our dataset, homologous lexical items are assigned to a ";
      Definition("cognate class"); DotSpace;
      "The word-forms within each cognate class are phonemic representations based on the International Phonetic Alphabet";
      Citation{IPA1999}; DotSpace;
      "Consider the cognate class for the concept ";
      style.SQuote {ec.Name}; ":";
    };

    SegmentTable(ec, data, true);

    style.ResumePar {
      "The word for "; style.SQuote {ec.Name}; " in "; ec.Taxon.Language; ", for example, is "
      "/"; ec.LangWord; "/. ";
      "The matrix assumes that the fine-scale homology of the segments has been established. ";
      "For example, it assumes that the glide /j/ of Romanian, Spanish, French, Friulian, and Italian are homologous. ";
      "The dashes indicate that there is no homologous segment at that potential position in the word. ";
      "As discussed in more detail below, this is not the only possible alignment and "; style.FigureReference(Figures.Alignment);
      " shows two further possibilities. ";
    };

    style.BodyPar {
      "Note that a segmental alignment, denoted ";
      SegmentalAlignment;
      ", is constructed by combining the segmental information for the languages of interest with information on the homology of the segments. ";
      "The segmental information for the ";
      NumLanguages;
      " languages of interest is denoted ";
      Equation {
        SegmentalInfo;
        Tex.Equals;
        SpanParens {
          EllipsisList {
            Segment sub 1;
            Segment sub 2;
            Segment sub NumLanguages;
          }
        }
      };
      ", where ";
      Defs.Segment sub sym.i;
      " is the segmental string for the ";
      Ith;
      " language. ";
      "The segmental information for the ";
      SampledLanguages(MainResults.Data.Taxa.Length);
      " languages for the cognate class above for ";
      style.SQuote {ec.Name}; " is:";
    };

    SegmentTable(ec, MainResults.Data, false);

    style.BodyPar {
      "Here, the segments for "; ec.Taxon.Language; " would be ";
      Equation {
        Segment sub 1;
        Tex.Equals;
        SpanParens {
          ec.LangWord
        }; DotSpace;
      };
      "The alignment of the segments is accomplished by the use of a map, ";
      HomologyMap;
      ", describing the homology of the segments. ";
      "The alignment is formed by combining the segment information with the homology map, ";
      Equation {
        SegmentalAlignment;
        Tex.Equals;
        Arguments {
          SegmentalInfo;
          HomologyMap;
        };
      }; DotSpace;
      style.FigureReference(Figures.Alignment);
      " shows an example of two alignments for the word ";
      ec.Name;
      " that can be formed using two different homology maps. ";
    };

    style.BodyPar {
      "Spoken and written word-forms can be observed, but alignments cannot. ";
      "There are many different ways in which the segments of a cognate word can be homologous. ";
      "The example from the word "; ec.Name; ", above, shows only one such way. ";
      "In this study, we develop the statistical and analytical machinery that allow us to marginalize over the segmental alignments. ";
      "Our method considers all possible segmental alignments of the word-forms in a cognate class, weighting each such possibility by its probability under a model. ";
      "In this way, our method does not condition on any specific segmental alignment.";
    };

    style.BodyPar {
      BodyTitle {"Language evolution model"}; DotSpace;
      "We assume that cognate words evolve along the branches of a phylogenetic tree through substitution of one segment by another, insertion of a new segment, or deletion of a segment.";
    };

    style.BodyPar {
      "Substitution of one segment for another is modeled using a continuous-time Markov model in which the possible states are the set of segments in the phonemic representations. ";
      "At the heart of a continuous-time Markov chain is a rate matrix describing the rate of change between all pairs of states. ";
      "Consider, for example, a simplified Markov process with only "; Enumerators.Cardinal(StateCount); " segments as states. ";
      "The rates of change between the pairs of states can be represented in tabular form as follows:";
    };

    style.BodyPar {
      ParAlignment: ParAlignments.Center;
      Frame {
        StateSection.StateTable(StateCount);
      };
    };

    style.ResumePar {
      "where ";
      RateChange;
      " is the rate of change from segment "; sym.i; " to segment "; sym.j; DotSpace;
      "The diagonal elements of the rate matrix "; qii; " are specified such that each row sums to zero (i.e., ";
      DiagonalElements;
      "). This negative value can be interpreted as the rate at which the process moves away from state "; sym.i; DotSpace;
      "Rates of change between all pairs of states are typically represented in matrix form as follows:";
    };

    style.LineEquation(RatesOfChangeBetweenStates);

    style.ResumePar {
      "The additional parameter ";
      RateMatrixScale;
      " scales the rate matrix such that the average rate of segmental substitution is 1.0.";
    };

    style.BodyPar {
      "A continuous-time Markov model has a simple physical interpretation. ";
      "Specifically, when the process is in state "; sym.i; ", one waits an exponentially-distributed time with parameter ";
      -qii; " until the next segmental substitution occurs. ";
      "When a change occurs, it is to state ";
      sym.j;
      " with probability ";
      Equation {-qij; Tex.Divide; qii;}; DotSpace;
      "Several important quantities can be calculated using the information contained in the rate matrix ";
      RateMatrix; DotSpace;
      "For one, the probability of the process ending in state ";
      sym.j;
      " conditional on starting in state ";
      sym.i;
      " after a period ";
      ExpectedEvents;
      " can be calculated through exponentiation of the rate matrix, ";
      ExponentiationOfRateMatrix; DotSpace;
      "In addition, the equilibrium distribution of the process can be calculated. ";
      "This distribution is denoted ";
      EquilibriumDistribution;
      " and represents the probability of capturing the process in a particular state after a very long time (technically, an infinite amount of time) has passed. ";
      "The equilibrium distribution is calculated by solving the system of equations defined by ";
      RateMatrixSolution; DotSpace;
      "Both the transition probabilities and equilibrium probability distribution play an important role in calculating the likelihood (see below).";
    };

    style.BodyPar {
      "Insertions and deletions of single segments occur at rates ";
      InsertDelete(" and ");
      ", respectively. ";
      "Consider the long-term behavior of a process in which ";
      InsertDelete(Tex.gt); DotSpace;
      "On average, segments would be inserted more frequently than they would be deleted, ";
      "as a result of which the length of word-forms would increase without bounds. ";
      "The opposite situation occurs when ";
      InsertDelete(Tex.lt);
      ", as segments are deleted at a higher rate than they are inserted. ";
      "In this case, the words of a language would be reduced to silence. ";
    };

    style.BodyPar {
      "The TKF91"; Citation {Thorne1991}; " model of DNA sequence evolution allows single nucleotides to be inserted and deleted at rates ";
      InsertDelete(" and "); DotSpace;
      "They introduced a convention for thinking about a DNA sequence in which nucleotides are connected by invisible links. ";
      "Each nucleotide is paired with the link to its right. ";
      "The left-most nucleotide has a special link to its left, which is known as the immortal link. ";
      "When a nucleotide is inserted, it is inserted to the right of a link and contributes its own link to its right. ";
      "Deletions remove a nucleotide and its associated link, but the immortal link is never deleted. ";
      "As a result, the process does not go extinct, even when "; InsertDelete(Tex.lt); ". ";
      "Instead, a nucleotide (and its link) can be inserted to to the right of the immortal link. ";
      };
     style.BodyPar {
      "The TKF91 model constrains the insertion rate to be less than the deletion rate ";
      SpanParens {InsertDelete(Tex.lt)};
      ", so the equilibrium distribution of a sequence length is geometrically distributed with parameter ";
      InsertDelete(Tex.Divide); DotSpace;
      "This constraint is adopted in this study. ";
      "In fact, the model we use is precisely the same as the TKF91 model, but with a different continuous-time Markov model to describe segmental transitions. ";
      "TKF91"; Citation {Thorne1991}; " uses a four-state process to describe nucleotide substitutions. ";
    };

    style.BodyPar {
      "The overall substitution and insertion/deletion process can be described as follows. ";
      "In a sequence ";
      WordLength;
      " segments in length, of which ";
      WordLength sub sym.i;
      " are of segment type ";
      sym.i;
      ", the time until the next event occurs follows an exponential distribution with parameter ";
    };

    style.LineEquation(InDelDistribution);

    style.BodyPar {
      "When an event occurs, it is a substitution with probability ";
      InDelProbability;
      ", an insertion with probability ";
      EventInsertionProbability;
      ", and a deletion with probability ";
      EventDeletionProbability;
      DotSpace;
      "Crucially, the process allows the alignment map ";
      SpanParens {HomologyMap};
      " to be treated as a parameter of the model. ";
    };

    style.BodyPar {
      BodyTitle {"Bayesian estimation of model parameters"}; DotSpace;
      "We estimate the parameters of the model in a Bayesian framework. ";
      "Bayesians base inferences on the posterior probability distribution of a parameter, which can be calculated using Bayes’ theorem as";
    };

    style.LineEquation(BayesTheorem);

    style.ResumePar {
      "where the pipe indicates a conditional statement. ";
      "In words, the posterior probability distribution of the parameters is equal to the likelihood ";
      InBrackets {PPO};
      " times the prior probability distribution ";
      InBrackets {PP};
      ", divided by the marginal likelihood ";
      InBrackets {PO}; DotSpace;
    };

    style.BodyPar {
      "In this study, parameters include:";
    };

    BodyTable([new ColumnClass(1 inch, null, null, HAligns.Right), 20 pts, 4 inches]) {
      ParamRow {
        ParamList(Topology);
        "Tree Topologies";
      };
      ParamRow {
        ParamList(ExpectedEvents);
        "Branch length parameters";
      };
      ParamRow {
        Equation {RateMatrixParams};
        Span {RateMatrixParams.Description; Space; Equation {RateMatrix}};
      };
      ParamRow {
        Equation {InsertDelete(", "); Space; SpanParens {InsertDelete(Tex.lt)}};
        "The insertion and deletion rates of  segments";
      };
      ParamRow {
        HomologyMap;
        HomologyMap.Description;
      };
    };

    style.BodyPar {
      "We assign prior probability distributions to all parameters of the model (see Table 1). ";
      "The posterior probability distribution of the model parameters is then";
    };

    style.LineEquation(PosteriorProbabilityDistribution);

    style.ResumePar {
      "We highlight that the likelihood is marginalized over all possible alignments: "
    };

    style.LineEquation(MarginalizationOverAlignments);

    style.ResumePar {
      "where the sum is over all possible alignment maps. Our inferences are therefore not conditioned on any particular alignment of segments being correct. ";
      "In a similar vein, the marginal likelihood accounts for all possible combinations of model parameters:";
    };

    style.LineEquation(MarginalLikelihoodParameters);

    style.ResumePar {
      "where the integrals represent integration over all possible combinations of branch lengths, rate matrix parameters, and insertion/deletion rates.";
    };

    style.BodyPar {
      "The likelihood is calculated on a per-word basis using the algorithm described by "; Citation{Lunter2003} ", which conditions on an alignment. ";
      "Although the posterior probability distribution can be written down and individual components such as the prior probability or likelihood for a particular combination of parameters can be calculated, analytically solving the high dimensional summations and integrals required for the posterior probability is unfeasible. ";
      "Instead, we numerically approximate the joint posterior probability distribution of the parameters using Markov chain Monte Carlo.";
    };

    style.BodyPar {
      BodyTitle {"Markov chain Monte Carlo"}; DotSpace;
      "The aim of Markov chain Monte Carlo (MCMC) is to construct a Markov chain that has as its possible states the parameter values of the statistical model and a stationary distribution that is the posterior probability distribution of the parameters. ";
      "Metropolis et al. (1953)";
      Citation {Metropolis1953};
      " and Hastings (1970)";
      Citation {Hastings1970};
      " describe rules for constructing such a chain. ";
      "When at stationarity, samples from this chain form valid, albeit dependent, samples from the posterior probability distribution. ";
      "The Metropolis-Hastings algorithm constructs the Markov chain using the following algorithm:";
    };

    style.NumberedList {
      ParAlignment: ParAlignments.Left;

      Paragraph {
        "The current state of the chain is denoted ";
        RateMatrixParams; DotSpace;
        "If this is the first cycle of the Markov chain, initialize ";
        RateMatrixParams;
        "(e.g., by choosing a value from the prior distribution).";
      };

      Paragraph {
        "Propose a new value for "; RateMatrixParams; ", denoted "; NewValueProposal; DotSpace;
        "The proposal mechanism is up to the programmer, but must involve the generation of random numbers ";
        RandomNumber;
        " such that the proposed value is a function of the current value and the random numbers, ";
        Equation {
          NewValueProposal;
          Tex.Equals;
          "h"; Arguments {
            RateMatrixParams;
            RandomNumber;
          };
        }; DotSpace;

        "The probability of proposing the new value is ";
        NewProposal(RateMatrixParams, RateMatrixParams);
        " whereas the probability of the imagined reverse move, not actually made in computer memory, is ";
        NewProposal(NewValueProposal, RateMatrixParams); DotSpace;
      };

      ListItem {
        FirstIndent: 0;
        "Calculate the probability of accepting the proposed value:";
        ProbOfAcceptingProposal;
        "In other words, the acceptance probability is the product of the likelihood, prior, and proposal ratios.";
      };

      Paragraph {
        "Generate a uniform(0,1) random variable, ";
        Equation {
          RandomNumber
        }; DotSpace;
        "If ";
        Equation {
          RandomNumber;
          Tex.lt;
          ProbOfAccepting;
        };
        ", accept the proposed state, setting ";
        Equation {
          RateMatrixParams;
          Tex.Equals;
          NewValueProposal;
        }; DotSpace;
        "Otherwise, the proposed state is said to be rejected and the chain remains in state ";
        Equation {
          RateMatrixParams;
        }; DotSpace;
      };

      Paragraph {
        "Return to Step # 1.";
      };
    };

    style.BodyPar {
      "The proposals we implement in this study are all typical for phylogenetic models, such as the LOCAL mechanism to update the tree and branch lengths"; Citation{Larget1999}; DotSpace;
      "The unique aspect of this study is a proposal mechanism for the alignments of the segments for various words. ";
      "Here, we use the proposal mechanism described by Lunter et al."; Citation{Lunter2005}; DotSpace;
    };

    style.BodyPar {
      "The general strategy behind a MCMC analysis is to run the chain for many thousands or millions of cycles. Each cycle, the chain proposes a new state that may accepted or rejected as the next state of the chain. Every so often, the state of the chain is printed to a file. In our study, we sampled the chain every 100 cycles. The samples contained in the output files can be used to reconstruct the marginal posterior probability distributions of parameters. As an example, the fraction of the time a particular alignment of a cognate is found in the file is a valid approximation of that alignment's posterior probability. Similarly, the fraction of the time a particular tree topology is found in the output file is a valid approximation of that tree's posterior probability. Probability distributions for continuous parameters can be approximated by constructing a frequency histogram for the parameter from the output files produced by the MCMC analysis.";
    };

    style.BodyPar {
      BodyTitle {"Model comparison"}; DotSpace;
      "In a Bayesian analysis, parameter estimates are based on the joint posterior probability distribution of the parameters, which we numerically approximate using the Metropolis-Hastings algorithm. ";
      "Often, however, the linguist is interested in the comparison of two or more models with the goal of evaluating which of the models best explains the observations. ";
      "Bayesian model comparison is based on the marginal likelihoods of the models. ";
      "Consider two different linguistics models, ";
      Model sub 1; " and "; Model sub 2;
      " with marginal likelihoods, "; PSM(1); " and "; PSM(2);
      " (note the marginal likelihoods are calculated for the same observations). The ratio of the marginal likelihoods is known as the Bayes Factor:";
    };

    style.LineEquation(ModelComparison);

    style.ResumePar {
      "The Bayes Factor measures the relative support of the two models. ";
      "A Bayes Factor less than one favors ";
      Model sub 1;
      ", whereas the oppose is true for a Bayes factor greater than one. ";
      "In contrast to frequentist statistics, Bayesian model comparison does not involve p-values. ";
      "The Bayes Factor is instead interpreted as is or on a log scale. ";
      Citation{Jeffreys1961}; " devised the following categories to interpret Bayes Factors:";
    };

    BodyTable([1 inches, 1 inches, 3 inches]) {
      Row(BorderB(0.5 pts)) {
        BayesFactor;
        Span {"log" sub 10; BayesFactor};
        "Interpretation";
      };
      Row {
        Span {1; Tex.Minus; 3.2};
        Span {0; Tex.Minus; 1/2};
        "Not worth a bare mention";
      };
      Row {
        Span {3.2; Tex.Minus; 10};
        Span {1/2; Tex.Minus; 1};
        "Substantial";
      };
      Row {
        Span {10 Tex.Minus 100};
        Span {1 Tex.Minus 2};
        "Strong";
      };
      Row {
        Span {Tex.gt; 100};
        Span {Tex.gt; 2};
        "Decisive";
      };
    };

    style.BodyPar {
      "In a Bayesian analysis, there is no need to penalize parameter rich models for having more parameters. ";
      "Rather, the penalization is built into the comparison; ";
      "the additional parameters in a complicated model are each assigned a prior probability distribution. ";
      "A parameter-rich model has lower prior probability for any combination of model parameters than a simpler model. ";
      "Hence, there is no need to compare the Bayes factor to a null distribution as there is in frequentist hypothesis testing.";
    };

    style.BodyPar {
      "The main limitation of Bayesian model comparison is numerically approximating the marginal likelihoods of the models. ";
      "This can be done in numerous ways. ";
      "For example, one can construct a Markov chain that jumps between models, even if the models differ in dimensions, using a generalization of MCMC described by Green (1995; reversible-jump MCMC). ";
      "Alternatively, one can numerically approximate the marginal likelihoods using what is called path-sampling in which numerous MCMC chains explore a path between the prior and posterior distributions "; Citation{Lartillot2006; Xie2010}; DotSpace;
    };

    style.BodyPar {
      "Three models describing how word segments evolve along the branches of the tree are compared in this study. ";
      "The first model is isomorphic to the model of molecular evolution first described by Jukes and Cantor ";
      Citation{Jukes1969}; ", and assumes that the rates of change between all IPA segments is equal. ";
      "The second model, isomorphic to the model first described by Felsenstein "; Citation{Felsenstein1981}; ",  assumes that the rate of change to a state is proportional to its stationary frequency. "; "The third model, our Natural Class Model, partitions the IPA segments into 10 sets according to their articulatory properties. The model allows there to be independently-estimated rates of change for changes to a segment in the same class and also independently-estimated rates for changes between classes.";
    };
   };
}

//======================================================================

SegmentTable(ExampleConceptClass example, DataSetClass data, aligned) = BodyTable([1 inches, 14 pts]) {
  var words = example.Cognate.Words;
  foreach (var taxon in data.Taxa) {
    Row {
      taxon.Language;
      var w    = words[taxon.Index];
      var list = aligned ? w.Padded : w.Segments;
      foreach (var s in list)
        s.ShowSegment;
    }
  }
};

//======================================================================

readonly RateMatrixDiscussionClass PaperSections.RateMatrixDiscussion = new;

class RateMatrixDiscussionClass: ContentClass {
  Constructor {
    super.Constructor("Rate Matrix Discussion");
  }

  override GetBody(ContentStyleClass style, title) = Block {
    style.TitlePar(title) {
      "Our model describes how the segments evolve along the branches of the tree. We have three events that can occur to change a word: an insertion of a single segment, a deletion of a single segment, and a substitution of a segment.";
    };

    style.BodyPar {
      "A substitution is the replacement of one segment by another. We model substitutions as occurring according to a continuous-time Markov model. Such a model can be understood if you know two things: the possible states and the rate of change between all pairs of states. For our work, the states are the "; MainResults.Data.UniqueSegments.Length; " possible segments. The rates of change between all pairs of states are contained in a rate matrix, which we denote "; RateMatrix; DotSpace;
    };

    style.BodyPar {
      "You can completely describe the substitution process if you have "; RateMatrix; DotSpace; "We use "; RateMatrix; " to calculate transition probabilities (by exponentiating the product of the rate matrix and the branch length) and also to get the stationary frequencies of the process (which are the probability of capturing the process in some state after infinite time has passed)."
    };

    style.BodyPar {
      "Now, for understanding the rate matrix. Let’s denote "; qij; " as the rate of change from state "; sym.i; " to state "; sym.j; ". (It’s simply an element of the rate matrix, "; RateMatrix; "). This is literally the rate of change to that state when the process is in state "; sym.i; ". Comparing rates in the rate matrix can be useful. You can say things such as, “ This rate is higher than that rate. This makes sense because everyone knows that such changes occur frequently in language.” I would especially compare rates in a single row. Does it make sense to see, for example, that when changes occur, they are more likely to be to other states in the same class? Does it make sense that when we have a change and a segment is in the green class that it is more likely to be to a segment in the dark gray and brown classes? That’s how I read ";
      style.FigureReference(Figures.QRatesMatrix); DotSpace;
    };

    style.AddFigure(Figures.QRatesMatrix, FigureOptions.Bottom | FigureOptions.Full);

    style.BodyPar {
      "That said, I think the diagonals are quite interesting because they give you an idea of the relative volatility of the segments. The diagonals are simply the negative of the sum of the off-diagonal components of the row:"
    };

    style.AlignEquations {
      style.LineEquation(Equations.OffDiagonalComponents);
    };

    style.BodyPar {
      "where "; sym.j; " is iterated over all states (for "; sym.i; Tex.neq; sym.j; "). What does this mean? Let’s consider two segments one of which has a diagonal value of –1.0 and the other that has a value of –2.0. The rate of change for the first, then, is 1.0 and the second is 2.0. This means that the second segment is in a sense more volatile than the first. When we are in the second segment, we move to another state at a rate 2.0 which is twice the rate of the first segment."
    };

    style.BodyPar {
      "What should you look for here with respect to the linguistic data? Well, I don’t know. I’m hoping that, with this interpretation under his belt, David will see patterns that make sense. Are certain segments known to be more volatile in language? Are others known to be more conservative? Does this background knowledge in the field match up with the rates we are getting (the diagonal values)?"
    };

    style.BodyPar {
      "The other graphs show the average rates. The average rates can be calculated from the rate matrix, "; RateMatrix; ". To distinguish the average rate matrix from the rate matrix, "; RateMatrix; ", I will denote it "; AverageMatrix; ". The "; sym.ij sup "th"; " element of this average rate matrix is calculated as "; AverageRateElement; ". In words, the average rate of change from state "; sym.i; " to state "; sym.j; " is equal to the probability of starting in state "; sym.i; " and then moving to state "; sym.j; "."
    };

    style.BodyPar {
      "What do the average rates tell us? I think the interpretation is a little more confusing, but still well defined. We are looking at averages now, over all the characters and taking into account their frequencies. A segment that is frequent in the data set will have a boost, here, because "; Probability sub sym.i; " will be higher."
    };

    style.BodyPar {
      "Perhaps the best way to think of this is as follows: "; AverageMatrix; " tells you the average rates and takes into account the probability of starting in state "; sym.i; DotSpace; RateMatrix; ", by contrast, assumes you are already in state "; sym.i; " and tells you how rapidly you move to various states (from "; sym.i; " to the other possible states). I believe for our purposes, you should concentrate on "; RateMatrix; DotSpace;
    };
  };
}
//======================================================================

