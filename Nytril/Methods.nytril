using Format, Units, Math, IO, Style, Defs, Equations, Languages, References, Tex;

//======================================================================

namespace Figures.PartitionAssignments {
  Title = Lang.PartitionRules;

  Body(DocumentClass document) = MainResults.Rule.ShowPartitions(12 pts);
}

//======================================================================

namespace Figures.ExperimentalRuns {
  Title = "Experimental Runs";

  Body(DocumentClass document) = MainResults.Data.ShowExperiment;
}

//======================================================================

namespace Figures.TransitionRates {
  Title = "Transition Rates between Partitions";

  Caption(DocumentClass document) = Span {
    "The area of the circles is proportional to the estimated equilibrium frequencies. ";
    "The width of the lines is proportional to the estimated rates. ";
  };

  CalcRatesClass Display = new(MainResults);

  Body(DocumentClass document) {
    return Display.PartitionDiagram;
  }
}

//======================================================================

namespace Figures.AlignmentExamples {
  Title = "Alignment Examples";

  CognateIdClass[] Examples = [
    new("Moon", null, 5),
    new("One", null, 8),
    new("Tooth", null, 3),
  ];

  Caption(DocumentClass document) = Span {
    "Credible sets for cognate alignments";
  };

  Body(DocumentClass document) = Block {
    Figures.Alignments.Display.ShowSet(MainResults.Data, Examples);
  };
}

//======================================================================

namespace Figures.ExchangeabilityTable {
  Title = Lang.Exchangeability;

  Body(DocumentClass document) = Block {
    var th = ExtentWidth * 0.015;
    Style.SansSerif;
    TextHeight: th;

    var stats      = MainResults.TransitionStats;
    var partitions = MainResults.Rule.Partitions;
    var dy         = 2 pts;
    var left       = 1 inch;
    var w          = (ExtentWidth - 1 inch) / stats.Length;

    Table(PadR(4 pts)) {
      HAlign: HAligns.Center;
      Columns: [left] + [w] * stats.Length;
      TextDigits: 3;

      Row {
        Empty;
        foreach (var r in stats) {
          Frame(w) {
            ParAlignment: ParAlignments.Center;
            TextHeight: th*0.8;
            var p = partitions[each0];
            TextColor: p.Color;
            p.Name.Split(Space);
          };
        }
      };

      foreach (var r in stats) {
        Row {
          VAlign: VAligns.Center;
          Frame(w) {
            ParAlignment: ParAlignments.Right;
            var p = partitions[each0];
            TextColor: p.Color;
            p;
          };

          foreach (var c in r) {
            if (c is valid)
              c.ShowBox {Margin: PadT(dy)};
            else
              "-";
          }
        };
      }
    };
  };
}
//======================================================================

namespace Figures.ExchangeabilityChart {
  Title = Lang.Exchangeability;

  ShowRight(number) = HBox {
    Space*2;
    TextHeight: 80%;
    TextColor: Colors.Gray;
    number;
  };

  Body(DocumentClass document) = Block {
    Style.SansSerif;
    TextHeight: ExtentWidth * 0.015;

    var partitions = MainResults.Rule.Partitions;
    var stats      = MainResults.TransitionStats;
    var bx         = 20 pts;
    var tx         = 60 pts + bx;
    var dy         = ExtentHeight / (partitions.Length + 1);
    var d          = Math.Min(dy, (ExtentWidth  - tx) / partitions.Length);

    var max = 0.0;
    foreach (var r in stats) {
      foreach (var c in r) {
        if (c is valid and c.Upper > max)
          max = c.Upper;
      }
    }

    var fc = d / max;
    var fp = 50.0 / max;

    HBox {
      VBox {
        Canvas(bx, bx);

        foreach (var r in stats) {
          var p = partitions[each0];
          HBox(null, dy) {
            Separation: 10 pts;
            VAlign: VAligns.Center;
            HAlignment: HAligns.Right;
            Frame {
              p;
            };
            Canvas(bx, dy) {
              Background: p.Color;
            };
          }
        }
      };

      VBox {
        HAlign: HAligns.Left;

        HBox {
          foreach (var r in stats) {
            var p = partitions[each0];
            Canvas(d, bx) {
              Background: p.Color;
              VAlign: VAligns.Center;
              HAlign: HAligns.Center;
              Frame(d) {
                TextColor: p.Color.TextCompliment;
                ParAlignment: ParAlignments.Center;
                TextHeight: 75%;
                p.Name;
              };
            };
          }
        };

        VBox {
          foreach (var r in stats) {
            var i = each0;
            HBox {
              foreach (var c in r) {
                if (c is valid) {
                  var p = partitions[each0];

                  Canvas(d, d) {
                    Tip: c;
                    var center = new PointClass(d * 0.5);
                    var x      = fc * c.Upper;
                    Figure(80%) {
                      Ellipse(new(new(center.X - x*0.5 , center.Y - x*0.5), x));
                      x = fc * c.Lower;
                      Ellipse(new(new(center.X - x*0.5 , center.Y - x*0.5), x));
                    };

                    Figure(null, 1) {
                      x = fc * c.Mean;
                      Ellipse(new(new(center.X - x*0.5 , center.Y - x*0.5), x));
                    };
                  };
                }
                else
                  Canvas(d, d);
              }
            };
          }
        }
      };
    };
  };
}

//======================================================================

namespace Figures.PartitionVolatilityChart {
  Title = "Partition Volatility";

  Body(DocumentClass document) = Block {
    Style.SansSerif;

    var partitions = MainResults.Rule.Partitions;
    var stats      = MainResults.TransitionStats;
    Chart(ExtentWidth, 4 inches) {
      Type: ChartTypes.Scatter;
      ValueLabel: "Probability %" {
        TextHeight: 14 pts;
        Transform: Rotate(90 degrees);
        TransformFit: true;
      };

      XAxis: ChartAxis {
        foreach (var p in partitions) {
          Span {
            p.Name;
            Tip: p;
          }
        }
      };

      ValueAxis: ChartAxis;

      ChartSeries {
        foreach (var i in 0..<stats.Length) {
          var s = stats[i][i];
          var p = partitions[i];
          var m = s.Mean * 100.0;
          new DataPointClass(i, m) {
            Fill: p.Color;
            Reference: p;
            ErrorHi: s.Upper*100.0 - m;
            ErrorLo: m- s.Lower*100.0;
          };
        }
      };
    };
  };
}

//======================================================================

namespace Figures.FractionGapsChart {
  Title = "Deletions at the right edge";

  Body(DocumentClass document) = Block {
    Style.SansSerif;
    "To be completed";
  };
}

//======================================================================

TopCount = 15;

namespace Figures.AverageTransitions {
  MinRate = 0.00005;
  Title   = "Average transitions above {0}%"(MinRate*100);

  AlignedCountClass Display = new(MainResults, MainResults.Output.AverageRates, MainResults.Output.AverageRatesMax, MinRate, true);

  Body(DocumentClass document) = Display.PartitionBox;
}

namespace Figures.AverageDiagonal {
  Title = "Average Diagonal";

  Body(DocumentClass document) = new DiagonalClass(MainResults, MainResults.Output.AverageRates, MainResults.Output.AverageRatesMax).Display;
}

namespace Figures.AverageMost {
  Title = "Average Top {0}"(TopCount);

  Body(DocumentClass document) = AverageTransitions.Display.Extrema(TopCount, true);
}

//======================================================================

namespace Figures.AsymmetriesMatrix {
  Title = "Asymmetries";

  AsymmetriesClass Display = new(MainResults, MainResults.Output.QRates, MainResults.Output.QRatesMax, Figures.AverageTransitions.MinRate, false);

  Body(DocumentClass document) = Display.PartitionBox;
}

namespace Figures.QRatesMatrix {
  MinRate = 0.005;
  Title   = "Q above {0}%"(MinRate*100);

  AlignedCountClass Display = new(MainResults, MainResults.Output.QRates, MainResults.Output.QRatesMax, MinRate, false);

  Body(DocumentClass document) = Display.PartitionBox;
}

namespace Figures.QRatesDiagonal {
  Title = "Segmental stability as measured by the instantaneous rate of change";

  DiagonalClass Diagonal = new(MainResults, MainResults.Output.QRates, MainResults.Output.QRatesMax);
  Body(DocumentClass document) = Diagonal.Display;
}

TransitionTitle(type) = "The top {0} {1} transitions"(TopCount, type);

namespace Figures.QRatesTop {
  Title = TransitionTitle("segmental");

  Body(DocumentClass document) = QRatesMatrix.Display.Extrema(TopCount, true);
}

namespace Figures.QRatesBottom {
  Title = "The bottom {0} segmental transitions"(TopCount);

  Body(DocumentClass document) = QRatesMatrix.Display.Extrema(TopCount, false);
}

namespace Figures.QRatesVowelVowel {
  Title = TransitionTitle("Consonant-Vowel");

  Predicate(AlignActionClass a) = a.S0.Features.HasFlagMask(SegmentFeatures.Vowel, SegmentFeatures.NoFeature) and
                                  a.S1.Features.HasFlagMask(SegmentFeatures.Vowel, SegmentFeatures.Vowel);

  Body(DocumentClass document) = QRatesMatrix.Display.Pairs(TopCount, ref Predicate);
}

namespace Figures.QRatesConsonantConsonant {
  Title = TransitionTitle("Consonant-Consonant");

  Predicate(AlignActionClass a) = a.S0.Features.HasFlagMask(SegmentFeatures.Vowel, SegmentFeatures.NoFeature) and
                                  a.S1.Features.HasFlagMask(SegmentFeatures.Vowel, SegmentFeatures.NoFeature);

  Body(DocumentClass document) = QRatesMatrix.Display.Pairs(TopCount, ref Predicate);
}

namespace Figures.QRatesAsperation {
  Title = TransitionTitle("pulmonic");

  Predicate(AlignActionClass a) = a.S0.Features.HasFlagMask(SegmentFeatures.Pulmonic | SegmentFeatures.Vowel, SegmentFeatures.NoFeature) and
                                  a.S1.Features.HasFlagMask(SegmentFeatures.Pulmonic | SegmentFeatures.Vowel, SegmentFeatures.Pulmonic) and
                                  a.Rate > a.Reverse*2;

  Body(DocumentClass document) = QRatesMatrix.Display.Pairs(TopCount, ref Predicate);
}

namespace Figures.QRatesVowelConsonant {
  Title = TransitionTitle("Vowel-Consonant");

  Predicate(AlignActionClass a) = a.S0.Features.HasFlagMask(SegmentFeatures.Vowel, SegmentFeatures.Vowel) and
                                  a.S1.Features.HasFlagMask(SegmentFeatures.Vowel, SegmentFeatures.NoFeature);

  Body(DocumentClass document) = QRatesMatrix.Display.Pairs(TopCount, ref Predicate);
}


namespace Figures.QRatesOneWay {
  Title = TransitionTitle("highly directed");

  Body(DocumentClass document) {
    var sorted = QRatesMatrix.Display.ActionList.Sort(true, ref ByReverseRate);
    return QRatesMatrix.Display.ShowChartPairs(TopCount, sorted);
  }

  ByReverseRate(AlignActionClass a1, AlignActionClass a2, options) {
    return a1.ReverseRating.Compare(a2.ReverseRating);
  }
}

//======================================================================

namespace Figures.AllSegmentFrequencies {
  Title = "Segment occurrance rates for all languages";

  Caption(DocumentClass document) = Span {
    "The frequency of occurrance of each segment for all languages";
  };

  Display = new SegmentDisplayClass(MainResults.Data).FrequencyChart(new(ExtentWidth, Math.Min(ExtentHeight, 5 inches)));

  Body(DocumentClass document) = Block {
    Display;
  };
}

//======================================================================


namespace Figures.ConsensusTree {
  Title = Lang.ConsensusTree;

  Body(DocumentClass document) = VBox(ExtentWidth) {
    HAlign: HAligns.Center;
    Style.TreeOptions(ExtentWidth) {
//      Root: MainResults.Data.MainRun.Tree;
    };
  };
}

//======================================================================

namespace Figures.SegmentOccuranceRates {
  Title = "Segment Occurance Rates";

  Caption(DocumentClass document) = Span {
    var l0 = MainResults.Data.Taxa[0].Language;

    "Comparison of occurance rates of segments in each language. Segments are sorted by the rates in ";
    l0; ". Bars are normalized to the rate of the most frequently ocurring segment in each language. Languages are ordered by their Euclidian distance from "; l0; " indicated by the red line.";
  };

  SegmentFrequencyClass Display = new(MainResults.Data, false);

  Body(DocumentClass document) = Display.ShowChart;
}
//======================================================================

namespace Figures.SegmentOccuranceGrouped {
  Title = "Segment Occurance Rates (by partition)";

  SegmentFrequencyClass Display = new(MainResults.Data, true);

  Body(DocumentClass document) = Block {
    Display.ShowChart;
  };
}
//======================================================================

namespace Figures.PartitionFrequencies {
  Title = "Partition Occurance Rates";

  Caption(DocumentClass document) = Span {
    var l0 = MainResults.Data.Taxa[0].Language;
    "Comparison of occurance rates of partitions in each language. Partitions are sorted by the rates in ";
    l0; ". Bars are normalized to the rate of the most frequently ocurring partition in each language. ";
    "Languages are ordered by their Euclidian distance from "; l0; " indicated by the red line.";
  };

  PartitionFrequencyClass Display = new(MainResults.Data);

  Body(DocumentClass document) = Block {
    Display.ShowChart;
  };
}
//======================================================================

namespace Figures.Alignments {
  Title = "Alignments";

  Caption(DocumentClass document) = Span {
    MainResults.AlignmentCutoff * 100.0; "% credible set of alignments";
  };

  AlignmentChartClass Display = new(MainResults);

  Body(DocumentClass document) = Block {
    Display.ShowChart(ExtentSize);
  };
}
//======================================================================

namespace ExampleAnimals {
  Chimpanzee = "AAGCTTCACCGGCGCAATTATCCTCATAATCGCCCACGGACTTACATCCT";
  Gorilla    = "AAGCTTCACCGGCGCAGTTGTTCTTATAATTGCCCACGGACTTACATCAT";
  Human      = "AAGCTTCACCGGCGCAGTCATTCTCATAATCGCCCACGGGCTTACATCCT";
}
//=====================================================================

class ExampleConceptClass {
  CognateClass    Cognate;
  LanguageClass[] ExLanguages,
                  LangNames;
  TaxonClass[]    TaxonList;
  TaxonClass      Callout,
                  Taxon;
  var             Concept,
                  TaxonIndex,
                  Name,
                  CalloutSegment,
                  LangWord;

  Constructor(DataSetClass data, concept) {
    Concept        = concept;
    Cognate        = data.GetCognate(concept);
    TaxonIndex     = 0;
    Taxon          = data.Taxa[TaxonIndex];
    Callout        = data.Taxa[3];
    Name           = ToLower(Cognate.Concept.Name);
    ExLanguages    = [Languages.French, Languages.Portuguese, Languages.Catalan, Languages.Friulian, Languages.Romanian];
    TaxonList      = data.Taxa.FindSlice(t => ExLanguages.Contains(t.Language));
    LangNames      = (each TaxonList).Language;
    CalloutSegment = FirstLetter(Callout);
    LangWord       = Span {(each Cognate.Words[TaxonIndex].Segments).Ipa};
  }

  FirstLetter(TaxonClass taxon) = Cognate.Words[taxon.Index].Segments[0].ShowSegment;
  FirstLetters = FirstLetter(each TaxonList);
}

//======================================================================

namespace Figures.ExampleTree {
  Title = "Example Tree";

  Caption(DocumentClass document) = Span {
    "An example tree showing the relationships of {0} languages."(SampledLanguages(MainResults.Data.LanguageSet.Length));
  };

  Body(DocumentClass document) = TreeOptions(5 inches) {
    Root: MainResults.Data.NumberedTree;
  };
}
//======================================================================

namespace Figures.ExampleConcepts {
  Title = Lang.ConceptsExamples;

  Body(DocumentClass document) = AllWords.ShowTable(11 pts, MainResults.Data, 2);
}

//======================================================================

namespace Figures.LanguagesUsed {
  Title = Lang.Languages;

  Body(DocumentClass document) = Utility.ShowLanguages(MainResults.Data);
}

//======================================================================

namespace Figures.UniqueSegments {
  Title = Lang.UniqueSegments;

  Body(DocumentClass document) = new SegmentDisplayClass(MainResults.Data).ShowSegmentAssignments;
}

//======================================================================

namespace Figures.Alignment {
  Title       = Lang.Alignment;
  ArrowWidth  = 40;
  ArrowMargin = 10 pts;
  Arrowhead   = 8 pts;
  ArrowColor  = 80%;

  HMap1 = [
    "00111110",
    "10001111",
    "10001110",
    "01101111",
    "10101010",
    "10101110",
    "10001111",
    "00001110",
    "10001110",
    "10011111",
  ];

  HMap2 = [
    "111110000",
    "000111100",
    "000111111",
    "000111111",
    "101010100",
    "000101111",
    "000101111",
    "000111000",
    "111100000",
    "000111111",
  ];

  TName(TaxonClass taxon) = Cell {
    Style.SansSerif;
    taxon.Language;
  };

  SegmentTable(ExampleConceptClass example, DataSetClass data, aligned) = MatrixBlock {
    TextHeight: 9 pts;

    foreach (var taxon in data.Taxa) {
      Row {
        TName(taxon);
        Cell {
          IPAFamily;
          Span {
            var word = example.Cognate.Words[taxon.Index];
            var segs = aligned ? word.Padded : word.Segments;
            (each segs).ShowBlock;
          }
        };
      }
    }
  };

  AlignSegments(SegPartClass[] segments, map) = Span {
    IPAFamily;

    var i = 0;
    foreach (var c in map) {
      if (c == '1' and i < segments.Length)
        segments[i++].ShowBlock;
      else
        IPASegments.GapSegment.ShowBlock;
    }
  };

  MapTable(ExampleConceptClass example, DataSetClass data, map, text) = MatrixBlock {
    foreach (var taxon in data.Taxa) {
      Row {
        TName(taxon);
        Cell {
          var t = map[each0];
          Span {
            if (text)
              AlignSegments(example.Cognate.Words[taxon.Index].Segments, t);
            else {
              TextFixed: true;
              t;
            }
          }
        };
      }
    }
  };

  LabelBox(label) = HBox {
    TextHeight: 18 pts;
    Bold;
    Equation {label};
  };

  ContentBox(content) = HBox(null, null, PadAll(2 pts)) {
    Margin: PadL(4 pts);
    Border: new EdgeClass(0.5 pts, ArrowColor);
    content;
  };

  ArrowFigure(SizeClass size) = Canvas(size.Width, size.Height) {
    Figure(null, new(1.5, ArrowColor)) {
      FigurePath {
        MoveTo(0, 0);
        QuadTo(new(size.Width*0.92, size.Height*0.4), new(size.Width - Arrowhead*0.5, size.Height - Arrowhead));
      };
    };
    Figure(ArrowColor) {
      FigurePath(true) {
        MoveTo(size.Width - Arrowhead, size.Height - Arrowhead);
        LineTo(size.Width, size.Height - Arrowhead);
        LineTo(size.Width - Arrowhead * 0.5, size.Height);
      };
    };
    Canvas {
      Background: Colors.White;
      X: size.Width * 0.3;
      Y: (size.Height - 25 pts) * 0.5;
      TextHeight: 20 pts;
      TextColor: ArrowColor;
      Bold;
      Plus;
    };
  };

  NumBox(num, c1, c2) = MatrixBlock {
    VAlign: VAligns.Top;
    HAlign: HAligns.Center;
    ColumnGap: 0;
    Row {
      LabelBox(HomologyMap sub num);
      ContentBox(c1);
    };
    Row {
      Empty;
      Canvas {
        TextColor: ArrowColor;
        Margin: PadB(5 pts);
        TextHeight: 20 pts;
        HAlign: HAligns.Center;
        Span {
          Tex.downarrow;
          X: 1 pts;
        };
        "=";
      }
    };
    Row {
      LabelBox(SegmentalAlignment sub num);
      ContentBox(c2);
    };
  };

  HomBox(ExampleConceptClass example, DataSetClass data, i, map) = NumBox(i, MapTable(example, data, map, false), MapTable(example, data, map, true));

  Caption(DocumentClass document) = Span {
    "Alignments ("; SegmentalAlignment; ") are formed from the observed segments ("; SegmentalInfo; ") and a homology map ("; HomologyMap; "). ";
  };

  Body(DocumentClass document) = VBox {
    TextHeight: 12 pts;

    var data    = MainResults.Data;
    var example = new ExampleConceptClass(data, data.ExampleConcept);

    Margin: 5 pts;
    HAlign: HAligns.Center;
    HBox {
      Margin: PadB(4 pts);
      VAlign: VAligns.Bottom;
      var fsize = new SizeClass(ArrowWidth, data.Taxa.Length * 8 pts);

      ArrowFigure(fsize) {
        Transform: Affine(-1, 0, 0, 1, fsize.Width, 0);
      };
      HBox {
        VAlign: VAligns.Top;
        LabelBox(SegmentalInfo);
        ContentBox(SegmentTable(example, data, false)) {
          Margin: new ThicknessClass(null, null, ArrowMargin, ArrowMargin);
        };
      };
      ArrowFigure(fsize);
    };
    HBox {
      HomBox(example, data, 1, HMap1);
      Separation: 24 pts;
      HomBox(example, data, 2, HMap2);
    }
  };
}
//======================================================================

namespace StateSection {
  MatrixRow(states, state) = {
    foreach (var s in states) {
      Cell {
        sym.q sub (state s);
      }
    }
  };

  StateRow(states, state) = Row {
    Cell {
      ParAlignment: ParAlignments.Right;
      Span {
        each0 == states.Length div 2 ? "From   " : Empty;
        state;
      }
    };
    MatrixRow(states, state);
  };

  GetStates(count) = 'A'..('A' + (count - 1)) step 1;

  StateTable(count) = Table(new ThicknessClass(1 pts, 1 pts, 3 pts, null)) {
    ParAlignment: ParAlignments.Center;
    VAlign: VAligns.Center;
    HAlign: HAligns.Center;

    var states = GetStates(count);
    Columns: [new ColumnClass(58 pts, BorderR(Style.TableEdgeSize))] + count*[0.36 inches];
    Row {
      Empty;
      Cell {
        ColSpan: states.Length;
        Lang.To;
      };
    };
    Row {
      Border: BorderB(Style.TableEdgeSize);
      Empty;
      states;
    };
    StateRow(states, each states);
  };

  StateMatrix(count) = MatrixBlock(PadB(3)) {
    var states = GetStates(count);

    Brackets: Brackets.FlatRound;
    foreach (var state in states) {
      Row {
        MatrixRow(states, state);
      }
    }
  };
}
//======================================================================

namespace PaperSections.WordTransformation {
  Title = "Segmental Change";

  Body(DocumentClass document) = Block {
    var modelname = Span {TextCase: TextCases.AllLower; MainResults.Rule.Name};

    FirstPar {
      //"The "; modelname; " model allows different rates for different groups of word segments. ";
      FigureReference(Figures.QRatesDiagonal); " presents the absolute values of the diagonal elements of the Q matrix under the "; modelname; " model. ";
      "These diagonal elements can be interpreted as a measure of segmental volatility, since it is the sum of the rates at which it transitions to other segments. ";
      "The distribution of the diagonal elements reveals a number of properties of the segmental changes in our dataset. ";
      "First and foremost, the stability profile of segments is remarkably consistent within each class. ";
      "For instance, all the long vowels cluster together, as do the affricates, fricatives, short vowels, nasal vowels, fricatives, nasal consonants, and stops. ";
      "What this clustering reveals is that when a segment changes it is more likely to transition to a segment of the same class than to one of a different class.  ";
      "Looking at the classes themselves, the segments most likely to change (in blue) are all long vowels. ";
      "This is precisely what we expect since one of the signal events that characterized the emergence of the Romance languages was the loss of phonemic vowel length. ";
      "With the exception of the affricates (in red), the most volatile segmental classes are all vowels. ";
      "Non-syllabic segmental classes on the whole are decidedly more resistant to change and stop consonants are the most stable class. ";


    };

    ShowFigureDoc(document, Figures.QRatesDiagonal);

    BodyPar {
      FigureReference(Figures.QRatesTop); " presents the "; Cardinal(TopCount); " transitions with the highest instantaneous rates of change. ";
      "In contrast to "; FigureReference(Figures.QRatesDiagonal); " above, the focus here is on individual sound changes. ";
      "The results paint a similar picture, however. The input segments in " FigureReference(Figures.QRatesTop); " are either long vowels or diphthongs. ";
      "The output segments are similarly restricted. ";
      "Although there are eight transitions in the graph, there are only two output segments, the mid-high front vowel /e/ and the high back vowel /u/. ";
      };


    ShowFigureDoc(document, Figures.QRatesTop);
};
}
//======================================================================

namespace PaperSections.WordSegmentRelationships {
  Title = "Segmental Alignments";

  Body(DocumentClass document) = Block {
    FirstPar {
      "Our method treats the relationships of word segments from one language to another as a random variable. ";
      FigureReference(Figures.AlignmentExamples); " shows alignments for ";
      Cardinal(Figures.AlignmentExamples.Examples.Length);
      " of the words we analyzed. ";
      "For each word, the alignments form a 95% credible set, with alignments ordered from highest to lowest posterior probability. ";
      "This sample of alignments illustrates three key properties. ";
      "First, the distributions of credible sets exhibit extreme skew. ";
      "There is always a decisively optimal alignment. ";
      "Second, deletions occur predominantly at the end of the words. ";
      "Finally, the alignments tend to assign word segments from the same segment group to the same column in the alignment. ";
      "The alignment of the nasalized vowels is surprising, in that they are being aligned with nasal consonants, when in fact they are homologous with vowels.";
    };

    ShowFigureDoc(document, Figures.AlignmentExamples);
  };
}


//======================================================================

namespace PaperSections.RomanceLanguagePhylogeny {
  Title = "The Phylogeny of Romance";

  Body(DocumentClass document) = Block {
    BodyPar {
      "The majority-rule consensus tree (with a 50% cutoff) is presented in "; FigureReference(Figures.ConsensusTree); eos;
      "Latin was specified as an outgroup, according to the widespread view that it is a sister to the most recent common ancestor of the Romance languages"; Citation {hall1950; Pages: 19; hall1974; Pages: 14; vallejo2012; Pages: 458}; eos;
     "Despite a wealth of textual data from Latin and its medieval descendants, the phylogeny of Romance remains a challenge";
     Citation {hall1974; malkiel1978; koutna1990}; eos;
     "The topology of the tree in "; FigureReference(Figures.ConsensusTree); " correctly identifies long-established clades, such as Ibero-Romance (Spanish and Portuguese) and Gallo-Romance (French and Walloon) with posterior probabilities of 1. ";
     "The position of other languages, such as Catalan and Friulian, is less certain. ";
     "Indeed, Romance specialists themselves are less confident as to where these languages should be located in the tree. ";
     "The consensus tree also correctly reflects the fact that among the languages under investigation French and Walloon have undergone more segmental change (particularly in terms of deletions) than the other languages. ";


    };
    ShowFigureDoc(document, Figures.ConsensusTree);
  };
}


//======================================================================

namespace PaperSections.Discussion {
  Title = "Discussion";

  Body(DocumentClass document) = Block {

   FirstPar {
     "One aspect of the tree in " FigureReference(Figures.ConsensusTree); " that is at odds with current views of the phylogeny of Romance concerns Italian and Romanian. ";
     "Romanian is widely agreed on the basis of the relative chronology of sound changes to have diverged before Italian. ";
     "There are a number of possible causes for the position of Romanian. ";
     "One is segmental representation. ";
     "The position of Romanian is inferred on the basis of specific segmental agreements with Latin. ";
     "For instance, Latin "; textit{"buccam"}; Space; SQuote{"mouth"}; " and Romanian "; textit{"bucă"}; " preserve "; IPASegments.u; " against the " IPASegments.oh; " of Italian "; textit{"bocca"}; eos;
     "If word-forms with Romanian "; IPASegments.u; " are not present in sufficient number in the dataset, they will not play the role in topological inference that they do in the traditional literature. ";
     "The issue of segmental sampling is discussed further below. ";
     "A second possibility that may account for the topology is that the model is somehow misled by the superficial similarity (in both segmental composition and the preservation of segmental material) of Latin and Italian into putting them closer together on the tree than they actually are. ";
     "Finally, it is important to bear in mind that the transition model is homogenous. Such a model is unlikely to be linguistically realistic and may also influence topological estimation. ";
     };


   BodyPar {
     "There is a long debate—known as the "; DQuote{"Neogrammarian controversy"}; "—about the units involved in sound change. ";
     "Leonard Bloomfield famously declared "; DQuote{"phonemes change"}; Citation {bloomfield1933; Pages: 354}; eos;
     "According to this view, sound change is not only abrupt but also non-independent. ";
     "It is abrupt in that there are no intermediary stages in a transition from "; IPASegments.ah; " to "; IPASegments.oh; ", for instance. ";
     "It is non-independent because the transitions from one phoneme to another in each individual word are regarded as a single event, even if dozens or even hundreds of words are affected. ";
     "One consequence of this view is that the changes in each individual word-form are not independent and there is therefore just one change event from "; IPASegments.ah; " to "; IPASegments.oh; eos;
     "Other scholars have emphasized the role of acoustic and auditory phonetics in sound change";
     Citation {blevins2004a; ohala2003; ohala2012};
     ", while yet another view contends that sound change occurs by gradually making its way through the lexicon in a process known as lexical diffusion"; Citation {chen1975a; phillips2015}; eos;
     "Our method is not located within any one of these traditions, but rather has affinities with the phonemic approach and lexical diffusion. ";
     "Since our analysis is based on phonemic representations, it is phonemes that undergo insertions, deletions, and transitions. ";
     "These events are treated as independent, however. ";
     "Consider again the change from "; IPASegments.ah; " to "; IPASegments.oh; eos;
     "This is not modeled as a single transition in our framework. ";
     "Instead a rate of change is inferred based on the homologies of ";
     IPASegments.ah; " and "; IPASegments.oh; " in the data and how often the former transitions to the latter.";
   };



   BodyPar {

     "Under our framework a new issue in linguistic phylogenetics emerges, that of segmental sampling"; Citation {References.Dockum2019}; eos;
     "Certain segmental transitions can play a crucial role in topological inference, but under a sampling scheme such as ours, in which selection of concepts is guided by a Swadesh list, ";
     "there is no guarantee that the necessary segmental correspondences will be sampled. ";
     "There is the further question of the frequency distribution of segments in the dataset. ";
     "Some segments will be sampled far more often than others simply because they are more frequent in a language. ";
     "The sampling can thus influence estimates of equilibrium frequencies and transition rates. ";
     "The principles that guide the creation of Swadesh sampling schemes (namely low rates of borrowing and lexical change) will in all likelihood have to be modified under our framework to take into account issues of segmental distribution. ";

   };

   BodyPar {
     "Our event-based modeling approach to linguistic history has the power to transform the discipline by offering an inroad into questions that were previously intractable. ";
     "For instance, questions pertaining to the relationship between phonological change and the phonemic inventory of a language can now be addressed. ";
     "Does the frequency of a phoneme in the words of a language affect its diachronic stability? ";
     "To what extent is phonemic change sensitive to the size and structure of the phonemic inventory of a language? ";
     "What is the role of "; DQuote{"natural classes"}; " in phonological change? ";
     "This last question can be addressed in particular through comparison of models with different numbers of rate parameters. ";
     "The method can also be extended to handle more complex phonological changes (such as those involving context dependency), ";
     "to estimate divergence times and diversification rates in addition to topology, ";
     "or to model the history of words along a phylogenetic tree.";
   };

    BodyPar {
      "Our method models insertions, deletions, and transitions among segments. ";
      "An effort was made to exclude word-forms that involve changes of multiple segments (such as occur in morphological change). ";
      "Metathesis, a change in which two segments exchange positions, is modeled as separate transitions from the input and output segments. ";
      "For instance, the Latin verb "; textit{"exprimere"}; " begins with "; TextIpa{"eks"}; ", which in Romanian has become "; TextIpa{"sk"}; eos;
      "The initial vowel has been lost and "; IPASegments.k; " and "; IPASegments.s; " have undergone metathesis. ";
      "Under our model, the metathesis is treated as two separate transitions, one from "; IPASegments.k; " to "; IPASegments.s; " and another from "; IPASegments.s; " to "; IPASegments.k; eos;
    };

   BodyPar {
     "In sum, our approach offers not simply a new framework for linguistic phylogenetics, but one for computational historical linguistics in general. ";
     "It can be expanded and refined in various ways. For instance, it can be combined with methods of automatic cognate detection. ";
     "It can also address more complicated questions, such as context-dependent changes and changes involving multiple segments (such as metathesis). ";
   };
  };
}
//======================================================================

namespace PaperSections.MethodsSummary {
  Title = Lang.Methods;

  Body(DocumentClass document) = Block {
    FirstPar {
      "A detailed description of the model and analysis can be found in the supplemental material, [reference]. ";
      "What follows is an outline, sufficient in detail to provide an understanding of the model and experiments performed in this study.";
    };
  };
}
//======================================================================

namespace PaperSections.DataSummary {
  Title = Lang.Data;

  W = TextIpa {Span{TextAlignment: TextAlignments.Superscript; "w"}};

  Body(DocumentClass document) = Block {
    var data = MainResults.Data;

    FirstPar {
      "The initial set of data was downloaded from "; Wiktionary.Title; Citation{Wiktionary}; ", which was then manually checked for accuracy and augmented. ";
      "Words were double-checked against data from "; SoundComparisons.Title; Citation{SoundComparisons}; eos;
      "For each concept, lexical items descending from a common ancestor were grouped together into cognate sets. ";
      "Membership in a particular cognate set depends solely on shared descent; meaning is irrelevant. ";
      "For instance, the Latin adjective "; textit{"gravis"}; " means "; SQuote{"heavy"}; ", but its French descendant "; textit{"grave"}; " means "; SQuoteEnd{"serious"};
      "Despite this difference, they are assigned to the same cognate set because the two words are segmentally homologous"; eos;
      "Each word-form is represented phonemically in the International Phonetic Alphabet (IPA). ";
      "Phonemic representations were used in lieu of phonetic representations since phonetic data is harder to come by especially with corpus languages such as Latin. ";
      "Suprasegmental features such as stress are not represented in the data. ";
    };

    BodyPar {
      "The raw data set contains many cognate word-forms, but data for this experiment was limited to only those cognates that have word-forms from ";
      data.WordCutoff == data.Taxa.Length ? "all " : "at least ";
      data.WordCutoff; " languages. ";
      "There are in total "; data.UsedConcepts.Length; " concepts, "; data.UsedCognates.Length; " cognate sets, "; data.WordCount; " word-forms, using "; data.UniqueSegments.Length; " unique segments. ";
    };

//    ShowTable(document, Figures.PartitionAssignments, 8 pts);

    BodyPar {
      "Latin is a highly inflectional language, which means that there are multiple word-forms for verbs, nouns, and adjectives. ";
      "For verbs, infinitive forms were selected. ";
      "For nouns, singular forms in either the accusative or (rarely) the nominative case were used, since these are the two case forms ancestral to Romance descendants. ";
      "The selection of word-forms is not without consequences, since it impacts the rates of phonological change. ";
      "For instance, most masculine singular nominative adjectives in Latin end in -"; textit{"us"}; eos;
      "By contrast, feminine singular nominative adjectives end in -"; textit{"a"}; eos;
      "Use of the feminine forms would increase the number of transitions originating in this vowel.";
    };

    BodyPar {
      "All word-forms were manually aligned, so that historically related segments occur in the same column. ";
      "The manual alignments serve as the starting point for the MCMC sampling procedure (see below), so our analysis did not condition on any particular alignment of word segments being correct. ";
      TableReference(TableFigures.ManualAlignment); " provides an illustrative example of the alignment for the concept ";
      TableFigures.ManualAlignment.WordDisplay; eos;
      "The Latin form "; TextIpa{"kʷ-id"}; " begins with a voiceless velar stop with a secondary labial articulation "; W; eos;
      "In most Romance languages, this secondary articulation is lost, ";
      "but in some, it develops into a consonant in its own right (i.e., the "; TextIpa{"kw"}; " of French and Walloon). ";
      "To accommodate this change, the Latin form has two segmental slots before the vowel (i.e., ";
      IPASegments.kw.ShowSegment; "-), the second of which anticipates the development of the secondary articulation " W; "in French and Walloon"; eos;
    };

    ShowTable(document, TableFigures.ManualAlignment, 10 pts);
  };
}
//======================================================================

namespace TableFigures.ManualAlignment {
  Title = "An example of an aligned cognate set";

  WordDisplay = SQuote {
    TextCase: TextCases.AllLower;
    MainResults.Data.FigureConcept.GetVariable.Name;
  };

  Caption(DocumentClass document) = Span {
    "Manual alignment of the words for the concept ";
    WordDisplay;
    eos;
  };

  Body(DocumentClass document) = LanguageTable {
    var th = ExtentWidth * 0.02;
    TextHeight: th;

    var cognate = MainResults.Data.GetCognate(MainResults.Data.FigureConcept);

    Columns: [1.5 inches, 2.1 inches, 2.5 inch];
    LanguageTitleRow {
      Lang.Language; Lang.PhonemicRep; Lang.Alignment;
    };

    foreach (var word in cognate.Words) {
      Row {
        word.Language;
        TextIpa {word};
        word.ShowPaddedBlocks(th);
      };
    }
  };
}

//======================================================================

namespace TableFigures.WordCountTable {

  Caption(DocumentClass document) = Span {
    "Manual alignment of the words for the concept ";
    SQuote {
      TextCase: TextCases.AllLower;
      MainResults.Data.FigureConcept.GetVariable.Name;
      eos;
    };
  };

  Body(DocumentClass document) = LanguageTable {
    Columns: [1.5 inches]*3;
    LanguageTitleRow {
      Lang.Language; Lang.WordForms; Lang.SegmentCount;
    };

    foreach (var taxon in MainResults.Data.Taxa) {
      Row {
        taxon.Language;
        taxon.WordCount;
        Span {
          TextGroup: true;
          taxon.SegmentCount;
        }
      };
    }
  };
}

//======================================================================

namespace PaperSections.ModelInference {
  Title = "Model and Statistical Inference";

  InsertionLessThanDeletion = Span {InsertionRate; Tex.lt; DeletionRate};

  Body(DocumentClass document) = Block {
    var rule = MainResults.Rule;

    FirstPar {
      "We assume that modern languages are related to one another through an unknown phylogenetic tree, ";
      UnknownTree;
      ", that contains information on the relatedness of the languages ";
      InParens {Topology};
      " and the expected number of sound substitutions "; ExpectedEvents; " that occur along each branch of the tree. ";
      "Language evolves along the branches of the tree according to the TKF91 model"; Citation {thorne91}; " which allows either a word segment transition, insertion, or deletion to occur in an instant of time. ";
      "Insertions and deletions occur at rates "; InsertionRate; " and "; DeletionRate; " respectively, with "; InsertionLessThanDeletion; eos;
      "Phonemic substitution is modeled as a continuous-time Markov model with phonemes as the states of the process (our inventory consists of "; MainResults.Data.UniqueSegments.Length; " phonemes). ";
      "The rates of change between all pairs of states are contained in the rate matrix "; RateMatrix; ", which has parameters "; Span {Bold; RateMatrixParams}; eos;
    };

    BodyPar {
      "We perform estimation in a Bayesian framework, basing parameter estimates on the joint posterior probability distribution, ";
    };

    Equations.BayesianEstimation;

    BodyContinue {
      "where "; SegmentalInfo; " are the observed word segments for the cognate words. ";
      "The likelihood function, "; LiklihoodFunction;
      ", is calculated using the algorithm described by Lunter "; textit{"et al."}; Citation {lunter2003}; eos;
      "We use priors for the model parameters that are standard in phylogenetics, with the exception of the rate parameters for the insertions and deletions, ";
      "which are assumed to follow independent and identically distributed exponential distributions with "; InsertionLessThanDeletion; eos;
      "We numerically approximate the posterior distribution of the parameters using MCMC. ";
      "Specifically, we constructed a Markov chain that has as its states the parameters of the model and a stationary distribution that is the posterior distribution of interest. ";
      "Samples from this chain when at stationarity are valid, albeit dependent, samples from the posterior distribution. ";
      "Besides sampling the phylogenetic parameters of the model, the chain also samples word segment alignments"; Citation{lunter04}; eos;
    };

    BodyPar {
      var count = MainResults.Data.UniqueSegments.Length;
      "Our model of segmental transitions is based on phonological natural classes, which are groups of segments that share articulatory properties. ";
      "The segmental inventory of our dataset was exhaustively partitioned into ten classes, which are presented in "; TableReference(Figures.PartitionAssignments); eos;
      "This "; SQuote{rule.Name}; " model allows different rates among the ";
      Cardinal(rule.Filters.Length); " classes of segments ";
      //Span {
      //  Separator: CommaSpace;
      //  LastSeparator: " and ";
      //  rule.Filters;
      //};
      " It has ";
      count;
      " parameters for the equilibrium distribution and ";
      (rule.Filters.Length-1)^2-1;
      " parameters describing rates among natural classes. ";
      "The equilibrium frequencies are modeled as random variables drawn from a flat Dirichlet prior distribution. ";
    };

    ShowTable(document, Figures.PartitionAssignments);

  };
}

//======================================================================

namespace PaperSections.DataCuration {
  Title = "Data Curation and Analysis";

  Body(DocumentClass document) = Block {
    var example = new ExampleConceptClass(MainResults.Data, MainResults.Data.DataConcept);

    FirstPar {
      "Our analysis is coordinated using a program written in the Nytril programming language"; Citation {nytrilprogram}; eos;
      "We created an automated framework for the experiment that comprises a reusable IPA library, word data, ";
      "data quality checks, typeset output and input files for the MCMC software (written in C++). ";
    };

    BodyPar {
      "Word-forms from the "; MainResults.Data.Taxa.Length; " languages in our study, coded in standard unicode IPA, are organized into classes by concept and then by cognate class. ";
      "For example, the concept "; SQuote{TextCase: TextCases.AllLower; example.Name}; " is coded in the following way:";
    };

    SourcePar(MainResults.Data, example.Concept);

    BodyPar {
      "The dashes ("; SQuote{"-"}; ") denote the absence of a homologous segment present in other word-forms. ";
      "A challenge for programming in linguistics is that the IPA representation of words are expressed in Unicode (UCS), not ASCII or ANSI. ";
      "This requires care with file formats, text encodings and diacritic compositional form. ";
      "Furthermore, each IPA segment string can comprise several UCS code-points, so that the mapping between string characters and segments is not one-to-one. ";
      "Below is an example of a more complex encoding. The numbers in grey are the hexadecimal UCS code points for the letters and diacritics. ";
    };

    BodyPar {
      ParAlignment: ParAlignments.Center;
      IPASegments.VlAlveolarNSAffricate.ShowFrame(3 inches, 20 pts);
    };

    BodyPar {
      "Since our analysis requires each word to be seperated into segments, a parser converts word strings into arrays of segment objects that facilitate the manipulation of segments at a high level. ";
      "A reusable library of such objects endows each segment with linguistic features that can be used for analysis. ";
      "After the input step, all steps are coded using properties such as "; SQuote{"vowel"}; " and "; SQuote{"nasal"}; ", rather than working with strings of characters directly.";
    };

    BodyPar {
      "After the raw input is parsed, the control program aggregates and partitions the words and builds the data files for the MCMC program to perform Bayesian phylogenetic analysis under the TKF91 model. ";
      "The MCMC analysis runs for "; Span {MainResults.Data.MainRun.Config.Generations; TextGroup: true}; " cycles and repeats to check for convergence. ";
      "Samples taken during the first "; Span {MainResults.Data.MainRun.Config.PreBurn; TextGroup: true}; " cycles of the chain are discarded as burn-in. ";
      "When the analysis is complete, the results are read back into the control program. ";
      "The resulting tables, trees and graphical figures are automatically combined with narrative elements created by the authors to make the final paper and supplemental materials. ";
    }
  };
}

//======================================================================

namespace PaperSections.Acknowledgements {
  Title = "Acknowledgements";

  Body(DocumentClass document) = Block {
    FirstPar {
      Style.ShowInitials(People.JPHuelsenbeck); " was supported through NSF (1759909) and the Koret Foundation. We thank "; Style.ShowPerson(People.GALunter); " for help with the TKF91 model.";
    }
  };
}

//======================================================================

namespace PaperSections.Contributions {
  Title = "Author contributions statement";

  Body(DocumentClass document) = Block {
    FirstPar {
      Style.ShowInitials(People.DMGoldstein) " collected data, ";
      Style.ShowInitials(People.EBuchi); " corrected it, ";
      Style.ShowInitials(People.SHMcCreight); " developed the control software, and ";
      Style.ShowInitials(People.JPHuelsenbeck); " developed the MCMC software. ";
      Style.ShowInitials(People.DMGoldstein); CommaSpace;
      Style.ShowInitials(People.SHMcCreight); ", and ";
      Style.ShowInitials(People.JPHuelsenbeck); " wrote the manuscript. ";
    }
  };
}

//======================================================================

namespace PaperSections.Methods {
  Title      = Lang.Methods;
  StateCount = 5;

  Body(DocumentClass document) = Block {
    var data  = MainResults.Data;
    var ec    = new ExampleConceptClass(data, data.ExampleConcept);

    FirstPar {
      "We use ancestral classes, in which the descendant forms are segmentally aligned. ";
      "It is important to note that our definition of cognate refers only to segmental descent. ";
      "It takes no account of semantics whatsoever. ";
      "So the lexical items for "; SQuote{"ear"}; " in Romance are paired with the Latin word "; textit{"auricula"}; " which is the diminute form of "; SQuoteEnd{"ear"};
    };

    FirstPar {
      "Other things we have to mention: "
    };

    NumberList {
      "The data are surface forms, not underlying forms. ";
      "We used the accusative singular for nouns in Latin. ";
    };

    BodyPar {
      "Here, we describe the details of the modeling assumptions we make for the linguistic characters, how we estimate the parameters of the linguists model, and how different models describing the evolution of words can be compared in a statistical framework.";
    };

    BodyPar {
      BodyTitle {"Phylogeny relating languages"}; eos;
      "We assume that modern-day languages are related by an unknown evolutionary tree, called a ";
      SQuote {Phylogeny.Name}; " and denoted "; Phylogeny; eos;
      "The phylogeny contains information on the topological relationships among "; NumLanguages;
      " sampled languages as well as information on the divergence times of the languages or on the amount of change that occurred between the languages. ";
    };

    BodyPar {
      FigureReference(Figures.ExampleTree); " shows an example of a phylogeny for "; SampledLanguages(data.Taxa.Length); " languages. ";
      "In the terminology of evolutionary biology, the tree is composed of "; SQuote{"nodes"}; " and "; SQuoteEnd{"branches"};
      "(By contrast, mathematicians call nodes and branches "; SQuote{"vertices"} " and "; SQuote{"edges,"}; " respectively.) ";
      "The nodes represent the tips of the tree, each of which is assigned a language, and the points on the tree where the languages diverge from one another. ";
      "Each language-assigned tip node is labeled "; (TipLabelNumbers); ". ";
      "The interior nodes are labeled "; TipLabelInterior; " in preorder sequence (i.e., ordered sequentially from the tips to the root). ";
      "The root node is always assigned the label "; TipLastLabel; eos;
      "We denote the ancestor of node "; NodeIndex; " as "; AncestorNode(NodeIndex); eos;
      "In the tree of "; FigureReference(Figures.ExampleTree); ", the ancestor of node 3 is "; Equation {AncestorNode(3); Equals; 12}; eos;
    };

    BodyPar {
      "The branches connect the nodes of the tree and are represented as lines in "; FigureReference(Figures.ExampleTree); eos;
      "The branch is assigned the label from its descendant node, so for example in the tree of ";
      FigureReference(Figures.ExampleTree);
      ", the branch connecting nodes 12 and 13 is assigned the label 12. ";
    };

    ShowFigureDoc(document, Figures.ExampleTree);

    BodyPar {
      "A phylogeny is an information-rich graph. ";
      "For one, it contains information on the relationships of the languages. ";
      "This topological information is denoted "; Topology; eos;
      FigureReference(Figures.ExampleTree);
      " for example, suggests that "; French; " and ";  Walloon; " are each others’ closest relatives. ";
      "They are more closely related to each other than they are to any another language on the tree because they share a more recent common ancestor with each other than they do with any other language. ";
      "This common ancestor is the node numbered 15 in "; FigureReference(Figures.ExampleTree); eos;
      French; " and "; Walloon; ", together, are more closely related to "; Friulian; " in the tree of "; FigureReference(Figures.ExampleTree); eos;
      "Both French and Walloon are equally related to "; Friulian; " because they both share the same common ancestor with ";
      Friulian; ", at the node numbered ";
      data.LangNumber(Friulian); " in "; FigureReference(Figures.ExampleTree); eos;
      "It is important to realize that there are many possible ways in which the languages can be related to one another, with the tree of ";
      FigureReference(Figures.ExampleTree);
      " depicting only one of the possibilities. ";
      "In fact, for the case in which ";
      SampledLanguages(data.Taxa.Length);
      " languages are considered, there are "
      BranchFormula(data.Taxa.Length);
      " possible trees relating the languages. ";
      "In general, the number of possible rooted trees is the product of the odd numbers up to, and including, ";
      MaxBranch;
      ": ";
      PossibleTrees; eos;
      "Each topology is given a unique label, ";
      Equation {
        EllipsisList {
          Topology sub 1;
          Topology sub 2;
          Topology sub BN;
        };
      }; eos;
      "The number of possible tree topologies becomes quite large very quickly — it is a factorial, after all. ";
      "A linguist interested in the relationships among ";
      SampledLanguages(60);
      " languages, for example, would contend with ";
      Span {
        TextScientific: true;
        TextDigits: 2;
        BranchFormula(60);
      };
      " possible topologies, each depicting a unique and different way the languages can be related. ";
      "For comparison, the number of atoms in the known universe is on the order of "; 10 sup 80; eos;
    };

    BodyPar {
     "Ideally, the linguist would not only be able to estimate the correct topology relating the languages of interest, but also the times at which the languages diverged. ";
     "The interior nodes of the tree represent language divergence events that occurred at specific times in the past and are denoted ";
     Equation {
       Span {Bold; Time};
       Equals;
       InParens {
         EllipsisList {
           Time sub (NumLanguages Plus 1);
           Time sub (NumLanguages Plus 2);
           Time sub TipLastLabel;
         };
       }
     }; eos;

     "The tip nodes are all assigned the time ";
     Equation {
       Time; Equals; 0;
     }; eos;

     "Below, we will discuss in more detail a stochastic model of language change. ";
     "However, the model we use, along with every other stochastic model for phylogenies, has an all-important parameter that describes the rate at which the language changes. ";
     "This parameter is called the substitution rate and is denoted "; SubstitutionRate; eos;

     "Without external information that constrains the divergence times, such as one language divergence time that is considered known, perhaps from textual information, it is impossible to estimate the divergence times. ";
     "The problem is that one obtains the same net divergence between two languages from a high rate of language evolution and a short divergence time separating the languages, or a low rate of language evolution and a long time separating the languages. ";
     "In fact, the expected number of evolutionary events that occurred between two languages that diverged at time "; Time; " is ";
     Equation {
       ExpectedEvents;
       Equals;
       2;
       Time;
       SubstitutionRate;
     }; eos;

     "(The factor of two is introduced because the path between the two languages is the time from one language to the common ancestor, and then back up the tree to the other language.) ";
     "In this paper, we allow each of the "; MaxBranches; " branches of the tree to have an independent substitution rate. ";
     "Hence, the expected number of evolutionary events that occur along the "; Ith; " branch of the tree is ";
     ExpectedEventsPerBranch;
     eos;
     "In this study, we do not estimate the divergence times on the tree, but rather estimate the compound parameter representing the branch lengths (the ";
     Equation {ExpectedEvents sub sym.i};
     " which are in units of expected number of substitutions per segment (see below). ";
    };

    BodyPar {
      "To summarize, we assume languages only diverge from one another, ignoring events such as word assimilation. ";
      "We represent the divergence as a phylogeny containing information on both the topology and branch lengths, together denoted ";
      UnknownTree;
      eos;
      "One of the goals of this study is to estimate these parameters from the data collected from each language."
    };

    BodyPar {
      BodyTitle {"Data"}; eos;
      "The similarities of words from different languages are informative about how the languages are related. ";
      "In this study, we use statistical methods developed in the field of evolutionary biology to estimate the relationships of species based on either the morphological characteristics of the species or the DNA sequences sampled from the same gene and compared across the species. ";
      "The methods assume that the characteristics compared across species are homologous. ";
      "Homology, in evolutionary biology, is similarity in some characteristic that is caused by common ancestry. ";
      "Consider as an example the following DNA sequences sampled from three species,";
    };

    BodyTable {
      Columns: [1 inch, 5 inches];
      AnimalRow(each ExampleAnimals);
    };

    BodyPar {
      "These are partial mitochondrial sequences from Gojobori88"; Citation {Gojobori88}; eos;
      "In the original paper, the complete data had ";
      SampledLanguages(12);
      " primate species and the sequences were each 898 nucleotides in length. ";
      "In a phylogenetic analysis of DNA sequenes, homology is assumed at two levels. ";
      "First, one assumes that the sequences that are compared are homologous. ";
      "Typically, homology at this level is established by sequence similarity and synteny of the gene (e.g., the gene that is compared across species is in the same, or at least similar, position along the chromosome when compared across species, which is another way of saying the gene that is compared has the same neighboring genes in all of the species in the analysis). "
    };

    BodyPar {
      "Not only must the DNA sequences be homologous, but the fine-scale homology of the sequences must also be established. ";
      "The DNA sequences, above, are in an aligned form in which the fine-scale homology has been established; ";
      "each column of the alignment is considered to be homologous. ";
      "So, for example, the first column of the alignment which happens to be the nucleotide A in all three species is assumed to be homologous; ";
      "it is assumed that the common ancestor of gorillas, chimpanzees, and humans had the same gene that also had a position that was homologous to the first column in the alignment. ";
      "Fine-scale homology is established using computer programs in a process called "; SQuoteEnd{"alignment"};
      "Importantly, phylogenetic methods assume that the homology established by the alignment program is correct.";
    };

    BodyPar {
      "Linguistic information, of course, is not like biological information. ";
      "In the past, linguists attempted to find homologous words, called cognates. ";
      "Typically, words are chosen that are thought to be resistant to assimilation. ";
      "Variation in the cognate words is carefully scrutinized by the linguist and encoded in a way that computer software, developed with biological character data in mind, can read and produce sensible results. ";
      "The encoding process produces variants on a cognate word with the variant states coded as 0 or 1 (or sometimes more, if there are more than two states for the word). ";
    };

    BodyPar {
      "In this study, we take a different approach. ";
      "Like others, we concentrate on the so-called "; SQuote{"basic vocabulary"}; " of a language "
      NeedsReview("SWADESH REFERENCE");
      ", since the lexical items that instantiate concepts in this domain are less prone to horizontal transmission (i.e., linguistic borrowing). ";
      "In contrast to every study of linguistic phylogenetics that we are aware of, however, our investigation draws inferences from segmental information. ";
      "For each concept in our dataset, homologous lexical items are assigned to the same class, which we refer to as a ";
      Definition("cognate class"); eos;
      "The word-forms within each cognate class are phonemic representations based on the International Phonetic Alphabet (IPA) ";
      NeedsReview("IPA REFERENCE"); eos;
      "Consider the following word-forms for one of the cognate classes for the concept ";
      SQuote {ec.Name};
    };

    SegmentTable(ec, data, true);

    BodyContinue {
      "The word for "; SQuote {ec.Cognate.Concept.Name};  " in "; ec.Taxon.Language; ", for example, is "
      "/"; ec.LangWord; "/. ";
      "The matrix for the word "; ec.Name; " also assumes that the fine-scale homology of the segments has been established. ";
      "For example, the above matrix for the concept "; SQuote {ec.Name};  " assumes that the first segment of the ";
      TextList {ec.LangNames};
      " languages (respectively, ";
      TextList {
        Style.IPAFamily;
        ec.FirstLetters
      };
      ") are homologous. ";
      "The dashes indicate that there is no homologous segment at that potential position in the word. ";
      "Note that the first segment for the word ";
      ec.Name;
      " in "; ec.Callout.Language; " is also "; ec.CalloutSegment; eos;
      "Why wasn't the first segment from Italian considered to be homologous to the first segments in ";
      TextList {ec.LangNames};
      "? ";
      "In this case, the alignment program chose the alignment that did not consider ";
      SQuote {ec.CalloutSegment}; " of "; ec.Callout.Language; " as homologous to the ";
      SQuote {ec.CalloutSegment}; " of French based on the settings chosen by the user. ";
      "It may be that other alignments are nearly as good as the one that is illustrated. ";
      FigureReference(Figures.Alignment);
      " shows two possible alignments of the word "
      ec.Name;
      eos;
    };

    BodyPar {
      "Note that a segmental alignment, denoted ";
      SegmentalAlignment;
      ", is constructed by combining the word segment information for the languages of interest with information on the homology of the segments. ";
      "The segmental information for the ";
      NumLanguages;
      " languages of interest is denoted ";
      Equation {
        SegmentalInfo;
        Equals;
        InParens {
          EllipsisList {
            Segment sub 1;
            Segment sub 2;
            Segment sub NumLanguages;
          }
        }
      };
      ", where ";
      Defs.Segment sub sym.i;
      " is the segmental string for the ";
      Ith;
      " language. ";
      "The segmental information for the ";
      SampledLanguages(MainResults.Data.Taxa.Length);
      " languages for the cognate class above for ";
      SQuote {ec.Name}; " is:";
    };

    SegmentTable(ec, MainResults.Data, false);

    BodyPar {
      "Here, the segments for "; ec.Taxon.Language; " would be ";
      Equation {
        Segment sub 1;
        Equals;
        InParens {
          ec.LangWord
        }; eos;
      };
      "The alignment of the segments is accomplished by the use of a map, ";
      HomologyMap;
      ", describing the homology of the word segments. ";
      "The alignment is formed by combining the word segment information with the homology map, ";
      Equation {
        SegmentalAlignment;
        Equals;
        Arguments {
          SegmentalInfo;
          HomologyMap;
        };
      }; eos;
      FigureReference(Figures.Alignment);
      " shows an example of two alignments for the word ";
      ec.Name;
      " that can be formed using two different homology maps. ";
    };

    ShowFigureDoc(document, Figures.Alignment);

    BodyPar {
      "Ultimately, the linguist observes the phonetic (in the case of contemporary languages) or graphemic (in the case of corpus languages) forms of words, on the basis of which phonemic representations are posited. ";
      "The alignment, by contrast, is not directly observed. ";
      "There are many different ways in which the segments from a cognate word can be homologous. ";
      "The example from the word "; ec.Name; ", above, shows only one such way. ";
      "In this study, we develop the statistical and analytical machinery that allow us to marginalize over the segmental alignments. ";
      "Our method considers all possible segmental alignments of the word-forms in a cognate class, weighting each such possibility by its probability under a model. ";
      "In this way, our method does not condition on any specific segmental alignment.";
    };

    BodyPar {
      BodyTitle {"Language evolution model"}; eos;
      "We assume that cognate words evolve along the branches of a phylogenetic tree through substitution of one segment by another, insertion of a new segment, or deletion of a segment.";
    };

    BodyPar {
      TextColor: Colors.Red;
      LeftIndent: 0.25 inches;
      "The process of linguistic change is more complex than this sentence allows. ";
      "There are cases where entire words disappear and emerge. ";
      "There are also cases in which the form of word can change with addition or deletion of a block of segments (called a morpheme). ";
      "If we want to restrict our scope to the forms of change mentioned at the beginning of this paragraph (i.e., to segmental transitions), we can do that, but that will impact the data that I collect. ";
      "We would also need to make it explicit that we are by design excluding certain types of well-known linguistic change.";
    };

    BodyPar {
      "Substitution of one segment for another is modeled using a continuous-time Markov model in which the possible states are the set of segments in the phonemic representations. ";
      "At the heart of a continuous-time Markov chain is a rate matrix describing the rate of change between all pairs of states. ";
      "As an example, consider a simplified Markov process with only "; Cardinal(StateCount); " segments as states. ";
      "The rates of change between the pairs of states can be represented in table form as";
    };

    BodyPar {
      ParAlignment: ParAlignments.Center;
      Frame {
        StateSection.StateTable(StateCount);
      };
    };

    BodyContinue {
      "where ";
      RateChange;
      " is the rate of change from segment "; sym.i; " to segment "; sym.j; eos;
      "The diagonal elements of the rate matrix "; qii; " are specified such that each row sums to zero (i.e., ";
      DiagonalElements;
      "); this negative value can be interpreted as the rate at which the process moves away from state "; sym.i; eos;
      "Note that the information on rates of change between all pairs of states is not typically represented in table form, but rather in matrix form as";
    };

    RatesOfChangeBetweenStates;

    BodyContinue {
      "Here, we introduce an additional parameter, ";
      RateMatrixScale;
      ", that scales the rate matrix such that the average rate of segmental substitution is one.";
    };

    BodyPar {
      "A continuous-time Markov model has a simple physical interpretation. ";
      "Specifically, when the process is in state "; sym.i; ", one waits an exponentially-distributed time with parameter ";
      Negative qii; " until the next  segmental substitution occurs. ";
      "The change, when it occurs, is to state ";
      sym.j;
      " with probability ";
      Equation {Negative; qij; Tex.Divide; qii;}; eos;
      "Several important quantities can be calculated using the information contained in the rate matrix, ";
      RateMatrix; eos;
      "For one, the probability the process ends in state ";
      sym.j;
      " conditional on starting in state ";
      sym.i;
      " after a period ";
      ExpectedEvents;
      " can be calculated through exponentiation of the rate matrix, ";
      ExponentiationOfRateMatrix; eos;
      "One can also calculate the equilibrium distribution of the process — denoted ";
      EquilibriumDistribution;
      " and interpreted as the probability of capturing the process in a particular state after a very long time (formally, an infinite amount of time) has passed — by solving the system of equations defined by ";
      RateMatrixSolution; eos;
      "Both the transition probabilities and equilibrium probability distribution play an important role in calculating the likelihood (see below).";
    };

    BodyPar {
      "Insertions and deletions of single segments occur at rates ";
      InsertDelete(" and ");
      ", respectively. ";
      "Consider, for a moment, the long-term behavior of a process in which ";
      InsertDelete(Tex.gt); eos;
      "On average, segments would be inserted more frequently than they would be deleted. ";
      "Word-forms, then, would evolve to become a mouthful, growing without bounds. ";
      "The opposite situation occurs when ";
      InsertDelete(Tex.lt);
      ", in which segments are deleted at a higher rate than they are inserted. ";
      "In this case, words would be whittled down to nothing; ";
      "a language speaker would not find the words to describe anything, even important people in the person's life, such as the person who gave birth to him or her! ";
    };

    BodyPar {
      "TKF91"; Citation {thorne91}; " described a model of DNA sequence evolution that allowed single nucleotides to be inserted and deleted at rates ";
      InsertDelete(" and "); eos;
      "They introduced a convention for thinking about a DNA sequence in which nucleotides were connected by invisible links. ";
      "Each nucleotide paired with the link to its right. ";
      "The left-most nucleotide had to its left a special link, termed the immortal link. ";
      "Importantly, when a nucleotide was inserted, it was inserted to the right of a link and brought along its own link (to its right). ";
      "Deletions removed a nucleotide and the paired link. Importantly, the immortal link is never deleted. ";
      "So, in the event that "; InsertDelete(Tex.lt); ", the process does not actually go extinct. ";
      "Rather, a nucleotide (and its link) can be inserted to to the right of the immortal link. ";
      "In the model described by TKF91 they constrain the insertion rate to be less than the deletion rate ";
      InsertDelete(Tex.lt); eos;
      "The equilibrium distribution of a sequence length is then geometrically-distributed with parameter ";
      InsertDelete(Tex.Divide); eos;
      "We follow the convention of TKF91 in this study. ";
      "In fact, the model we use is precisely the same as the TKF91 model, but with a different continuous-time Markov model used to describe segmental transitions (instead of the four-state process describing nucleotide substitutions used by Throne et al., 1991)."
    };

    BodyPar {
      "The overall substitution and insertion/deletion process can be described as follows. ";
      "In a sequence ";
      WordLength;
      " segments in length, of which ";
      WordLength sub sym.i;
      " of them are of segment type ";
      sym.i;
      ", the time until the next event occurs is exponentially-distributed with parameter ";
    };

    InDelDistribution;

    BodyPar {
      "When an event occurs, it is a substitution with probability ";
      InDelProbability;
      ", an insertion with probability ";
      EventInsertionProbability;
      ", and a deletion with probability ";
      EventDeletionProbability;
      eos;
      "Importantly, the process allows the alignment map ";
      InParens {HomologyMap};
      " to be treated as a parameter of the model. ";
    };

    BodyPar {
      BodyTitle {"Bayesian estimation of language evolution model parameters"}; eos;
      "We estimate the parameters of the language-evolution model in a Bayesian framework. ";
      "Bayesians base inferences on the posterior probability distribution of a parameter, which can be calculated using Bayes’ theorem as";
    };

    BayesTheorem;

    BodyContinue {
      "where the vertical bar indicates a conditional statement. ";
      "In words, the posterior probability distribution of the parameters is equal to the likelihood ";
      InBrackets {PPO};
      " times the prior probability distribution ";
      InBrackets {PP};
      ", divided by the marginal likelihood ";
      InBrackets {PO}; eos;
    };

    BodyPar {
      "In this study, parameters include:";
    };

    BodyTable {
      Columns: [new ColumnClass(1 inches, null, HAligns.Right), 20 pts, 4 inches];
      ParamRow {
        ParamList(Topology);
        "Tree Topologies";
      };
      ParamRow {
        ParamList(ExpectedEvents);
        "Branch length parameters";
      };
      ParamRow {
        Equation {RateMatrixParams};
        Span {RateMatrixParams.Description; Space; Equation {RateMatrix}};
      };
      ParamRow {
        Equation {InsertDelete(", "); Space; InParens {InsertDelete(Tex.lt)}};
        "The insertion and deletion rates of  segments";
      };
      ParamRow {
        HomologyMap;
        HomologyMap.Description;
      };
    };

    BodyPar {
      "We assign prior probability distributions to all parameters of the model (see Table 1). ";
      "The posterior probability distribution of the linguistic model parameters is then";
    };

    PosteriorProbabilityDistribution;

    BodyContinue {
      "Note that the likelihood is marginalized over all possible alignments, "
    };

    MarginalizationOverAlignments;

    BodyContinue {
      "where the sum is over all possible alignment maps, which implies that our inferences are not conditioned on any particular alignment of segments being correct. ";
      "Similarly, the marginal likelihood accounts for all possible combinations of model parameters:";
    };

    MarginalLikelihoodParameters;

    BodyContinue {
      "where the integrals represent integration over all possible combinations of branch lengths, rate matrix parameters, and insertion/deletion rates.";
    };

    BodyPar {
      "We calculate the likelihood on a per-word basis using the algorithm described by Lunter et al. (2003) that conditions on an alignment. ";
      "Although the posterior probability distribution can be written down, and individual components such as the prior probability or likelihood for a particular combination of parameters can be calculated, analytically solving the high dimensional summations and integrals required for the posterior probability is unfeasible. ";
      "Instead, we numerically approximate the joint posterior probability distribution of the parameters using Markov chain Monte Carlo.";
    };

    BodyPar {
      BodyTitle {"Markov chain Monte Carlo"}; eos;
      "The aim with Markov chain Monte Carlo (MCMC) is to construct a Markov chain that has as its possible states the parameter values of the statistical model and a stationary distribution that is the posterior probability distribution of the parameters. ";
      "Metropolis et al. (1953)";
      Citation {metropolis53};
      " and Hastings (1970)";
      Citation {hastings70};
      " described rules that allow the scientist to construct such a chain. ";
      "When at stationarity, samples from this chain form valid, albeit dependent, samples from the posterior probability distribution. ";
      "The Metropolis-Hastings algorithm constructs the Markov chain using the following algorithm:";
    };

    NumberedList {
      ParAlignment: ParAlignments.Left;

      Paragraph {
        "The current state of the chain is denoted ";
        RateMatrixParams; eos;
        "If this is the first cycle of the Markov chain, initialize ";
        RateMatrixParams;
        ", perhaps by choosing a value from the prior distribution.";
      };

      Paragraph {
        "Propose a new value for "; RateMatrixParams; " denoted "; NewValueProposal; eos;
        "The proposal mechanism is up to the programmer, but must involve the generation of random numbers ";
        RandomNumber;
        " such that the proposed value is a function of the current value and the random numbers, ";
        Equation {
          NewValueProposal;
          Equals;
          "h"; Arguments {
            RateMatrixParams;
            RandomNumber;
          };
        }; eos;

        "The probability of proposing the new value is ";
        NewProposal(RateMatrixParams, RateMatrixParams);
        "whereas the probability of the imagined reverse move, not actually made in computer memory, is ";
        NewProposal(NewValueProposal, RateMatrixParams);
      };

      Paragraph {
        "Calculate the probability of accepting the proposed value:";
        LineBreak;
        Tab;
        ProbOfAcceptingProposal;
        LineBreak;
        "In words, the acceptance probability is the product of the likelihood, prior, and proposal ratios.";
      };

      Paragraph {
        "Generate a uniform(0,1) random variable, ";
        Equation {
          RandomNumber
        }; eos;
        "If ";
        Equation {
          RandomNumber;
          Tex.lt;
          ProbOfAccepting;
        };
        ", accept the proposed state, setting ";
        Equation {
          RateMatrixParams;
          Equals;
          NewValueProposal;
        }; eos;
        "Otherwise, the proposed state is said to be rejected and the chain remains in state ";
        Equation {
          RateMatrixParams;
        };
      };

      Paragraph {
        "Return to Step # 1.";
      };
    };

    BodyPar {
      "The proposals we implement in this study are all typical for phylogenetic models. ";
      NeedsReview("Some details here");
      "The unique aspect of this study is a proposal mechanism for the alignments of the segments for various words. ";
      "Here, we use the proposal mechanism described by Lunter et al. (2005). ";
    };

    BodyPar {
      NeedsReview("A bit on interpretation of MCMC results here.");
    };

    BodyPar {
      BodyTitle {"Model comparison"}; eos;
      "In a Bayesian analysis, parameter estimates are based on the joint posterior probability distribution of the parameters, which we numerically approximate using the Metropolis-Hastings algorithm. ";
      "Often, however, the linguist is interested in the comparison of two or more models with the goal of evaluating which of the models best explains the observations. ";
      "Bayesian model comparison is based on the marginal likelihoods of the models. ";
      "Consider two different linguistics models, ";
      Model sub 1; " and "; Model sub 2;
      " with marginal likelihoods, "; PSM(1); " and "; PSM(2);
      " (note the marginal likelihoods are calculated for the same observations). The ratio of the marginal likelihoods,";
    };

    ModelComparison;

    BodyContinue {
      "called the Bayes Factor, measures the relative support of the two models; ";
      "a Bayes Factor less than one favors ";
      Model sub 1;
      " whereas the oppose is true for a Bayes factor greater than one. ";
      "Unlike in frequentist statistics, one does not obtain p-values in a Bayesian comparison of models. ";
      "Rather, the Bayes Factor is interpreted as is, or on a log scale. ";
      "Jeffreys (1961) provided a table to help with the interpretation of Bayes Factors:";
    };

    BodyTable {
      Columns: [1 inches, 1 inches, 3 inches];
      Row {
        Border: BorderB(0.5 pts);

        BayesFactor;
        Span {"log" sub 10; BayesFactor};
        "Interpretation";
      };
      Row {
        Span {1; Minus; 3.2};
        Span {0; Minus; 1/2};
        "Not worth a bare mention";
      };
      Row {
        Span {3.2; Minus; 10};
        Span {1/2; Minus; 1};
        "Substantial";
      };
      Row {
        Span {10 Minus 100};
        Span {1 Minus 2};
        "Strong";
      };
      Row {
        Span {Tex.gt; 100};
        Span {Tex.gt; 2};
        "Decisive";
      };
    };

    BodyPar {
      "In a Bayesian analysis, there is no need to penalize parameter rich models for having more parameters. ";
      "Rather, the penalization is built into the comparison; ";
      "the additional parameters in a complicated model are each assigned a prior probability distribution. ";
      "A parameter-rich model has lower prior probability for any combination of model parameters than a simpler model. ";
      "Hence, there is no need to compare the Bayes factor to a null distribution as there is in frequentist hypothesis testing.";
    };

    BodyPar {
      "The main limitation of Bayesian model comparison is numerically approximating the marginal likelihoods of the models. ";
      "This can be done in numerous ways. ";
      "For example, one can construct a Markov chain that jumps between models, even if the models differ in dimensions, using a generalization of MCMC described by Green (1995; reversible-jump MCMC). ";
      "Alternatively, one can numerically approximate the marginal likelihoods using what is called path-sampling in which numerous MCMC chains explore a path between the prior and posterior distributions ";
      NeedsReview("citations"); eos;
    };

    BodyPar {
      "In this study, we compare two models. ";
      "The first model is the simplest one we could devise, assuming that the rate of change between all segments is equal. ";
      "Our first model is isomorphic to the earliest model of DNA substitution, called the Jukes and Cantor model in molecular evolution (Jukes and Cantor, 1969)";
      Citation{jukes69}; eos;
      "The second model assumes that the rate of change to ";
      NeedsReview("something");
      " is potentially different than the rate of change to ";
      NeedsReview("something else");
      ":";
    };

    BodyTable {
      Columns: [0.5 inches, 5 inches];
      Row {
        Span {Model sub 1; ":"};
        Equation {
          qij;
          Equals;
          Tex.alpha;
          " (i.e., all elements of rate matrix are equal)";
        };
      };
      Row {
        Span {Model sub 2; ":"};
        HBox {
          VAlign: VAligns.Center;
          qij;
          Equals;
          VBox {
            Brackets: Brackets.FlatCurly.Left;
            IfValue(Tex.alpha, " is a something");
            IfValue(Tex.beta, " is a something else");
          };
        };
      };
    };
  };
}

IfValue(a, text) = Span {
  a;
  " if ";
  sym.i;
  Tex.rightarrow;
  sym.j;
  text;
};

IntegrateOver(v) = Integral {
  TextStacked: false;
  Lower: v;
};

ParamList(v) = Equation {EllipsisList {v sub 1; v sub BN}};

FD(x) = Span {Space; Italic "d"; x};

Prob(x) = Equation {
  MarginalLikelihood;
  InParens {x};
};

PSM(n) = Prob(Condition {SegmentalInfo; Model sub n});

NewProposal(start, end) = Equation {
  ProbProposal;
  InParens {
    start;
    Tex.rightarrow;
    end;
  }
};

ProbVar(x, extra=null) = Prob(CommaList {
  Condition{x; Topology};
  ExpectedEvents;
  RateMatrixParams;
  InsertionRate;
  DeletionRate;
  extra;
});

ProbALL = Prob(CommaList {
  Topology;
  ExpectedEvents;
  RateMatrixParams;
  InsertionRate;
  DeletionRate;
});

ParamRow = Row {
  Separator: Empty;
};

PPO = Prob("Parameter(s) | Observations");
POP = Prob("Observations | Parameter(s)");
PP  = Prob("Parameter(s)");
PO  = Prob("Observations");

InsertDelete(by) = Span {
  InsertionRate;
  by;
  DeletionRate;
};

SegmentTable(ExampleConceptClass example, DataSetClass data, aligned) = BodyTable {
  Columns: [1.5 inches, 16 pts];

  var words = example.Cognate.Words;
  foreach (var taxon in data.Taxa) {
    Row {
      taxon.Language;
      var list = aligned ? words[taxon.Index].Padded : words[taxon.Index].Segments;
      (each list).ShowSegment;
    }
  }
};
//======================================================================

namespace PaperSections.Conclusion {
  Title = "The Rate Matrix in this model of Linguistics";

  Body(DocumentClass document) = Block {
    FirstPar {
      "Our model describes how the segments evolve along the branches of the tree. We have three events that can occur to change a word: an insertion of a single segment, a deletion of a single segment, and a substitution of a segment.";
    };


    BodyPar {
      "A substitution is the replacement of a word segment by another segment. We model substitutions as occurring according to a continuous-time Markov model. Such a model can be understood if you know two things: the possible states and the rate of change between all pairs of states. For our work, the states are the "; MainResults.Data.UniqueSegments.Length; " possible segments. The rates of change between all pairs of states are contained in a rate matrix, which we denote "; RateMatrix; eos;
   };

    BodyPar {
      "You can completely describe the substitution process if you have "; RateMatrix; eos; "We use "; RateMatrix; " to calculate transition probabilities (by exponentiating the product of the rate matrix and the branch length) and also to get the stationary frequencies of the process (which are the probability of capturing the process in some state after infinite time has passed)."
    };

    BodyPar {
      "Now, for understanding the rate matrix. Let’s denote "; qij; " as the rate of change from state "; sym.i; " to state "; sym.j; ". (It’s simply an element of the rate matrix, "; RateMatrix; "). This is literally the rate of change to that state when the process is in state "; sym.i; ". Comparing rates in the rate matrix can be useful. You can say things such as, “ This rate is higher than that rate. This makes sense because everyone knows that such changes occur frequently in language.” I would especially compare rates in a single row. Does it make sense to see, for example, that when changes occur, they are more likely to be to other states in the same class? Does it make sense that when we have a change and a segment is in the green class that it is more likely to be to a word segment in the dark gray and brown classes? That’s how I read "; FigureReference(Figures.QRatesMatrix); eos;
    };

    BodyPar {
      "That said, I think the diagonals are quite interesting because they give you an idea of the relative volatility of the word segments. The diagonals are simply the negative of the sum of the off-diagonal components of the row:"
    };

    Equations.OffDiagonalComponents;


    BodyPar {
      "where "; sym.j; " is iterated over all states (for "; sym.i; Tex.neq; sym.j; "). What does this mean? Let’s consider two segments one of which has a diagonal value of –1.0 and the other that has a value of –2.0. The rate of change for the first, then, is 1.0 and the second is 2.0. This means that the second segment is in a sense more volatile than the first. When we are in the second segment, we move to another state at a rate 2.0 which is twice the rate of the first segment."
    };

    BodyPar {
      "What should you look for here with respect to the linguistic data? Well, I don’t know. I’m hoping that, with this interpretation under his belt, David will see patterns that make sense. Are certain word segments known to be more volatile in language? Are others known to be more conservative? Does this background knowledge in the field match up with the rates we are getting (the diagonal values)?"
    };

    BodyPar {
      "The other graphs show the average rates. The average rates can be calculated from the rate matrix, "; RateMatrix; ". To distinguish the average rate matrix from the rate matrix, "; RateMatrix; ", I will denote it "; AverageMatrix; ". The "; sym.ij sup "th"; " element of this average rate matrix is calculated as "; AverageRateElement; ". In words, the average rate of change from state "; sym.i; " to state "; sym.j; " is equal to the probability of starting in state "; sym.i; " and then moving to state "; sym.j; "."
    };

    BodyPar {
      "What do the average rates tell us? I think the interpretation is a little more confusing, but still well defined. We are looking at averages now, over all of the characters and taking into account their frequencies. A segment that is frequent in the data set will have a boost, here, because "; Probability sub sym.i; " will be higher."
    };

    BodyPar {
      "Perhaps the best way to think of this is as follows: "; AverageMatrix; " tells you the average rates and takes into account the probability of starting in state "; sym.i; eos; RateMatrix; ", by contrast, assumes you are already in state "; sym.i; " and tells you how rapidly you move to various states (from "; sym.i; " to the other possible states). I believe for our purposes, you should concentrate on "; RateMatrix; eos;
    };

    ShowFigureDoc(document, Figures.QRatesMatrix);
  };
}
//======================================================================

