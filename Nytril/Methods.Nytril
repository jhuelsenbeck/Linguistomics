using Format, Units, Math, IO, Style, Defs;
//======================================================================

with Figures.ExampleTree {
  Number = 1;

  LanguageList = [
    Languages.Latin,
    Languages.Romanian,
    Languages.Catalan,
    Languages.Portuguese,
    Languages.Spanish,
    Languages.French,
    Languages.Walloon,
    Languages.Friulian,
    Languages.Italian,
  ];

  Tip(i, length)       = new TreeNodeClass("{0} ({1})"(LanguageList[i-1].Name, i), length);
  Branch(name, length) = new TreeNodeClass(name, length);

  Nodes = Branch(17, 1) {
    Tip(1, 7);
    Branch(16, 1) {
      Branch(14, 1) {
        Branch(13, 1) {
          Tip(2, 4);
          Branch(12, 1) {
            Tip(3, 3);
            Branch(11, 1) {
              Branch(10, 1) {
                Tip(6, 1);
                Tip(7, 1);
              };
              Tip(8, 2);
            };
          }
        };
        Tip(4, 5);
      };
      Branch(15, 5) {
        Tip(5, 1);
        Tip(9, 1);
      };
    };
  };


  Body = TreeOptions {
    Root: Nodes;
  };

  Caption = "An example tree showing the relationships of {0} languages."(SampledLanguages(LanguageList.Length));
}
//======================================================================

with StateSection {
  CellPad = Margin(1 pts, 1 pts, 3 pts, 0);
  States  = 'A'..'E' step 1;

  MatrixRow(state) = {
    foreach (var s in States) {
      Cell {
        qsub(state s);
      }
    }
  };

  StateRow(state) = Row {
    Cell {
      HAlign: HAligns.Right;
      Span {
        EachIndex == States.Length div 2 ? Lang.From + Space*3 : Empty;
        state;
      }
    };
    MatrixRow(state);
  };

  StateTable = Table {
    ParAlignment: ParAlignments.Center;

    VAlign: VAligns.Center;
    HAlign: HAligns.Center;
    Padding: CellPad;
    Columns: [(1 inch) {EdgeR: Style.TableEdgeSize}] + 5*[0.5 inches];
    Row {
      Empty;
      Cell {
        ColSpan: States.Length;
        Lang.To;
      };
    };
    Row {
      EdgeB: Style.TableEdgeSize;
      Empty;
      States;
    };
    StateRow(each States);
  };

  StateMatrix = MatrixBlock {
    BracketLR: Brackets.FlatRound;
    foreach (var state in States) {
      Row {
        MatrixRow(state);
      }
    }
  };
}
//======================================================================

with Abstract {
  Title = Lang.Abstract;
  Body  = Block {
    Style.BodyPar {
      "Linguistically phylogenies are standardly inferred on the basis of cognate relationships, which are discrete representations of ancestry. Although inference on the basis of such datasets has yielded important results, it suffers from an obvious fault: it ignores the phylogenetic signal in the segmental form of words. In this paper, we infer the phylogeny of Romance on the basis of segmental data...";
    };
  };
}
//======================================================================

with Content.Introduction {
  Title = Lang.Introduction;
  Body  = Block {
    Style.BodyPar {
      "In this paper, we attempt to do the impossible!";
    };
  };
}
//======================================================================

with Content.Methods {
  Title = Lang.Methods;
  Body  = Block {
    BodyPar {
      "Here, we describe the details of the modeling assumptions we make for the linguistic characters, how we estimate the parameters of the linguists model, and how different models describing the evolution of words can be compared in a statistical framework.";
    };

    BodyPar {
      BodyTitle {"Phylogeny relating languages."};
      "We assume that modern-day languages are related by an unknown evolutionary tree, called a {0} and denoted {1}."(SingleQuote {Phylogeny.Name}, ShowVar(Phylogeny));
      "The phylogeny contains information on the topological relationships among {0} sampled languages as well as information on the divergence times of the languages or on the amount of change that occurred between the languages."(TipLabelCount);
    };

    BodyPar {
      "Figure 1 shows an example of a phylogeny for {0} languages."(SampledLanguages(Results.UsedLanguages.Length));
      "In the terminology of evolutionary biology, the tree is composed of `nodes' and `branches.'";
      "(By contrast, mathematicians call nodes and branches `vertices' and `edges,' respectively.)";
      "The nodes represent the tips of the tree, each of which is assigned a language, and the points on the tree where the languages diverge from one another.";
      "Each language-assigned tip node is labeled {0}."(TipLabelNumbers);
      "The interior nodes are labeled {0} in preorder sequence (i.e., ordered sequentially from the tips to the root)."(TipLabelInterior);
      "The root node is always assigned the label {0}."(TipLastLabel);
//      "We denote the ancestor of node $i$ as $\sigma(i)$.";
//      "In the tree of Figure 1, the ancestor of node 3 is $\sigma(3)=12$.";
    };

    Style.DocumentFigure(Figures.ExampleTree);

    Style.BodyPar {
      "A phylogeny is an information-rich graph.";
      "For one, it contains information on the relationships of the languages.";
      "This topological information is denoted {0}"(sym.tau);
    };

    Style.BodyPar {
      "Substitution of one segment for another is modeled using a continuous-time Markov model in which the possible states are the set of segments in the phonemic representations.";
      "At the heart of a continuous-time Markov chain is a rate matrix describing the rate of change between all pairs ofstates.";
      "As an example, consider a simplified Markov process with only five segments as states.";
      "The rates of change between the pairs of states can be represented in table form as";
    };

    BodyPar {
      "We use ancestral classes, in which the descendant forms are segmentally aligned.";
      "It is important to note that our definition of cognate refers only to segmental descent.";
      "It takes no account of semantics whatsoever.";
      "So the lexical items for 'ear' in Romance are paired with the Latin word " Word("auricula")
      " which is the diminute form of 'ear'.";
    };
    Style.BodyPar {
      "Other things we have to mention: "
    };
    Style.NumberList {
      "The data are surface forms, not underlying forms.";
      "We used the accusative singular for nouns in Latin.";
    };


    Style.FigureBody {
      StateSection.StateTable;
    };

    Style.EquationPar {
      sym.Q;
      Equals;
      InBraces {qij};
      Equals;
      StateSection.StateMatrix;
      Space;
      sym.Beta;
    };

    Style.EquationPar {
      InDelDistribution;
    };
  };
}
//======================================================================

with Content.Conclusion {
  Title = Lang.Conclusion;
  Body  = Block {
    Paragraph {
      "Vene Vidi Vici";
    };
  };
}
//======================================================================

