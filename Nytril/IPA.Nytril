using Format, Units, Type, IPA.SoundTypes
//======================================================================

with IPA
  with Opens
    let Close     = enum {Name: Lang.Close}
    let NearClose = enum {Name: Lang.NearClose}
    let CloseMid  = enum {Name: Lang.CloseMid}
    let Mid       = enum {Name: Lang.Mid}
    let OpenMid   = enum {Name: Lang.OpenMid}
    let NearOpen  = enum {Name: Lang.NearOpen}
    let Open      = enum {Name: Lang.Open}
  end

  with Backnesses
    let Front     = enum {Name: Lang.Front}
    let NearFront = enum {Name: Lang.NearFront}
    let Central   = enum {Name: Lang.Central}
    let NearBack  = enum {Name: Lang.NearBack}
    let Back      = enum {Name: Lang.Back}
  end

  with Places
    let Bilabial       = enum {Name: Lang.Bilabial}
    let Labial         = enum {Name: Lang.Labial}
    let LabialVelar    = enum {Name: Lang.LabialVelar}
    let LabialPalatal  = enum {Name: Lang.LabialPalatal}
    let LabioDental    = enum {Name: Lang.LabioDental}
    let LinguoLabial   = enum {Name: Lang.LinguoLabial}
    let Dental         = enum {Name: Lang.Dental}
    let Alveolar       = enum {Name: Lang.Alveolar}
    let AlveoloPalatal = enum {Name: Lang.AlveoloPalatal}
    let PostAlveolar   = enum {Name: Lang.PostAlveolar}
    let Retroflex      = enum {Name: Lang.Retroflex}
    let Palatal        = enum {Name: Lang.Palatal}
    let PalatoAlveolar = enum {Name: Lang.PalatoAlveolar}
    let Velar          = enum {Name: Lang.Velar}
    let Uvular         = enum {Name: Lang.Uvular}
    let Pharyngeal     = enum {Name: Lang.Pharyngeal}
    let Glottal        = enum {Name: Lang.Glottal}
  end

  with SoundTypes
    let None        = flag
    let Voiced      = flag {Name: Lang.Voiced}
    let Rounded     = flag {Name: Lang.Rounded}
    let Velarized   = flag {Name: Lang.Velarized}
    let Ejective    = flag {Name: Lang.Ejective}
    let Pulmonic    = flag {Name: Lang.Pulmonic}
    let Nasal       = flag {Name: Lang.Nasal}
    let Tenuis      = flag {Name: Lang.Tenuis}
    let Lateral     = flag {Name: Lang.Lateral}
    let Sibilant    = flag {Name: Lang.Sibilant}
    let Fricative   = flag {Name: Lang.Fricative}
    let Approximant = flag {Name: Lang.Approximant}
    let Plosive     = flag {Name: Lang.Plosive}
    let Implosive   = flag {Name: Lang.Implosive}
    let Central     = flag {Name: Lang.Central}
    let TapFlap     = flag {Name: Lang.TapFlap}
    let Trill       = flag {Name: Lang.Trill}
    let Stop        = flag {Name: Lang.Stop}
    let Click       = flag {Name: Lang.Click}
    let Affricate   = flag {Name: Lang.Affricate}
    let Vowel       = flag {Name: Lang.Vowel}
    let Rhotic      = flag {Name: Lang.Rhotic}
    let Impossible  = flag {Name: Lang.Impossible}
    let NonIPA      = flag {Name: Lang.NonIPA}
    let Diacritic   = flag {Name: Lang.Diacritic}

//    let Consonant   = mask {Name: Lang.Consonant}
  end

  let Unrounded = SoundTypes.None

  let Encode(text, sampa) = {
    Popup: SoundPopup,
    Text: text,
    Sampa: sampa,
  }

  let Diac(description, text, sampa) = Encode(text, sampa) {
    Flags: Diacritic,
    Description: description,
  }

  let Con(flags, place, text, sampa) = Encode(text, sampa) {
    Flags: flags,
    Place: place,
  }

  let Vow(flags, open, backness, text, sampa) = Encode(text, sampa) {
    Flags: flags | Vowel,
    Open: open,
    Backness: backness,
  }

  let NPEjective(flags, sound) = Con(Ejective | flags, sound.Place, sound.Text DiacriticSounds.Ejective.Text, sound.Sampa DiacriticSounds.Ejective.Sampa)

  let Imp(flags, place) = {
    Flags: flags | Impossible,
    Place: place,
  }

  let Dia(text, sampa) = Encode(text, sampa) {
    Flags: Diacritic
  }

  with Sounds
    //==================================
    // Extra sounds found in word list
    //==================================

    let VdNasalizedLabialVelarApproximant = Con(Voiced Approximant Nasal, Places.LabialVelar, "w\u0303", "w_~")
    let NasalizedCloseFrontRounded        = Vow(Rounded Nasal, Opens.Close, Backnesses.Front, "y\u0303", "y_~")
    let VdNasalizedUvularFricative        = Con(Voiced Pulmonic Fricative, Places.Uvular, "r\u0303", "r_~")

    let r_twiddle                         = Con(Voiced Pulmonic Fricative, Places.Uvular, "ʁ", "r_~")  // French Cold "Froid"  Same as SAMPA "R"?

    let A_star                            = Vow(Nasal Rounded, Opens.NearOpen, Backnesses.Central, "ɐ\u0303", "a*")   // Supposed to be "ɛ̃" as in French Dog "chien"?
    let O_star                            = Vow(Nasal Rounded, Opens.OpenMid, Backnesses.Back, "ɔ̃", "o*")             // French Fish "poisson"
    let OE_star                           = Vow(Nasal Rounded, Opens.OpenMid, Backnesses.NearFront, "œ\u0303", "oe*") // French One "un"

    let U_star                            = Vow(Nasal Rounded, Opens.Close, Backnesses.Back, "u\u0303", "u*")         // Portuguese One "um"
    let e_star                            = Vow(Nasal Unrounded, Opens.CloseMid, Backnesses.Front, "e\u0303", "e*")   // Portuguese Trail "se*da
    let i_star                            = Vow(Nasal Unrounded, Opens.Close, Backnesses.Front, "i\u0303", "i*")      // Portuguese Tongue

    let e3_star                           = Vow(Nasal Unrounded, Opens.OpenMid, Backnesses.NearFront, "ɛ\u0303", "3*")   // SAMPA "E"?

    let E_star                            = Vow(Nasal Unrounded, Opens.OpenMid, Backnesses.NearFront, "ɛ\u0303", "E*")   // Walloon One, Don't know how this is different from above


    let Space                             = Diac("Space", " ", " ")


    //==================================
    // Pulmonic Consonants
    //==================================

    // Nasal					
    let VlBilabialNasal              = Con(Pulmonic Nasal, Places.Bilabial, "m̥", "m_0")
    let VdBilabialNasal              = Con(Voiced Pulmonic Nasal, Places.Bilabial, "m", "m")
    let VdLabioDentalNasal           = Con(Voiced Pulmonic Nasal, Places.LabioDental, "ɱ", "F")
    let VdLinguoLabioNasal           = Con(Voiced Pulmonic Nasal, Places.LinguoLabial, "n̼", "m_d")
    let VlAlveolarNasal              = Con(Pulmonic Nasal, Places.Alveolar, "n̥", "n_0")
    let VdAlveolarNasal              = Con(Voiced Pulmonic Nasal, Places.Alveolar, "n", "n")
    let VlRetroFlexNasal             = Con(Pulmonic Nasal, Places.Retroflex, "ɳ̊", "n`_0")
    let VdRetroFlexNasal             = Con(Voiced Pulmonic Nasal, Places.Retroflex, "ɳ", "n`")
    let VlPalatalNasal               = Con(Pulmonic Nasal, Places.Palatal, "ɲ̊", "J_0")
    let VdPalatalNasal               = Con(Voiced Pulmonic Nasal, Places.Palatal, "ɲ", "J")
    let VlVelarNasal                 = Con(Pulmonic Nasal, Places.Velar, "ŋ̊", "N_0")
    let VdVelarNasal                 = Con(Voiced Pulmonic Nasal, Places.Velar, "ŋ", "N")
    let VdUvularNasal                = Con(Voiced Pulmonic Nasal, Places.Uvular, "ɴ", "N\\")
														
    // Stop
    let VlBilabialStop               = Con(Pulmonic Stop, Places.Bilabial, "p", "p")
    let VdBilabialStop               = Con(Voiced Pulmonic Stop, Places.Bilabial, "b", "b")
    let VlLabioDentalStop            = Con(Pulmonic Stop, Places.LabioDental, "p̪", "p_d")
    let VdLabioDentalStop            = Con(Voiced Pulmonic Stop, Places.LabioDental, "b̪", "b_d")
    let VlLinguoLabialStop           = Con(Pulmonic Stop, Places.LinguoLabial, "t̼", "")
    let VdLinguoLabialStop           = Con(Voiced Pulmonic Stop, Places.LinguoLabial, "d̼", "")
    let VlAlveolarStop               = Con(Pulmonic Stop, Places.Alveolar, "t", "t")
    let VdAlveolarStop               = Con(Voiced Pulmonic Stop, Places.Alveolar, "d", "d")
    let VlRetroflexStop              = Con(Pulmonic Stop, Places.Retroflex, "ʈ", "t`")
    let VdRetroflexStop              = Con(Voiced Pulmonic Stop, Places.Retroflex, "ɖ", "d`")
    let VlPalatalStop                = Con(Pulmonic Stop, Places.Palatal, "c", "c")
    let VdPalatalStop                = Con(Voiced Pulmonic Stop, Places.Palatal, "ɟ", "J\\")
    let VlVelarStop                  = Con(Pulmonic Stop, Places.Velar, "k", "k")
    let VdVelarStop                  = Con(Voiced Pulmonic Stop, Places.Velar, "ɡ", "g")
    let VlUvularStop                 = Con(Pulmonic Stop, Places.Uvular, "q", "q")
    let VdUvularStop                 = Con(Voiced Pulmonic Stop, Places.Uvular, "ɢ", "G\\")
    let VdEpiglottalStop             = Con(Pulmonic Stop, Places.Pharyngeal, "ʡ", ">\\")
    let GlottalStop                  = Con(Pulmonic Stop, Places.Glottal, "ʔ", "?")
		
    // Sibilant Fricative										
    let VlAlveolarSibFricative       = Con(Pulmonic Sibilant Fricative, Places.Alveolar, "s", "s")
    let VdAlveolarSibFricative       = Con(Voiced Pulmonic Sibilant Fricative, Places.Alveolar, "z", "z")
    let VlPostalveolarSibFricative   = Con(Pulmonic Sibilant Fricative, Places.PostAlveolar, "ʃ", "S")
    let VdPostalveolarSibFricative   = Con(Voiced Pulmonic Sibilant Fricative, Places.PostAlveolar, "ʒ", "Z")
    let VlRetroflexSibFricative      = Con(Pulmonic Sibilant Fricative, Places.Retroflex, "ʂ", "s`")
    let VdRetroflexSibFricative      = Con(Voiced Pulmonic Sibilant Fricative, Places.Retroflex, "ʐ", "z`")
    let VlPalatalSibFricative        = Con(Pulmonic Sibilant Fricative, Places.Palatal, "ɕ", "s\\")
    let VdPalatalSibFricative        = Con(Voiced Pulmonic Sibilant Fricative, Places.Palatal, "ʑ", "z\\")

    // Fricative										
    let VlBilabialFricative          = Con(Pulmonic Fricative, Places.Bilabial, "ɸ", "p\\")
    let VdBilabialFricative          = Con(Voiced Pulmonic|  Fricative, Places.Bilabial, "β", "B")
    let VlLabiodentalFricative       = Con(Pulmonic Fricative, Places.LabioDental, "f", "f")
    let VdLabiodentalFricative       = Con(Voiced Pulmonic Fricative, Places.LabioDental, "v", "v")
    let VlLinguoLabialFricative      = Con(Pulmonic Fricative, Places.LinguoLabial, "θ̼", "")
    let VdLinguoLabialFricative      = Con(Voiced Pulmonic Fricative, Places.LinguoLabial, "ð̼", "")
    let VlDentalFricative            = Con(Pulmonic Fricative, Places.Dental, "θ", "T")
    let VdDentalFricative            = Con(Voiced Pulmonic Fricative, Places.Dental, "ð", "D")
    let VlAlveolarFricative          = Con(Pulmonic Fricative, Places.Alveolar, "θ̠", "")
    let VdAlveolarFricative          = Con(Voiced Pulmonic Fricative, Places.Alveolar, "ð̠", "")
    let VlPostaveolarFricative       = Con(Pulmonic Fricative, Places.PostAlveolar, "ɹ̠̊", "")
    let VdPostalveolarFricative      = Con(Voiced Pulmonic Fricative, Places.PostAlveolar, "ɹ̝̊", "")
    let VdRetroflexFricative         = Con(Voiced Pulmonic Fricative, Places.Retroflex, "ɻ˔","")
    let VlPalatalFricative           = Con(Pulmonic Fricative, Places.Palatal, "ç", "C")
    let VdPalatalFricative           = Con(Voiced Pulmonic Fricative, Places.Palatal, "ʝ", "j\\")
    let VlVelarFricative             = Con(Pulmonic Fricative, Places.Velar, "x", "x")
    let VdVelarFricative             = Con(Voiced Pulmonic Fricative, Places.Velar, "ɣ", "G")
    let VlUvularFricative            = Con(Pulmonic Fricative, Places.Uvular, "χ", "X")
    let VdUvularFricative            = Con(Voiced Pulmonic Fricative, Places.Uvular, "ʁ", "R")
    let VlPharyngealFricative        = Con(Pulmonic Fricative, Places.Pharyngeal, "ħ", "X\\")
    let VdPharyngealFricative        = Con(Voiced Pulmonic Fricative, Places.Pharyngeal, "ʕ", "?\\")
    let VlGlottalFricative           = Con(Pulmonic Fricative, Places.Glottal, "h", "h")
    let VdGlottalFricative           = Con(Voiced Pulmonic Fricative, Places.Glottal, "ɦ", "h\\")
														
    // Approximant										
    let VlLabioDentalApproximant     = Con(Pulmonic Approximant, Places.LabioDental, "ʋ̥", "")
    let VdLabioDentalApproximant     = Con(Voiced Pulmonic Approximant, Places.LabioDental, "ʋ", "v\\")
    let VlPostalveolarApproximant    = Con(Pulmonic Approximant, Places.Alveolar, "ɹ̥", "")
    let VdPostalveolarApproximant    = Con(Voiced Pulmonic Approximant, Places.Alveolar, "ɹ", "r\\")
    let VlRetroflexApproximant       = Con(Pulmonic Approximant, Places.Retroflex, "ɻ̊", "")
    let VdRetroflexApproximant       = Con(Voiced Pulmonic Approximant, Places.Retroflex, "ɻ", "r\\`")
    let VlPalatalApproximant         = Con(Pulmonic Approximant, Places.Palatal, "j̊", "")
    let VdPalatalApproximant         = Con(Voiced Pulmonic Approximant, Places.Palatal, "j", "j")
    let VlVelarApproximant           = Con(Pulmonic Approximant, Places.Velar, "ɰ̊", "")
    let VdVelarApproximant           = Con(Voiced Pulmonic Approximant, Places.Velar, "ɰ", "M\\")
    let VdGlottalApproximant         = Con(Voiced Pulmonic Approximant, Places.Glottal, "ʔ̞", "")
														
    // Tap or Flap										
    let VdBilabialDentalFlap         = Con(Voiced Pulmonic TapFlap, Places.Bilabial, "ⱱ̟", "")
    let VdLabioDentalFlap            = Con(Voiced Pulmonic TapFlap, Places.LabioDental, "ⱱ", "")
    let VdLingualLabialStop          = Con(Voiced Pulmonic TapFlap, Places.LinguoLabial, "ɾ̼", "")
    let VlAlveolarFlap               = Con(Pulmonic TapFlap, Places.Alveolar, "ɾ̥", "")
    let VdAlveolarTap                = Con(Voiced Pulmonic TapFlap, Places.Alveolar, "ɾ", "4")
    let VlRetroflexFlap              = Con(Pulmonic TapFlap, Places.Retroflex, "ɽ̊", "")
    let VdRetroflexFlap              = Con(Voiced Pulmonic TapFlap, Places.Retroflex, "ɽ", "r`")
    let VdUvularFlap                 = Con(Voiced Pulmonic TapFlap, Places.Uvular, "ɢ̆", "")
    let VdPharyngealFlap             = Con(Voiced Pulmonic TapFlap, Places.Pharyngeal, "ʡ̆", "")
														
    // Trill											
    let VlBilabialTrill              = Con(Pulmonic Trill, Places.Bilabial, "ʙ̥", "")
    let VdBilabialTrill              = Con(Voiced Pulmonic Trill, Places.Bilabial, "ʙ", "B\\")
    let VlAlveolarTrill              = Con(Pulmonic Trill, Places.Alveolar, "r̥", "")
    let VdAlveolarTrill              = Con(Voiced Pulmonic Trill, Places.Alveolar, "r", "r")
    let VlRetroflexTrill             = Con(Pulmonic Trill, Places.Retroflex, "ɽ̊r̥", "")
    let VdRetroflexTrill             = Con(Voiced Pulmonic Trill, Places.Retroflex, "ɽr", "")
    let VlUvularTrill                = Con(Pulmonic Trill, Places.Uvular, "ʀ", "R\\")
    let VlPharyngealTrill            = Con(Pulmonic Trill, Places.Pharyngeal, "H", "")
    let VdPharyngealTrill            = Con(Voiced Pulmonic Trill, Places.Pharyngeal, "ʢ", "<\\")
														
    // Lateral Fricative								
    let VlAlveolarLateralFricative   = Con(Pulmonic Lateral Fricative, Places.Alveolar, "ɬ", "K")
    let VdAlveolarLateralFricative   = Con(Voiced Pulmonic Lateral Fricative, Places.Alveolar, "ɮ", "K\\")
    let VlRetroflexLateralFricative  = Con(Pulmonic Lateral Fricative, Places.Retroflex, "ɭ̊˔", "")
    let VdRetroflexLateralFricative  = Con(Voiced Pulmonic Lateral Fricative, Places.Retroflex, "ɭ˔", "")
    let VlAlveolarPalatalFricative   = Con(Pulmonic Lateral Fricative, Places.Palatal, "ʎ̝̊", "")
    let VdAlveolarPalatalFricative   = Con(Voiced Pulmonic Lateral Fricative, Places.Palatal, "ʎ̝", "")
    let VlVelarPalatalFricative      = Con(Pulmonic Lateral Fricative, Places.Velar, "ʟ̝̊", "")
    let VdVelarPalatalFricative      = Con(Voiced Pulmonic Lateral Fricative, Places.Velar, "ʟ̝", "")
														
    // LateralApproximant								
    let VlAlveolarLateralApproximant = Con(Pulmonic Lateral Approximant, Places.Alveolar, "l̥", "")
    let VdAlveolarLateralApproximant = Con(Voiced Pulmonic Lateral Approximant, Places.Alveolar, "l", "l")
    let VdVelarizedAlvLatApproximant = Con(Voiced Velarized Pulmonic Lateral Approximant, Places.Alveolar, "ɫ", "5")
    let VlRetroflexLateral           = Con(Pulmonic Lateral Approximant, Places.Retroflex, "ɭ̊", "")
    let VdRetroflexLateral           = Con(Voiced Pulmonic Lateral Approximant, Places.Retroflex, "ɭ", "n`")
    let VlPalatalLateral             = Con(Pulmonic Lateral Approximant, Places.Palatal, "ʎ̥", "")
    let VdPalatalLateral             = Con(Voiced Pulmonic Lateral Approximant, Places.Palatal, "ʎ", "L")
    let VlVelarLateral               = Con(Pulmonic Lateral Approximant, Places.Velar, "ʟ̥", "")
    let VdVelarLateral               = Con(Voiced Pulmonic Lateral Approximant, Places.Velar, "ʟ", "L\\")
    let VdUvularLateral              = Con(Voiced Pulmonic Lateral Approximant, Places.Uvular, "ʟ̠", "")

    // Lateral tap/flap
    let VdAlveolarLateralFlap        = Con(Voiced Pulmonic Lateral TapFlap, Places.Alveolar, "ɺ", "l\\")
    let VdRetroflexLateralFlap       = Con(Voiced Pulmonic Lateral TapFlap, Places.Retroflex, "ɭ̆", "")
    let VdPalatalLateralFlap         = Con(Voiced Pulmonic Lateral TapFlap, Places.Palatal, "ʎ̆", "")
    let VdVelarLateralTap            = Con(Voiced Pulmonic Lateral TapFlap, Places.Velar, "L̆", "")


    //==================================
    // Non-Pulmonic Consonants
    //==================================

    // Clicks
    let VlBilabialTenuisClick        = Con(Ejective Tenuis Click Affricate, Places.Bilabial, "ʘ", "O\\")
    let VdBilabialTenuisClick        = Con(Voiced Ejective Tenuis Click Affricate, Places.Bilabial, "ʘ̬", "")
    let VlDentalTenuisClick          = Con(Ejective Tenuis Click Affricate, Places.Dental, "ǀ", "|")
    let VdDentalTenuisClick          = Con(Voiced Ejective Tenuis Click Affricate, Places.Dental, "ǀ̬", "")
    let VlAlveolarTenuisClick        = Con(Ejective Tenuis Click Affricate, Places.Alveolar, "ǃ", "!\\")
    let VdAlveolarTenuisClick        = Con(Voiced Ejective Tenuis Click Affricate, Places.Alveolar, "ǃ̬", "")
    let VlPalatalTenuisClick         = Con(Ejective Tenuis Click Affricate, Places.Palatal, "ǂ", "=\\")
    let VdPalatalTenuisClick         = Con(Voiced Ejective Tenuis Click Affricate, Places.Palatal, "ǂ̬", "")

    let VlBilabialNasalClick         = Con(Ejective Nasal Click Affricate, Places.Bilabial, "ʘ̃", "")
    let VlDentalNasalClick           = Con(Ejective Nasal Click Affricate, Places.Dental, "ǀ̃", "")
    let VlAlveolarNasalClick         = Con(Ejective Nasal Click Affricate, Places.Alveolar, "ǃ̃", "")
    let VlPalatalNasalClick          = Con(Ejective Nasal Click Affricate, Places.Palatal, "ǂ̃", "")

    let VlAlveolarTenuisLateralClick = Con(Ejective Tenuis Lateral Click Affricate, Places.Alveolar, "ǁ", " | \\ | \\")
    let VdAlveolarTenuisLateralClick = Con(Voiced Ejective Tenuis Lateral Click Affricate, Places.Alveolar, "ǁ̬", "")

    let VlBilabialImplosiveClick     = Con(Ejective Implosive Click Affricate, Places.Bilabial, "ɓ̥", "")
    let VdBilabialImplosiveClick     = Con(Voiced Ejective Implosive Click Affricate, Places.Bilabial, "ɓ", "b_<")
    let VlAlveolarImplosiveClick     = Con(Ejective Implosive Click Affricate, Places.Alveolar, "ɗ̥", "")
    let VdAlveolarImplosiveClick     = Con(Voiced Ejective Implosive Click Affricate, Places.Alveolar, "ɗ", "d_<")
    let VlRetroflexImplosiveClick    = Con(Ejective Implosive Click Affricate, Places.Retroflex, "ᶑ̊", "")
    let VdRetroflexImplosiveClick    = Con(Voiced Ejective Implosive Click Affricate, Places.Retroflex, "ᶑ", "")
    let VlPalatalImplosiveClick      = Con(Ejective Implosive Click Affricate, Places.Palatal, "ʄ̊", "")
    let VdPalatalImplosiveClick      = Con(Voiced Ejective Implosive Click Affricate, Places.Palatal, "ʄ", "J\\_<")
    let VlVelarImplosiveClick        = Con(Ejective Implosive Click Affricate, Places.Velar, "ɠ̊", "")
    let VdVelarImplosiveClick        = Con(Voiced Ejective Implosive Click Affricate, Places.Velar, "ɠ", "g_<")
    let VlUvularImplosiveClick       = Con(Ejective Implosive Click Affricate, Places.Uvular, "ʛ̥", "")
    let VdUvularImplosiveClick       = Con(Voiced Ejective Implosive Click Affricate, Places.Uvular, "ʛ", "G\\_<")

    //==================================
    // Pulmonic Affricates
    //==================================

    // Sibilants
    let VlAlveolarAffricate          = Con(Pulmonic Sibilant Affricate, Places.Alveolar, "ts", "")
    let VdAlveolarAffricate          = Con(Voiced Pulmonic Sibilant Affricate, Places.Alveolar, "dz", "")
    let VlPostalveolarAffricate      = Con(Pulmonic Sibilant Affricate, Places.PalatoAlveolar, "t̠ʃ", "")
    let VdPostalveolarAffricate      = Con(Voiced Pulmonic Sibilant Affricate, Places.PalatoAlveolar, "d̠ʒ", "")
    let VlRetroflexAffricate         = Con(Pulmonic Sibilant Affricate, Places.Retroflex, "ʈʂ", "")
    let VdRetroflexAffricate         = Con(Voiced Pulmonic Sibilant Affricate, Places.Retroflex, "ɖʐ", "")
    let VlAlveoloPalatalAffricate    = Con(Pulmonic Sibilant Affricate, Places.AlveoloPalatal, "tɕ", "")
    let VdAlveoloPalatalAffricate    = Con(Voiced Pulmonic Sibilant Affricate, Places.AlveoloPalatal, "dʑ", "")

    // Non-Sibilants
    let VlBilabialNSAffricate        = Con(Pulmonic Affricate, Places.Bilabial, "pɸ", "")
    let VdBilabialNSAffricate        = Con(Voiced Pulmonic Affricate, Places.Bilabial, "bβ", "")
    let VlLabioDentalNSAffricate     = Con(Pulmonic Affricate, Places.LabioDental, "p̪f", "")
    let VdLabioDentalNSAffricate     = Con(Voiced Pulmonic Affricate, Places.LabioDental, "b̪v", "")
    let VlDentalNSAffricate          = Con(Pulmonic Affricate, Places.Dental, "t̪θ", "")
    let VdDentalNSAffricate          = Con(Voiced Pulmonic Affricate, Places.Dental, "d̪ð", "")
    let VlAlveolarNSAffricate        = Con(Pulmonic Affricate, Places.Alveolar, "tɹ̝̊", "")
    let VdAlveolarNSAffricate        = Con(Voiced Pulmonic Affricate, Places.Alveolar, "dɹ̝", "")
    let VlPalatoAlveolarNSAffricate  = Con(Pulmonic Affricate, Places.PalatoAlveolar, "t̠ɹ̠̊˔", "")
    let VdPalatoAlveolarNSAffricate  = Con(Voiced Pulmonic Affricate, Places.PalatoAlveolar, "d̠ɹ̠˔", "")
    let VlPalatalNSAffricate         = Con(Pulmonic Affricate, Places.Palatal, "cç", "")
    let VdPalatalNSAffricate         = Con(Voiced Pulmonic Affricate, Places.Palatal, "ɟʝ", "")
    let VlVelarNSAffricate           = Con(Pulmonic Affricate, Places.Velar, "kx", "")
    let VdVelarNSAffricate           = Con(Voiced Pulmonic Affricate, Places.Velar, "ɡɣ", "")
    let VlUvularNSAffricate          = Con(Pulmonic Affricate, Places.Uvular, "qχ", "")
    let VdEpiglottalNSAffricate      = Con(Voiced Pulmonic Affricate, Places.Pharyngeal, "ʡʢ", "")
    let VlGlottalNSAffricate         = Con(Pulmonic Affricate, Places.Glottal, "ʔh", "")

    // Lateral
    let VlAlveolarLateralAffricate   = Con(Pulmonic Lateral Affricate, Places.Alveolar, "tɬ̝̊", "")
    let VdAlveolarLateralAffricate   = Con(Voiced Pulmonic Lateral Affricate, Places.Alveolar, "dɮ", "")
    let VlRetroflexLateralAffricate  = Con(Pulmonic Lateral Affricate, Places.Retroflex, "ʈɭ̊˔", "")
    let VdPalatalLateralAffricate    = Con(Voiced Pulmonic Lateral Affricate, Places.Palatal, "cʎ̝̊", "")
    let VlVelarLateralAffricate      = Con(Pulmonic Lateral Affricate, Places.Velar, "kʟ̝̊", "")
    let VdVelarLateralAffricate      = Con(Voiced Pulmonic Lateral Affricate, Places.Velar, "ɡʟ̝", "")

    //==================================
    // Ejective | Affricates
    //==================================

    // Central
    let VlAlveolarEjectiveAffricate       = Con(Ejective Central Affricate, Places.Alveolar, "tsʼ", "")
    let VlPalatoAlveolarEjectiveAffricate = Con(Ejective Central Affricate, Places.PalatoAlveolar, "t̠ʃʼ", "")
    let VlRetroflexEjectiveAffricate      = Con(Ejective Central Affricate, Places.Retroflex, "ʈʂʼ", "")
    let VlVelarEjectiveAffricate          = Con(Ejective Central Affricate, Places.Velar, "kxʼ", "")
    let VlUvularEjectiveAffricate         = Con(Ejective Central Affricate, Places.Uvular, "qχʼ", "")

    // Lateral
    let VlAlveolarLateralEjective         = Con(Ejective Lateral Affricate, Places.Alveolar, "tɬʼ", "")
    let VlPalatalLateralEjective          = Con(Ejective Lateral Affricate, Places.Palatal, "cʎ̝̊ʼ", "")
    let VlVelarLateralEjective            = Con(Ejective Lateral Affricate, Places.Velar, "kʟ̝̊ʼ", "")

    let VlLabialVelarFricative            = Con(Fricative, Places.LabialVelar, "ʍ", "W")

// Pre-existing
//    let VlAlveoloPalatalFricative1      = NewConsonant(CPM(Categories.Other, Places.AlveoloPalatal) Fricative, "ɕ", "")
//    let VlAlveoloPalatalFricative       = NewConsonant(CPM(Categories.Other, Places.AlveoloPalatal) Fricative, "ʑ", "")


    let VdLabialVelarApproximant          = Con(Voiced Approximant, Places.LabialVelar, "w", "w")



    let VlEpiglottalFricative             = Con(Fricative, Places.Pharyngeal, "ʜ", "H\\")
    let VdLabialPalatalApproximant        = Con(Voiced Approximant, Places.LabialPalatal, "ɥ", "H")

    let SimultaneousSx                    = Con(Sibilant Fricative, Places.PostAlveolar, "ɧ", "x\\")
    let VdEpiglottalFricative             = Con(Voiced Fricative, Places.Pharyngeal, "ʢ", "?\\")
    let VlEpiglottalPlosive               = Con(Plosive, Places.Pharyngeal, "ʡ", "<\\")

    // Ejectives
    let VlBilabialStopEjective            = NPEjective(Stop, VlBilabialStop)
    let VlAveolarStopEjective             = NPEjective(Stop, VlAlveolarStop)
    let VlRetroflexStopEjective           = NPEjective(Stop, VlRetroflexStop)
    let VlPalatalStopEjective             = NPEjective(Stop, VlPalatalStop)
    let VlVelarStopEjective               = NPEjective(Stop, VlVelarStop)
    let VlUvularStopEjective              = NPEjective(Stop, VlUvularStop)
    let VlEpiglottalStopEjective          = NPEjective(Stop, VdEpiglottalStop)
    let VlBilabialFricativeEjective       = NPEjective(Fricative, VlBilabialFricative)
    let VlLabiodentalFricativeEjective    = NPEjective(Fricative, VlLabiodentalFricative)
    let VlDentalFricativeEjective         = NPEjective(Fricative, VlDentalFricative)
    let VlAlveolarFricativeEjective       = NPEjective(Fricative, VlAlveolarSibFricative)
    let VlPostalveolarFricativeEjective   = NPEjective(Fricative, VlPostalveolarSibFricative)
    let VlRetroflexFricativeEjective      = NPEjective(Fricative, VlRetroflexSibFricative)
    let VlPalatalFricativeEjective        = NPEjective(Fricative, VlPalatalSibFricative)
    let VlVelarFricativeEjective          = NPEjective(Fricative, VlVelarFricative)
    let VlUvularFricativeEjective         = NPEjective(Fricative, VlUvularFricative)

    // Lateral Fricatives
    let VlPostalveolarLatFricEjective    = NPEjective(Lateral | Fricative, VlAlveolarLateralFricative)

    //==================================
    // Vowels
    //==================================

    let CloseFrontUnrounded          = Vow(Unrounded, Opens.Close, Backnesses.Front, "i", "i")


    let CloseFrontRounded            = Vow(Rounded, Opens.Close, Backnesses.Front, "y", "y")


    let CloseCentralUnrounded        = Vow(Unrounded, Opens.Close, Backnesses.Central, "ɨ", "1")
    let CloseCentralRounded          = Vow(Rounded, Opens.Close, Backnesses.Central, "ʉ", "}")
    let CloseBackUnrounded           = Vow(Unrounded, Opens.Close, Backnesses.Back, "ɯ", "M")
    let CloseBackRounded             = Vow(Rounded, Opens.Close, Backnesses.Back, "u", "u")

    let NearCloseCentralUnrounded    = Vow(Unrounded | NonIPA, Opens.NearClose, Backnesses.Central, "ᵻ", "I\\")
    let NearCloseFrontUnrounded      = Vow(Unrounded, Opens.NearClose, Backnesses.NearFront, "ɪ", "I")
    let NearCloseFrontRounded        = Vow(Rounded, Opens.NearClose, Backnesses.NearFront, "ʏ", "Y")
    let NearCloseCentralRounded      = Vow(Rounded |NonIPA, Opens.NearClose, Backnesses.Central, "ᵿ", "U\\")
    let NearCloseBackRounded         = Vow(Rounded, Opens.NearClose, Backnesses.NearBack, "ʊ", "U")

    let CloseMidFrontUnrounded       = Vow(Unrounded, Opens.CloseMid, Backnesses.Front, "e", "e")
    let CloseMidFrontRounded         = Vow(Rounded, Opens.CloseMid, Backnesses.Front, "ø", "2")
    let MidCentralUnrounded          = Vow(Unrounded, Opens.Mid, Backnesses.Central, "ɘ", "@\\")
    let Schwa                        = Vow(Unrounded, Opens.CloseMid, Backnesses.Central, "ə", "@")
    let RoundedSchwa                 = Vow(Rounded, Opens.CloseMid, Backnesses.Central, "ɵ", "8")
    let CloseMidBackUnrounded        = Vow(Unrounded, Opens.CloseMid, Backnesses.Back, "ɤ", "7")
    let CloseMidBackRounded          = Vow(Rounded, Opens.CloseMid, Backnesses.Back, "o", "o")

    let MidFrontUnrounded            = Vow(Unrounded, Opens.Mid, Backnesses.Front, "ø̞", "")
    let MidBackUnrounded             = Vow(Unrounded, Opens.Mid, Backnesses.Back, "o̞", "")

    let OpenMidNearFrontUnrounded    = Vow(Unrounded, Opens.OpenMid, Backnesses.NearFront, "ɛ", "E")
    let OpenMidNearFrontRounded      = Vow(Rounded, Opens.OpenMid, Backnesses.NearFront, "œ", "9")
    let OpenMidCentralRounded        = Vow(Rounded, Opens.OpenMid, Backnesses.Central, "ɞ", "3\\")
    let OpenMidCentral               = Vow(Unrounded, Opens.OpenMid, Backnesses.Central, "ɜ", "3")
    let OpenMidBackUnrounded         = Vow(Unrounded, Opens.OpenMid, Backnesses.Back, "ʌ", "V")
    let OpenMidBackRounded           = Vow(Rounded, Opens.OpenMid, Backnesses.Back, "ɔ", "O")

    let NearFrontUnrounded           = Vow(Unrounded, Opens.NearOpen, Backnesses.NearFront, "æ", "{")
    let FrontOpenRounded             = Vow(Rounded, Opens.NearOpen, Backnesses.NearFront, "ɶ", "&")
    let OpenMidSchwa                 = Vow(Rounded, Opens.NearOpen, Backnesses.Central, "ɐ", "6")

    let OpenCentralUnrounded         = Vow(Unrounded, Opens.Open, Backnesses.Central, "ä", "a_\"")
    let OpenNearFrontUnrounded       = Vow(Unrounded, Opens.Open, Backnesses.NearFront, "a", "a")
    let OpenNearFrontRounded         = Vow(Rounded, Opens.Open, Backnesses.NearFront, "ɶ", "&")
    let OpenBackUnrounded            = Vow(Unrounded, Opens.Open, Backnesses.Back, "ɑ", "A")
    let OpenBackRounded              = Vow(Rounded, Opens.Open, Backnesses.Back, "ɒ", "Q")

// How to show rhotic vowels?
//    let OpenMidCentralRhotic       = Vow(Rhotic, Opens.OpenMid, Backnesses.Central, "ɝ", "")
//    let RhoticSchwa                = Vow(Rhotic, Opens.Open, Backnesses.NearFront, "ɚ", "@`")
  end

  with ImpossibleSounds
    let I10 = Imp(Pulmonic Nasal, Places.Pharyngeal)
    let I11 = Imp(Pulmonic Nasal, Places.Glottal)
    let I12 = Imp(Pulmonic Stop Voiced, Places.Pharyngeal)
    let I13 = Imp(Pulmonic Stop Voiced, Places.Glottal)
    let I14 = Imp(Pulmonic Sibilant Fricative, Places.Bilabial)
    let I15 = Imp(Pulmonic Sibilant Fricative, Places.LabioDental)
    let I16 = Imp(Pulmonic Sibilant Fricative, Places.LinguoLabial)
    let I17 = Imp(Pulmonic Sibilant Fricative, Places.Velar)
    let I18 = Imp(Pulmonic Sibilant Fricative, Places.Uvular)
    let I19 = Imp(Pulmonic Sibilant Fricative, Places.Pharyngeal)
    let I20 = Imp(Pulmonic Sibilant Fricative, Places.Glottal)
    let I21 = Imp(Pulmonic Trill, Places.Velar)
    let I22 = Imp(Pulmonic Trill, Places.Glottal)
    let I23 = Imp(Pulmonic TapFlap, Places.Velar)
    let I24 = Imp(Pulmonic TapFlap, Places.Glottal)
    let I25 = Imp(Pulmonic Lateral Fricative, Places.Bilabial)
    let I26 = Imp(Pulmonic Lateral Fricative, Places.LabioDental)
    let I27 = Imp(Pulmonic Lateral Fricative, Places.Pharyngeal)
    let I28 = Imp(Pulmonic Lateral Fricative, Places.Glottal)
    let I29 = Imp(Pulmonic Lateral Approximant, Places.Bilabial)
    let I30 = Imp(Pulmonic Lateral Approximant, Places.LabioDental)
    let I31 = Imp(Pulmonic Lateral Approximant, Places.Pharyngeal)
    let I32 = Imp(Pulmonic Lateral Approximant, Places.Glottal)
    let I33 = Imp(Pulmonic Lateral TapFlap, Places.Bilabial)
    let I34 = Imp(Pulmonic Lateral TapFlap, Places.LabioDental)
    let I35 = Imp(Pulmonic Lateral TapFlap, Places.Pharyngeal)
    let I36 = Imp(Pulmonic Lateral TapFlap, Places.Glottal)
    let I37 = Imp(Pulmonic Sibilant Affricate, Places.Bilabial)
    let I38 = Imp(Pulmonic Sibilant Affricate, Places.LabioDental)
    let I39 = Imp(Pulmonic Sibilant Affricate, Places.Velar)
    let I40 = Imp(Pulmonic Sibilant Affricate, Places.Uvular)
    let I41 = Imp(Pulmonic Sibilant Affricate, Places.Pharyngeal)
    let I42 = Imp(Pulmonic Sibilant Affricate, Places.Glottal)
    let I43 = Imp(Pulmonic Lateral Affricate, Places.Bilabial)
    let I44 = Imp(Pulmonic Lateral Affricate, Places.LabioDental)
    let I45 = Imp(Pulmonic Lateral Affricate, Places.Pharyngeal)
    let I46 = Imp(Pulmonic Lateral Affricate, Places.Glottal)
    let I47 = Imp(Ejective Lateral Fricative Affricate, Places.Bilabial)
    let I48 = Imp(Ejective Lateral Fricative Affricate, Places.LabioDental)
    let I49 = Imp(Ejective Lateral Fricative Affricate, Places.Pharyngeal)
    let I50 = Imp(Ejective Central Affricate, Places.Glottal)
    let I51 = Imp(Ejective Lateral Affricate, Places.Bilabial)
    let I52 = Imp(Ejective Lateral Affricate, Places.LabioDental)
    let I53 = Imp(Ejective Lateral Affricate, Places.Pharyngeal)
    let I54 = Imp(Ejective Lateral Affricate, Places.Glottal)
    let I55 = Imp(Ejective Tenuis Click Affricate, Places.Velar)
    let I56 = Imp(Ejective Tenuis Click Affricate, Places.Uvular)
    let I57 = Imp(Ejective Tenuis Click Affricate, Places.Pharyngeal)
    let I58 = Imp(Ejective Nasal Click Affricate, Places.Velar)
    let I59 = Imp(Ejective Nasal Click Affricate, Places.Uvular)
    let I60 = Imp(Ejective Nasal Click Affricate, Places.Pharyngeal)
    let I61 = Imp(Ejective Tenuis Lateral Click Affricate, Places.Bilabial)
    let I62 = Imp(Ejective Tenuis Lateral Click Affricate, Places.LabioDental)
    let I63 = Imp(Ejective Tenuis Lateral Click Affricate, Places.Velar)
    let I64 = Imp(Ejective Tenuis Lateral Click Affricate, Places.Uvular)
    let I65 = Imp(Ejective Tenuis Lateral Click Affricate, Places.Pharyngeal)
  end                       									

  let AllSounds = Sounds + ImpossibleSounds
  let NoSound   = Encode("?", "?") {Flags: Impossible}

  with DiacriticSounds
    let UndefinedEscapeCharacter     = Diac("Undefined escape character", null, "*")
    let Nasalized                    = Diac("Nasalized", "\u0303", "_~")
    let Centralized                  = Diac("Centralized", "\u0308", "_\"")
    let Advanced                     = Diac("Advanced", "\u031F", "_+")
    let Retracted                    = Diac("Retracted", "\u0320", "_-")
    let RisingTone                   = Diac("RisingTone ", "\u030C", "_R")
    let Voiceless                    = Diac("Voiceless", "\u0325", "_0")
    let Implosive                    = Diac("Implosive", null, "_<")
    let Syllabic                     = Diac("Syllabic", "\u0329", "_=")
    let Ejective                     = Diac("Ejective", "\u02BC", "_>")
    let Pharyngealized               = Diac("Pharyngealized ", "\u02E4", "_?\\")
    let FallingTone                  = Diac("Falling tone", "\u0302", "_F")
    let NonSyllabic                  = Diac("Non-syllabic", "\u032F", "_^")
    let NoAudibleRelease             = Diac("No audible release", "\u031A", "_}")
    let RhoticHook                   = Diac("Rhotic hook", "\u02DE", "`")
    let AdvancedTongueRoot           = Diac("Advanced tongue root ", "\u0318", "_A")
    let Apical                       = Diac("Apical", "\u033A", "_a")
    let ExtraLowTone                 = Diac("Extra low tone", "\u030F", "_B")
    let LowRisingTone                = Diac("Low rising tone", "\u1DC5", "_B_L")
    let LessRounded                  = Diac("Less rounded", "\u031C", "_c")
    let Dental                       = Diac("Dental", "\u032A", "_d")
    let VelarizedOrPharyngealized    = Diac("Velarized or Pharyngealized", "\u0334", "_e")
    let GlobalFall                   = Diac("Global fall", "↘", "<F>")
    let Velarized                    = Diac("Velarized", "\u02E0", "_G")
    let HighTone                     = Diac("High tone", "\u0301", "_H")
    let HighRisingTone               = Diac("High rising tone", "\u1DC4", "_H_T")
    let Aspirated                    = Diac("Aspirated", "\u02B0", "_h")
    let Palatalized                  = Diac("Palatalized", "\u02B2", "_j")
    let CreakyVoiced                 = Diac("Creaky voiced", "\u0330", "_k")
    let LowTone                      = Diac("Low tone", "\u0300", "_L")
    let LateralRelease               = Diac("Lateral release", "\u02E1", "_l")
    let MidTone                      = Diac("Mid tone", "\u0304", "_M")
    let Laminal                      = Diac("Laminal", "\u033B", "_m")
    let LinguoLabial                 = Diac("Linguo-Labial", "\u033C", "_N")
    let NasalRelease                 = Diac("Nasal release", "\u207F", "_n")
    let MoreRounded                  = Diac("More rounded", "\u0339", "_O")
    let Lowered                      = Diac("Lowered", "\u031E", "_o")
    let RetractedTongueRoot          = Diac("Retracted tongue root", "\u0319", "_q")
    let GlobalRise                   = Diac("Global rise", "↗", "<R>")
    let RisingFallingTone            = Diac("Rising falling tone", "\u1DC8", "_R_F")
    let Raised                       = Diac("Raised", "\u031D", "_r")
    let ExtraHighTone                = Diac("Extra high tone", "\u030B", "_T")
    let BreathyVoiced                = Diac("Breathy voiced", "\u0324", "_t")
    let Voiced                       = Diac("Voiced", "\u032C", "_v")
    let Labialized                   = Diac("Labialized", "\u02B7", "_W")
    let ExtraShort                   = Diac("Extra short", "\u02D8", "_X")
    let MidCentralized               = Diac("Mid-centralized", "\u033D", "_x")
    let Downstep                     = Diac("Down-step", "↓", "!")
    let Upstep                       = Diac("Up-step", "↑", "^")
    let SylableBreak                 = Diac("Sylable break", ".", ".")
    let PrimaryStress                = Diac("Primary stress", "ˈ", "\"")
    let SecondaryStress              = Diac("Secondary stress", "ˌ", "%")
    let Long                         = Diac("Long", "ː", ":")
    let HalfLong                     = Diac("Half-long", "ˑ", ":\\")
    let IndeterminacyinFrenchVowels  = Diac("Indeterminacy in french vowels", null, "/")
    let BeginNonsegmentalNotation    = Diac("Begin Non-segmental notation", null, "<")
    let Endnonsegmentalnotation      = Diac("End non-segmental notation", "", ">")
    let Voicedepiglottalfricative    = Diac("Voiced epiglottal fricative", "ʢ", "<\\")
    let Postalveolarclick            = Diac("Post-alveolar click", "ǃ", "!\\")
    let MinorGroup                   = Diac("Minor group", " | ", " | ")
    let Dentalclick                  = Diac("Dental click", "ǀ", " | \\")
    let MajorGroup                   = Diac("Major group", "‖", " |  | ")
    let Alveolarlateralclick         = Diac("Alveolar lateral click", "ǁ", " | \\ | \\")
    let Palatalclick                 = Diac("Palatal click", "ǂ", "")
    let Linkingmark                  = Diac("Linkingmark", "‿", "-\\")
    let VoicelessDescender           = Diac("Voiceless descender", "\u030A", "")
    let CombiningMacron              = Diac("Combining macron", "\u0331", "")
    let TieBarBelow                  = Diac("Tie-bar below", "\u035C", "")
    let TieBarAbove                  = Diac("Tie-bar above", "\u0361", "")
    let ReadyMadeCombination         = Diac("Ready made combination", "\u026B", "")
    let Becomes                      = Diac("Becomes", "→", "")
    let Separator                    = Diac("Separator", "", "-")
  end

  //======================================================================

  let HasFlag(flags, f)       = (flags & f) != None
  let NotFlag(flags, f)       = (flags & f) == None
  let HasMask(flags, mask, f) = (flags & mask) == (f & mask)

  //======================================================================
  // Convert SAMPA text to sound data
  //======================================================================

  let MatchSampa(ref sound, data) begin
     return sound.Sampa and sound.Sampa.Length > 0 and data.Index + sound.Sampa.Length <= data.SLength and sound.Sampa == data.Sampa.Slice(data.Index..<(data.Index+sound.Sampa.Length))
  end

  let SAMPACheck(list, sampa, index, length) begin
    var matches = Sounds.FindSlice(MatchSampa, {Sampa: sampa, Index: index, SLength: length}, 1);
    if (matches.Length == 0)
      list.AddReference(NoSound);
    else
      list.AddReference(matches[0]);
    end;
    if (matches.Length > 0 and (index + matches[0].Sampa.Length) < length)
      SAMPACheck(list, sampa, index + matches[0].Sampa.Length, length);
    end
  end

  let WordToSounds(word) begin
    var list = Type.List(16);
    SAMPACheck(list, word.Sampa, 0, word.Sampa.Length);
    return list;
  end

  //======================================================================
  // Matching Options Table
  //======================================================================

  let CheckFlags(sflags, rflags, options) = sflags.NotFlag(options.Exclude) and sflags.HasFlag(options.Include) and sflags.HasMask(options.RowMask | rflags, rflags)

  let AnyManners(flags, data)             = CheckFlags(data.Flags, flags | data.Options.All, data.Options)

  let MatchRow(sound, data)               = sound.Place == data.Place and CheckFlags(sound.Flags, data.Flags, data.Options)

  let MatchInclude(sound, data)           = sound.Place == data.Place and sound.Flags.NotFlag(data.Options.Exclude) and
                                            sound.Flags.HasFlag(data.Options.Include) and
                                            data.Options.Manners.Contains(AnyManners, {Flags: sound.Flags, Options: data.Options})

  let MatchPlace(place, options)          = AllSounds.Contains(MatchInclude, {Place: place, Options: options})
  let GetPlaces(options)                  = Places.FindSlice(MatchPlace, options)


  let BoxSize  = Type.Size(18 pts, 20 pts)
  let CellSize = Type.Size(BoxSize.Width * 2, BoxSize.Height)

  let SoundName(sound) = Span {
    if (sound.Flags.HasFlag(Vowel))
      sound.Open,
      Space,
      sound.Backness,
    else
      sound.Place,
    end,
    Space,
    Span {
      Separator: Space,
      if (sound.Flags.HasFlag(Diacritic))
        sound.Description
      else
        each sound.Flags,
      end
    }
  }

  let ShowCodePoint(c) = {Style.MonoFamily, TextRadix: 16, TextDigits: 4} Type.Integer(c)

  let CodePoints(text) = Span {
    Separator: Lang.Separator,
    if (text)
      ShowCodePoint(each text)
    end
  }

  let ShowSound(ref sound, flags=Impossible) = Span {
    Style.IPAFamily,
    Popup: SoundPopup.Call(sound),
    Link: sound.FullSymbolName,
    if (sound.Flags.HasFlag(flags))
      Assert(false, "Impossible sound"),
      TextColor: Colors.Red,
    end,
    if (sound.Flags.HasFlag(Diacritic))
      "  ",
    end,
    sound.Text
  }

  let SoundText(set, ref sound) begin
    if (sound.Flags.NotFlag(Impossible))
      AddReference(set, sound);
    end;
    return ShowSound(sound);
  end

  let SoundBox(set, ref sound, color) = Canvas {
    HAlign: HAligns.Center,
    Size: BoxSize,
    if (sound.Text)
      TextHeight: BoxSize.Height - 4 pts,
      TextColor: color,
      SoundText(set, sound)
    else
      Style.ImpossibleBackground
    end
  }

  let ShowBox(set, ref sound, color) = SoundBox(set, sound, color) {
    if (sound.Flags.HasFlag(Voiced))
      X: BoxSize.Width
    end
  }

  let MatchError(matches) = matches.Length > 2 or (matches.Length == 2 and matches[0].Flags.HasFlag(Voiced) == matches[1].Flags.HasFlag(Voiced))

  let SoundBlock(set, matches) = Cell {
    Style.SoundBottom,
    if (matches.Length > 0)
      if (matches.Length == 1 and matches[0].Flags.HasFlag(Impossible))
        Style.ImpossibleBackground
      else
        TextHeight: 1 pts,
        Span {
          Canvas {
            Size: CellSize,
            ShowBox(set, each matches, MatchError(matches) ? Colors.Red : Colors.Black)
          }
        }
      end
    end
  }

  let AddCell(set, options, place, flags) = SoundBlock(set, AllSounds.FindSlice(MatchRow, {Place: place, Flags: flags, Options: options}))

  let AddRow(set, options, places, flags) begin
    var allflags = flags | options.All;
    return Row {
      Cell {
        VAlign: VAligns.Center,
        EdgeR: 0.5 pts,
        Style.TitleBackground,
        PaddingLR: 2 pts,
        TextHeight: 7 pts,
        if (allflags.HasMask(Lateral Pulmonic Affricate Sibilant, Pulmonic Affricate))
          Lang.NoSibilant,
        else
          flags,
        end,
      },
      AddCell(set, options, each places, allflags)
    }
  end

  let PlaceHeader(place) = Style.HeaderCell(place.Name)

  let ShowTable(set, options) begin
    var places = GetPlaces(options);

    return Block {
      Table {
        Style.TableEdge,
        Columns: [options.ColWidth {EdgeR: 0.5 pts}] +
                 [CellSize.Width {HAlign: HAligns.Center, EdgeR: 0.25 pts}] * places.Length,

        Style.TitleBar(options.Title, places.Length+1),
        Row {
          TextHeight: 6 pts,
          Style.HeaderCell(Bold Lang.Manner) {HAlign: HAligns.Left},
          PlaceHeader(each places)
        },
        AddRow(set, options, places, each options.Manners),
      },
      Style.TableNotes {
        Lang.ShadedImpossible,
        Space,
        options.Notes
      },
    }
  end
  //======================================================================

  let VowelBlock(set, matches) = Cell {
    Style.SoundBottom,
    HAlign: HAligns.Center,
    TextHeight: BoxSize.Height,
    if (matches.Length == 2)
      Span {
        SoundText(set, matches[0]),
        " • " {TextColor: Colors.LightGray},
        SoundText(set, matches[1]),
      }
    elseif (matches.Length == 1)
      SoundText(set, matches[0]),
    end
  }

  let MatchVowelPair(ref sound, data) = sound.Flags.HasFlag(Vowel) and sound.Open == data.Open and sound.Backness == data.Backness
  let VowelCell(set, open, backness)  = VowelBlock(set, Sounds.FindSlice(MatchVowelPair, {Open: open, Backness: backness}))

  let VowelRow(set, open) = Row {
    Cell {
      VAlign: VAligns.Center,
      Style.TitleBackground,
      Style.SoundBottom,
      open.Name
    },
    VowelCell(set, open, each Backnesses)
  }

  let VowelTable(set) = Block {
    Table {
      HAlign: HAligns.Center,
      Style.TableEdge,
      Columns: [(1 inch){EdgeR: 0.5 pts}] + [BoxSize.Width*3 {EdgeR: 0.25 pts}] * Backnesses.Length,
      Style.TitleBar(Lang.Vowels, Backnesses.Length+1),
      Row {
        TextHeight: 10 pts,
        Style.HeaderCell(Empty),
        Style.HeaderCell(each Backnesses)
      },
      VowelRow(set, each Opens)
    },
    Style.TableNotes {
      Lang.VowelSymbols,
    },
  }
  //======================================================================

  let MatchOther(ref sound, set) = not set.ContainsReference(sound)

  let OtherColumns = 2

  let OtherCell(ref sound) = {
    Cell {
      VAlign: VAligns.Center,
      HAlign: HAligns.Center,
      TextHeight: 20 pts,
      LocationMark: sound.FullSymbolName,
      ShowSound(sound),
    },
    Cell {
      VAlign: VAligns.Center,
      SoundName(sound)
    }
  }

  let OtherRow(sounds) = Row {
    OtherCell(each sounds)
  }

  let OtherTable(set) = Block {
    Table {
      Style.TableEdge,
      Columns: [BoxSize.Width, Metrics.Content.Width * 0.5 - BoxSize.Width] * OtherColumns,
      Style.TitleBar(Lang.OtherSounds, OtherColumns*2),
      OtherRow(each (FindSlice(Sounds, MatchOther, set) / OtherColumns)),
    },
    Style.TableNotes
  }
  //======================================================================

  let DiacriticColumns = 3

  let DiacriticCell(ref sound) = Cell {
    Paragraph {
      LeftIndent: 0.5 inches,
      FirstIndent: -0.5 inches,
      LocationMark: sound.FullSymbolName,
      ShowSound(sound) {
        TextHeight: 18 pts,
        Tab,
      },
      sound.Description
    }
  }

  let DiacriticRow(sounds) = Row {
    DiacriticCell(each sounds)
  }

  let DiacriticTable = Block {
    Table {
      Style.TableEdge,
      Columns: [Metrics.Content.Width / DiacriticColumns] * DiacriticColumns,
      Style.TitleBar(Lang.Diacritics, DiacriticColumns),
      DiacriticRow(each DiacriticSounds / DiacriticColumns),
    },
    Style.TableNotes
  }
  //======================================================================
  // Sound Tree
  //======================================================================

  let AddNode(name) = Node {
    Bevel: 20%,
    Curvature: 20%,
    Label: name
  }

  let AddSound(set, ref sound) begin
    set.AddReference(sound);
    return ShowSound(sound)
  end

  let AddSounds(set, name, func, data) begin
    var sounds = Sounds.FindSlice(func, data);
    if (sounds.Length > 0)
      return Node {
        Label: Frame {
          Width: 3.5 inches,
          Paragraph {
            LeftIndent: 1 inches,
            FirstIndent: -1 inches,
            Span {
              TextColor: Colors.DarkGray,
              name,
              ":\t",
            },
            Span {
              TextHeight: 15 pts,
              Separator: Space,
              AddSound(set, each sounds),
            }
          }
        }
      }
    else
      return null
    end
  end

  let MatchVowel(ref sound, data) = sound.Flags.HasFlag(Vowel) and sound.Backness == data.Backness
  let AddVowels(set, backness)    = AddSounds(set, backness.Name, MatchVowel, {Backness: backness})

  let MatchFlags(ref sound, data) = not data.Set.ContainsReference(sound) and sound.Flags.HasMask(data.All, data.Flags) and sound.Flags.HasMask(data.Other, data.Other)
  let AddFlag(set, all, flags, f) = AddSounds(set, f.Name, MatchFlags, {Set: set, All: all, Flags: flags, Other: f})

  let AddConsonants(set, name, all, flags) = AddNode(name) {
    AddFlag(set, all, flags, each [Tenuis, Click, Nasal, Ejective, Fricative, Sibilant, Lateral, Stop, Approximant, TapFlap, Trill, None]),
  }

  let AddVoicedPairs(set, name, all, flags) = AddNode(name) {
    AddConsonants(set, Lang.Voiced, all Voiced, flags Voiced),
    AddConsonants(set, Lang.Voiceless, all Voiced, flags),
  }

  let SoundTree begin
    var set1 = Type.Dictionary(256);
    var set2 = Type.Dictionary(256);
    var all  = Vowel Pulmonic Affricate;

    return Block {
      Tree {
        Width: 7 inches,
        LabelGap: 3 pts,
        Node {
          AddNode(Lang.Vowels) {
            AddVowels(set1, each Backnesses)
          },
          AddNode(Lang.Affricates) {
            AddVoicedPairs(set1, Lang.NonPulmonic, all, Affricate),
            AddVoicedPairs(set1, Lang.Pulmonic, all, Pulmonic Affricate),
          },
          AddNode(Lang.Consonants) {
            AddVoicedPairs(set1, Lang.Pulmonic, all, Pulmonic),
            AddVoicedPairs(set1, Lang.NonPulmonic, all, None),
          },
          AddSounds(set2, Lang.OtherSounds, MatchOther, set1)
        }
      }
    }
  end
  //======================================================================

  let SoundColumns = 4
  let SoundSize    = 40 pts

  let ShowSampa(sampa) = Span {
    Style.MonoFamily,
    sampa,
  }

  let SoundDisplay(sound, location) = Block {
    ParAlignment: ParAlignments.Center,
    Paragraph {
      LocationMark: location,
      SpaceBefore: 8 pts,
      SpaceAfter: 8 pts,
      TextHeight: SoundSize,
      Style.IPAFamily,
      SpaceAfter: SoundSize * 0.125,
      sound.Text,
    },
    Paragraph {
      TextHeight: 10 pts,
      SoundName(sound),
    },
    Paragraph {
      TextHeight: 8 pts,
      ParBackground: 95%,
      CodePoints(sound.Text),
    },
    Paragraph {
      TextHeight: 8 pts,
      if (sound.Sampa and sound.Sampa.Length > 0)
        ParBackground: 90%,
        ShowSampa(sound.Sampa)
      elseif (sound.Text.Length > 0)
        ParBackground: Colors.Red,
//        Assert(false, "Missing Sampa definition"),
      end
    },
  }

  let SoundCell(ref sound) = Cell {
    Edge: 0.25 pts {Color: Colors.LightGray},
    Padding: 2 pts,
    SoundDisplay(sound, sound.FullSymbolName)
  }

  let SoundRow(sounds) = Row {
    SoundCell(each sounds)
  }

  let SoundTable(sounds) = Block {
    Table {
      Columns: [Metrics.Content.Width / SoundColumns] * SoundColumns,
      Style.TitleBar(Lang.IPAListing, SoundColumns),
      SoundRow(each (sounds / SoundColumns))
    },
    Style.TableNotes
  }

  let SoundPopup(sound) = Frame {
    Width: 2 inches,
    SoundDisplay(sound, null)
  }
  //======================================================================
  // Options for each table type
  //======================================================================

  let PulmonicTable = {
    Title: Lang.PConsonants,
    ColWidth: 45 pts,
    Exclude: Affricate,
    Include: Pulmonic,
    All: None,
    Manners: [Nasal, Stop, Sibilant Fricative, Fricative, Approximant, TapFlap, Trill, Lateral Fricative, Lateral Approximant, Lateral TapFlap],
    RowMask: Nasal Stop Sibilant Fricative Approximant TapFlap Trill Lateral Velarized,
    Notes: Lang.PulmonicSymbols
  }

  let NonPulmonicTable = {
    Title: Lang.NPConsonants,
    ColWidth: 80 pts,
    Exclude: Vowel Pulmonic Central,
    Include: Ejective Click Implosive,
    All: None,
    Manners: [Ejective Stop, Ejective Fricative, Ejective Lateral Fricative, Click Tenuis, Click Nasal, Click Tenuis Lateral, Implosive],
    RowMask: Lateral,
    Notes: Lang.ConsonantSymbols
  }

  let PulmonicAffricatesTable = {
    Title: Lang.PulmonicAffricates,
    ColWidth: 50 pts,
    Exclude: Vowel,
    Include: Affricate Sibilant Lateral,
    All: Pulmonic Affricate,
    Manners: [Sibilant, None, Lateral],
    RowMask: Pulmonic Affricate Sibilant Fricative Lateral,
  }

  let EjectiveAffricatesTable = {
    Title: Lang.EjectiveAffricates,
    ColWidth: 50 pts,
    Exclude: Vowel Click Implosive Pulmonic,
    Include: Ejective Affricate Central Lateral,
    All: Ejective Affricate,
    Manners: [Central, Lateral],
    RowMask: Pulmonic Approximant Central Lateral,
  }
  //======================================================================
  // Find the list of meanings for which there is a word in every language
  //======================================================================

  let ContainsWord(word, data)        = word.Meaning == data.Meaning
  let ContainsMeaning(language, data) = language.Words.Contains(ContainsWord, data)

  let CollectMeanings(set, languages, ref meaning) begin
    var list = languages.FindSlice(ContainsMeaning, {Meaning: ref meaning});
    if (list.Length == languages.Length)
      set.AddReference(meaning)
    end
  end

  let FindCompleteMeanings(languages) begin
    var set = Type.Dictionary(128);
    CollectMeanings(set, languages, each WordMeanings);
    return set.Slice(0..);
  end


  let MeaningRow(ref meaning) = Row {
    Cell {
      HAlign: HAligns.Center,
      Style.TitleBackground,
      Style.SoundBottom,
      EachIndex+1
    },
    Cell {
      meaning.Name
    }
  }

  let MeaningTable(meanings) = Block {
    Table {
      Style.TableEdge,
      Columns: [0.5 inches, 4 inches],
      Style.TitleBar("Meanings", 3),
      Row {
        Style.HeaderCell("#") {HAlign: HAligns.Center},
        Style.HeaderCell("Meaning") {HAlign: HAligns.Left}
      },
      MeaningRow(each meanings),
    },
    Style.TableNotes
  }
  //======================================================================

  let CharacterList = ('A'..'Z' step 1) + ('a'..'z' step 1) + ('0'..'9' step 1)

  let WordMatch(meaning, def) = meaning == def.Meaning
  let CompleteWord(def)       = Results.CompleteMeanings.Contains(WordMatch, def)
  let GetWordList(language)   = language.Words.FindSlice(CompleteWord)


  let CollectWord(set, word) begin
    var sounds = WordToSounds(word);
    set.AddReference(each sounds);
  end

  let CollectLanguage(set, language) begin
    CollectWord(set, each GetWordList(language));
  end

  let FindUniqueSounds(languagelist) begin
    var set = Type.Dictionary(256);
    CollectLanguage(set, each languagelist);
    return set.Slice(0..);
  end

  let ShowIPAWord(word) =  Span {
//    word.Sampa,
    (each IPA.WordToSounds(word)).Text
  }

  let SameSound(ref sound, data) = sound == data.Sound

  let CollectLangWord(set, ref sound, word) begin
    var sounds = WordToSounds(word);
    if (sounds.Contains(SameSound, {Sound: ref sound}))
      set.AddElement(word.Sampa, word);
    end
  end

  let CollectLanguageWords(set, ref sound, language) begin
    CollectLangWord(set, sound, each GetWordList(language));
  end

  let WordsWithSound(ref sound) begin
    var set = Type.Dictionary(256);
    CollectLanguageWords(set, sound, each Results.LanguageList);
    return set.Slice(0..);
  end

  let CharacterRow(ref sound) = Row {
    Cell {
      HAlign: HAligns.Center,
      Style.TitleBackground,
      CharacterList[EachIndex]
    },
    Cell {
      HAlign: HAligns.Center,
      ShowSound(sound, Diacritic | Impossible),
    },
    Cell {
      Style.IPAFamily,
      Span {
        Separator: Lang.Separator,
        ShowIPAWord(each WordsWithSound(sound))
      }
    }
  }

  let CharacterTable(sounds) = Block {
    Table {
      Style.TableEdge,
      Columns: [0.5 inches, 0.5 inches, 6 inches],
      Row {
        Style.HeaderCell("Nex"),
        Style.HeaderCell(Lang.IPA),
        Style.HeaderCell("Words containing this sound")
      },
      CharacterRow(each sounds),
    },
    Style.TableNotes
  }
  //======================================================================

  let ShowGroups begin
    var set = Type.Dictionary(256);
    return Block {
      ShowTable(set, each [PulmonicTable, NonPulmonicTable]),
      PageBreak,
      ShowTable(set, each [PulmonicAffricatesTable, EjectiveAffricatesTable]),
      VowelTable(set),
      OtherTable(set),
      DiacriticTable,
      PageBreak,
      SoundTree
    }
  end
  //======================================================================
end
