using Format, Math, Units, LinkTypes;

//======================================================================

readonly namespace PaperStyle {
  const TableSpace        = 24 pts;
  const SegmentColumns    = 4;
  const SegmentSize       = 40 pts;
  const SegmentWidth      = 2 inches;
  const SegmentTextFactor = 0.58;
  const TableEdgeSize     = 0.25 pts;
  const TableBorder       = TableEdgeSize;

  SizeClass BorderSize    = new(2, 2);
  SizeClass BoxSize       = new(18 pts, 20 pts);
  SizeClass CellSize      = new(BoxSize.Width * 2, BoxSize.Height);

  IPAFamily            = TextFamily: TextFamilies.LibertinusSerif;
  BoldSymbol           = {TextFamily: TextFamilies.CMUSerif; Bold};
  TaxonFormat          = TextColor: Colors.DarkBlue;
  CommentFormat        = TextColor: Colors.Green;
  KeywordFormat        = TextColor: Colors.Blue;
  Used                 = TextColor: Colors.Red;
  ImpossibleBackground = Background: 80%;
  TitleBackground      = Background: 90%;
  CommentColor         = new ColorClass(0, 0x64, 0);
  StringColor          = new ColorClass(168, 21, 53);
  VariableColor        = Colors.DarkBlue;
  AlignBackColor       = 95%;
  ColumnEdge           = BorderR(TableEdgeSize);
  SegmentBottom        = BorderB(new(TableEdgeSize, 0, 80%));
  HighlightColor       = Colors.Orange;
  TextColor            = Colors.Black;
  SlideHeader          = Colors.SlateGray;
  textit               = Span {TextLiteral: true; Italic};
  TextIpa              = Span {TextLiteral: true; IPAFamily; Begin:"/"; End:"/"};
  HeatMap              = LinearGradientClass.FromColorArray([Colors.Blue, Colors.Cyan, Colors.Yellow, Colors.Pink, Colors.Red]);

  LanguageTable(ColumnClass[] columns) = Table(new(new(0, 2), new(2 pts, 2), new(0, 2), new(2 pts, 2)), PadLR(2 pts), columns);

  LanguageTitleRow = Row(BorderB(1 pts));

  Keyword(text) = Span {
    KeywordFormat;
    text;
  };

  ReadOnly = Keyword("readonly ");

  Variable(text) = Span {
    TextColor: new ColorClass(43, 145, 175);
    text;
  };

  NameSpace(text) = Span {
    ReadOnly; Keyword("namespace ");
    Variable(text);
    " {"
  };

  RowBar(i) = Row {
    if (i mod 2 != 0)
      Background: 95%;
  };

  TableNotes = Paragraph {
    Italic;
    SpaceAfter: TableSpace;
  };

  Definition(s) = Span {
    Italic;
    s;
  };

  BranchMarker = HBox {
    Margin: PadR(2 pts);
    Shape(Colors.Black, new StrokeClass(1 pt, Colors.Gray)) {
      EllipsePath(new(0, 1 pts))
    };
  };

  ShowTree(ContentStyleClass style, NodeClass root, width, title=null, axis=null, reorder=true) = VBox {
    if (title is valid) {
      Margin: PadAll(5 pts);
      style.Heading1 {
        title;
      };
    }

    Tree(width, null) {
      style.SansSerif;
      TextHeight: 11 pts;
      Reorder: reorder;
      Root: root;
      Default: new NodeClass(null) {
        NodeGap: 2 pts;
        Curvature: 20%;
        Bevel: 20%;
      };
      if (axis is valid) {
        TreeAxisLabel: axis;
        TreeAxisLabel: axis;
        TreeAxis: ChartAxis;
      }
    };
  };

  ShowTreeHorizontal(ContentStyleClass style, NodeClass root, width, title=null, axis=null) = HBox {
    style.SansSerif;

    VAlign: Top;
    if (title is valid) {
      HBox(null, null, PadR(6 pts)) {
        VAlign: Center;
        Paragraph {
          Bold;
          title;
        };
      };
    }

    Tree(width, null) {
      TextHeight: 8 pts;
      Reorder: true;
      Root: root;
      Default: new NodeClass(null) {
//        NodeGap: 5 pts;
        Curvature: 20%;
        Bevel: 20%;
//        Marker: BranchMarker;
      };
      if (axis is valid) {
        TreeAxisLabel: axis;
        TreeAxis: ChartAxis;
      }
    };
  };

  AppendixRow(appendix) = Paragraph {
    LeftIndent: 20 pts;
    FirstIndent: -20 pts;
    each1;
    ".";
    Tab;
    Span {
      Action: new ActionClass(Actions.ToAnchor, Lang.Appendix + each0);
      appendix.Title
    };
  };

  HeaderCell(ContentStyleClass style) = Cell(new(new(0, 2 pts), new(0, 2 pts), new(0, 2 pts), new(1 pts, 2 pts))) {
    HAlign: Center;
    VAlign: Center;
    style.SansSerif;
    TitleBackground;
  };

  TitleBar = Paragraph {
    SpaceBefore: 6 pts;
    ParBackground: 40%;
    TextColor: Colors.White;
    TextHeight: 16 pts;
  };

  BulletList = ListBlock {
    LeftIndent: 24 pts;
    FirstIndent: -16 pts;
  };

  NumberList = ListBlock(i => i + ".") {
    LeftIndent: 24 pts;
    FirstIndent: -16 pts;
  };

  SourcePar(DataSetClass data, ConceptClass concept) = Block {
    ParAlignment: Left;
    SpaceBefore: 6 pts;
    LeftIndent: 0.25 inches;
    TextHeight: 8 pts;

    TextBlock {
      SpaceAfter: 10 pts;
      Span {
        Nexus.Keyword("namespace ");
        concept.Name;
        " {";
      };
      TextBlock {
        IndentSpace: 2;
        foreach (var cvar in concept.Attribute.Children) {
          Span {
            Nexus.Keyword("namespace ");
            cvar.Name;
            " {";
          };
          TextBlock {
            IndentSpace: 2;
            foreach (var word in cvar.Value) {
              var taxon = data.Taxa[each0];
              Span {
                taxon.Language;
                Span {
                  Space * (data.MaxLanguageName - taxon.Language.Name.Length);
                  " = ";
                  Span {
                    TextColor: PaperStyle.StringColor;
                    Quote;
                    foreach (var i in word) {
                      if (i < 0)
                        "-";
                      else
                        data.UniqueSegments[i].Ipa;
                    }
                    Quote;
                  }
                  ";";
                };
              };
            }
          };
          "}";
        }
      };
      "}";
    }
//    SourceSelection(concept, SourceSelectOptions.Line SourceSelectOptions.Children);
  };

  BodyTable(ColumnClass[] columns) = Table(null, null, columns) {
    SpaceBefore: 10 pts;
    SpaceAfter: 10 pts;
    LeftIndent: 0.5 inches;
  };

  BodyTitle = Span {
    Bold;
  };

  NeedsReview(text) = SpanParens {
    TextColor: Colors.Red;
    text;
  };

  Equation = Span {
    TextEquation: true;
  };

  ValueLabel = HBox(null, null, PadB(6)) {
    Transform: TransformClass.Rotate(-90 degrees);
    TransformFit: true;
  };
}

//======================================================================

class TreeContentClass: ContentClass {
  var NodeClass Root;
  var           Axis;

  Constructor(title, NodeClass root, axis=null) {
    super.Constructor(title);
    Root = root;
    Axis = axis;
  }

  override GetBody(ContentStyleClass style, title) = Paragraph {
    PaperStyle.ShowTree(style, Root, 100%, null, Axis);
  };
}

//======================================================================

class LineStyleClass {
  var LineSize,
      Flat,
      Tip,
      Side,
      Edge,
      Angle,
      LineColor;

  Constructor(size, width=1.4, length=1.8) {
    LineSize  = size;
    LineColor = Colors.Black;
    Flat      = LineSize * width;
    Tip       = LineSize * length;
    Side      = 0.5 * LineSize + Flat;
    Angle     = Atan2(Side, Tip);
    Edge      = Sqrt(Side*Side + Tip*Tip);
  }
}
//======================================================================

readonly namespace Graphics {
  Half      = 0.5;
  OneEighty = Math.PI;
  Ninety    = Half * OneEighty;
  FortyFive = 0.25 * OneEighty;

  PointClass ExtendPoint(PointClass center, r, angle) {
    return new(center.X + r * Cos(angle), center.Y + r * Sin(angle));
  }

  Adjust(PointClass center, r, angle) {
    return center - ExtendPoint(new(0), r, angle);
  }

  GetAngle(PointClass p1, PointClass p2) {
    return Atan2(p2.Y - p1.Y, p2.X - p1.X);
  }

  Line(LineStyleClass line, PointClass p1, PointClass p2) = Shape(null, new(line.LineSize, line.LineColor, LineStyles.Solid, LineCaps.Round)) {
    OpenPath(p1) {
      LineTo(p2);
    };
  };

  TwoArrowLine(LineStyleClass line, PointClass p1, PointClass p2) = Shape(line.LineColor) {
    var angle = GetAngle(p1, p2);
    var opp   = angle - Ninety;
    var a1    = ExtendPoint(p1, line.Edge, angle + OneEighty - line.Angle);
    var a2    = ExtendPoint(a1, line.Flat, opp);
    var a3    = ExtendPoint(a2, line.LineSize, opp);
    var b1    = ExtendPoint(p2, line.Edge, angle + line.Angle);
    var b2    = ExtendPoint(b1, line.Flat, opp);
    var b3    = ExtendPoint(b2, line.LineSize, opp);

    ClosedPath(p1.X, p1.Y) {
      LineTo(a1);
      LineTo(a2);
      LineTo(b2);
      LineTo(b1);
      LineTo(p2);
      LineTo(ExtendPoint(b3, line.Flat, opp));
      LineTo(b3);
      LineTo(a3);
      LineTo(ExtendPoint(a3, line.Flat, opp));
    }
  };

  CircleLine(LineStyleClass line, PointClass center, radius, angle, anglegap) = Shape(null, new(line.LineSize, line.LineColor, LineStyles.Solid, LineCaps.Round)) {
    var angle1 = angle + anglegap;
    var angle2 = angle - anglegap;
    var p1     = ExtendPoint(center, radius, angle1);
    var p2     = ExtendPoint(center, radius, angle2);

    OpenPath(p1) {
      ArcTo(p2, new(radius), angle, true, true);
    }
  };

  CircleArrow(LineStyleClass line, PointClass center, radius, angle, anglegap) = Shape(line.LineColor) {
    var angle1 = angle + anglegap;
    var angle2 = angle - anglegap;
    var an1    = angle1 - Ninety;
    var an2    = angle2 - Ninety;
    var p1     = ExtendPoint(center, radius, angle1);
    var p2     = ExtendPoint(center, radius, angle2);
    var a1     = ExtendPoint(p1, line.Tip, an1 + 1.5 * Ninety);
    var a2     = ExtendPoint(a1, line.Flat, an1 - Ninety);
    var a3     = ExtendPoint(a2, line.LineSize, an1 - Ninety);
    var b1     = ExtendPoint(p2, line.Tip, an2 + FortyFive);
    var b2     = ExtendPoint(b1, line.Flat, an2 - Ninety);
    var b3     = ExtendPoint(b2, line.LineSize, an2 - Ninety);

    ClosedPath(p1.X, p1.Y) {
      LineTo(a1);
      LineTo(a2);
      ArcTo(b2, new(radius + line.LineSize), angle, true, true);
      LineTo(b1);
      LineTo(p2);
      LineTo(ExtendPoint(b3, line.Flat, an2 - Ninety));
      LineTo(b3);
      ArcTo(a3, new(radius), angle, true);
      LineTo(ExtendPoint(a3, line.Flat, an1 - Ninety));
    };
  };
}
//======================================================================

