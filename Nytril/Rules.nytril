using Format, Units, FeatureSet, Math, SegmentGroups, Style;
//======================================================================

class FilterClass {
  var Name;

  Constructor(name) {
    Name = name;
  }

  virtual Matches(SegmentClass segment) = true;

  override GetPopup = Frame {
    Width: 2 inches;
    Paragraph {
      ParAlignment: ParAlignments.Center;
      TextHeight: 16 pts;
      Name;
      BorderB: 1;
    };
    Results.ShowFilterSegments(this, ParAlignments.Left);
  };

  override GetLayout = Span {
    Popup: this;
    Name;
  };
}
//======================================================================

class PartitionClass {
  SegmentClass[] Segments;
  var            Index,
                 Center,
                 Radius,
                 Angle,
                 Outer;
  FilterClass    Filter;

  Constructor(index, FilterClass filter, SegmentClass[] segments) {
    Index    = index;
    Filter   = filter;
    Segments = segments;
  }

  override GetPopup = Filter.GetPopup;
}
//======================================================================

abstract class RuleClass {
  ListClass        FilterList;
  FilterClass[]    Filters,
                   FiltersPlus;
  PartitionClass[] Partitions;
  var              Name,
                   Matrix,
                   Numbers;

  Constructor(name) {
    Name       = name;
    Numbers    = false;
    FilterList = new ListClass(128);
  }

  void Add(FilterClass filter) {
    FilterList.Add(filter);
  }

  MatchesRule(FilterClass filter, SegmentClass segment) {
    foreach (var f in FiltersPlus) {
      if (f == filter)
        return f.Matches(segment);
      if (f.Matches(segment))
        return false;
    }
    return false;
  }

  virtual GetFilterIndex(SegmentClass segment) {
    var c = 0;
    foreach (var filter in FiltersPlus) {
      if (MatchesRule(filter, segment))
        return c;
      ++c;
    }
    return c;
  }

  void SetSegmentCharacter(SegmentClass segment, index) {
    segment.CharacterIndex = index;
    if (Numbers)
      segment.CharacterLetter = index;
    else if (index < Rev.CharacterList.Length)
      segment.CharacterLetter = Rev.CharacterList[index];
    else
      System.Assert(false, "Too many characters");
  }

  void GetFilters {
    Filters = FilterList.Values;
    Add(Residue);
    FiltersPlus = FilterList.Values;
  }

  virtual void AssignCharacters {
    var last = Rev.CharacterList.Length-1;
    foreach (var segment in Results.UniqueSegments) {
      var index = GetFilterIndex(segment);
      if (index > last)
        index = last;
      SetSegmentCharacter(segment, index);
    }
    GetFilters;
  }

  void AssignPartitions {
    var list = new ListClass(Results.UniqueSegments.Length, PartitionClass);
    var i    = 0;
    foreach (var filter in FiltersPlus) {
      var find = GetSegments(filter);
      if (valid find) {
        list.Add(new PartitionClass(i, filter, find));
        foreach (var s in find)
          s.PartitionIndex = i;
        ++i;
      }
    }
    Partitions = list.Values;
  }

  GetSegments(FilterClass filter) = Results.UniqueSegments.FindSlice(segment => MatchesRule(filter, segment));

  ShowPartitions = Block {
    Paragraph {
      TextHeight: 16 pts;
      "Model: ";
      Style.DQuote {Name};
      BorderB: 1;
    };

    foreach (var partition in Partitions) {
      Paragraph {
        TextHeight: 14 pts;
        SpaceBefore: 6 pts;
        TabStops: [0.35 inch];
        LeftIndent: 2.85 inches;
        FirstIndent: -2.85 inches;
        EachOne;
        ")"
        Tab;
        partition.Filter.Name;
        Tab;
        Span {
          Separator: Space;
          (each partition.Segments).ShowSegment;
        }
      }
    }
  };

  ShowDescription = Block {
    Paragraph {
      TextHeight: 14 pts;
      Name;
    };

    Paragraph {
      Separator: Space;

      var i = 0;
      foreach (var filter in FiltersPlus) {
        var segments = GetSegments(filter);
        if (segments.Length > 0) {
          HBox {
            VAlign: VAligns.Center;
            Margin: 2;
            PaddingLR: 1;
            Border: 0.25 pts {Color: 80%};
            Span {
              Style.MonoFamily;
              HAlign: HAligns.Center;
              if (Numbers) {
                i++;
                i;
              }
              else if (i < Rev.CharacterList.Length)
                Rev.CharacterList[i++];
              else
                System.Assert(false);
            };
            Space*5;
            Span {
              TextHeight: 18 pts;
              Separator: Space;
              (each segments).ShowSegment;
            };
          }
        }
      }
    }
  };
}
//======================================================================

class SingleFilterClass: FilterClass {
  SegmentClass Segment;

  Constructor(SegmentClass segment) {
    super.Constructor(segment.Ipa);
    Segment = segment;
  }

  override Matches(SegmentClass segment) = segment == Segment;
}
//======================================================================

class FeatureMaskClass: FilterClass {
  var Mask,
      Flags;

  Constructor(name, mask, flag) {
    super.Constructor(name);
    Mask  = mask;
    Flags = flag;
  }

  override Matches(SegmentClass segment) = segment.Features.HasFlagMask(Mask, Flags);
}
//======================================================================

class LabiovelarFilterClass: FilterClass {
  Constructor {
    super.Constructor("Labiovelar");
  }

  override Matches(SegmentClass segment) = segment.Features.HasFlagMask(Vowel, NoFeature) and segment.Place == Places.LabialVelar;
}
//======================================================================

class LongShortClass: FilterClass {
  var Root;

  Constructor(root) {
    Root = root;
    super.Constructor("Long & Short " + root.Name);
  }

  override Matches(SegmentClass segment) = segment.Root == Root and segment.Features.HasFlagMask(Vowel Nasal, Vowel);
}
//======================================================================

class RootMaskClass: FeatureMaskClass {
  var Root;

  Constructor(name, mask, flag, root) {
    super.Constructor(name + Space + root, mask, flag);
    Root = root;
  }

  override Matches(SegmentClass segment) = segment.Root == Root and segment.Features.HasFlagMask(Mask, Flags);
}
//======================================================================

class RootVowelClass: FilterClass {
  Constructor() {
    super.Constructor("Root vowel");
  }

  override Matches(SegmentClass segment) = segment.Features.HasFlag(Vowel) and valid segment.Root;
}
//======================================================================

class DiphthongFilterClass: FilterClass {
  var Root;

  Constructor(root) {
    super.Constructor("Root+Diphthongs");
    Root = root;
  }

  override Matches(SegmentClass segment) = segment == Root or (segment.Features.HasFlag(Diphthong) and segment.Root == Root);
}
//======================================================================

class SegmentListClass: FilterClass {
  SegmentClass[] List;

  Constructor(name, SegmentClass[] list) {
    super.Constructor(name);
    List = list;
  }

  override Matches(SegmentClass segment) = List.FindAny(segment);
}
//======================================================================

class VowelListClass: SegmentListClass {
  Constructor(SegmentClass[] list) {
    super.Constructor(list.FirstElement.Ipa, list);
  }

  override Matches(SegmentClass segment) = List.FindAny(segment);
}
//======================================================================

with SegmentGroups {
  NasalVowels         = new FeatureMaskClass("Nasal Vowel", Vowel Nasal, Vowel Nasal);
  RoundedVowels       = new FeatureMaskClass("Rounded Vowel", Vowel Rounded, Vowel Rounded);
  LongVowels          = new FeatureMaskClass("Long Vowel", Vowel LongVowel, Vowel LongVowel);
  ShortVowels         = new FeatureMaskClass("Short Vowel", Vowel LongVowel, Vowel);
  AllRootVowels       = new RootVowelClass;
  Vowels              = new FeatureMaskClass("Vowel", Vowel, Vowel);
  VoicelessStops      = new FeatureMaskClass("Voiceless Stop", Voiced Stop, Stop);
  VoicedStops         = new FeatureMaskClass("Voiced Stop", Voiced Stop, Voiced Stop);
  VoicedAffricates    = new FeatureMaskClass("Voiced Affricate", Voiced Affricate, Voiced Affricate);
  VoicelessAffricates = new FeatureMaskClass("Voiceless Affricate", Voiced Affricate, Affricate);
  NasalConsonants     = new FeatureMaskClass("Nasal Consonant", Nasal, Nasal);
  Rhotics             = new FeatureMaskClass("Rhotic", Rhotic, Rhotic);
  Sibilants           = new FeatureMaskClass("Sibilant", Sibilant, Sibilant);
  Approximants        = new FeatureMaskClass("Approximant", Approximant, Approximant);
  Pulmonics           = new FeatureMaskClass("Pulmonic", Pulmonic, Pulmonic);
  VoicedFricatives    = new FeatureMaskClass("Voiced Fricative", Pulmonic Voiced Fricative, Pulmonic Voiced Fricative);
  VoicelessFricatives = new FeatureMaskClass("Voiceless Fricative", Pulmonic, Pulmonic Fricative);
  Laterals            = new FeatureMaskClass("Lateral", Lateral, Lateral);
  Diphthongs          = new FeatureMaskClass("Diphthong", Diphthong, Diphthong);
  Consonants          = new FeatureMaskClass("Consonant", Vowel, NoFeature);
  Labiovelars         = new LabiovelarFilterClass;
  LongShortRoot       = new LongShortClass(each IPA.ParentVowels);
  NasalRoot           = new RootMaskClass("Nasal", Vowel Nasal LongVowel, Vowel Nasal, each IPA.ParentVowels);
  LongRoot            = new RootMaskClass("Long", Vowel Nasal LongVowel, Vowel LongVowel, each IPA.ParentVowels);
  ShortRoot           = new RootMaskClass("Short", Vowel Nasal LongVowel, Vowel, each IPA.ParentVowels);
  NonSylabicSonorants = new SegmentListClass("Non Sylabic Sonorant", [IPA.Segments.l, IPA.Segments.r, IPA.Segments.n, IPA.Segments.m, IPA.Segments.jg, IPA.Segments.w]);
  Residue             = new FilterClass("Residue");
}
//======================================================================

class VowelsSeparatedRuleClass: RuleClass {
  Constructor {
    super.Constructor("Vowels Separated");

    Add(LongRoot);
    Add(ShortRoot);
    Add(NasalRoot);
    Add(NasalVowels);
    Add(RoundedVowels)
    Add(Vowels);
    Add(Labiovelars);
    Add(VoicelessStops);
    Add(VoicedStops);
    Add(VoicedAffricates);
    Add(VoicelessAffricates);
    Add(NasalConsonants);
    Add(Laterals);
    Add(Rhotics);
    Add(Sibilants);
    Add(Approximants);
    Add(VoicedFricatives);
    Add(VoicelessFricatives);
  }
}
//======================================================================

// This produces a tree with Catalan and Spanish in the same clade
class SegmentTypesRuleClass: RuleClass {
  Constructor {
    super.Constructor("Segment Types");

    Add(NasalVowels);
    Add(RoundedVowels);
    Add(LongVowels);
    Add(AllRootVowels);
    Add(Vowels);
    Add(VoicelessStops);
    Add(VoicedStops);
    Add(VoicedAffricates);
    Add(VoicelessAffricates);
    Add(NasalConsonants);
    Add(Rhotics);
    Add(Sibilants);
    Add(Pulmonics);
  }
}
//======================================================================

class DiphthongRuleClass: RuleClass {
  Constructor {
    super.Constructor("Diphthongs Separated");
    Add(Diphthongs);
  }

  override GetFilterIndex(SegmentClass segment) {
    var c = FilterList.Length;
    if (segment.Features.HasFlag(Diphthong))
      return c;
    FilterList.Add(new SingleFilterClass(segment));
    return c;
  }
}
//======================================================================

class DiphthongPairRuleClass: RuleClass {
  Constructor {
    super.Constructor("Diphthongs Paired with Vowels");
  }

  override void AssignCharacters {
    var count = 0;
    foreach (var segment in Results.UniqueSegments) {
      var dr = segment.Root;
      if (valid dr and segment.Features.HasFlag(Diphthong)) {
        var fi = -1;
        foreach (var f in FilterList) {
          if (f.Matches(segment)) {
            fi = EachIndex;
            break;
          }
        }
        if (fi < 0) {
          SetSegmentCharacter(segment, count);
          SetSegmentCharacter(dr, count);
          Add(new DiphthongFilterClass(dr));
          ++count;
        }
        else
          SetSegmentCharacter(segment, fi);
      }
    }

    foreach (var segment in Results.UniqueSegments) {
      if (segment.CharacterIndex < 0) {
        SetSegmentCharacter(segment, count++);
        Add(new SingleFilterClass(segment));
      }
    }
    GetFilters;
  }
}
//======================================================================

class SingletonRuleClass: RuleClass {
  Constructor() {
    super.Constructor("Each segment gets a different number");
    Numbers = true;
  }

  override void AssignCharacters {
    foreach (var segment in Results.UniqueSegments) {
      SetSegmentCharacter(segment, EachIndex);
      Add(new SingleFilterClass(segment));
    }
    GetFilters;
  }
}
//======================================================================

class Partition1Class: RuleClass {
  Constructor {
    super.Constructor("Linguistically Informed");
    Numbers = true;

    Add(NasalVowels);
    Add(Vowels);
    Add(NasalConsonants);
    Add(NonSylabicSonorants);
    Add(Consonants);
    GetFilters;
  }
}
//======================================================================

class Partition2Class: RuleClass {
  Constructor {
    super.Constructor("Linguistically Informed");
    Numbers = true;

    Add(new VowelListClass([IPA.Segments.ay, IPA.Segments.ai]));
    Add(new VowelListClass([IPA.Segments.e, IPA.Segments.E]));
    Add(new VowelListClass([IPA.Segments.ah, IPA.Segments.A]));
    Add(new VowelListClass([IPA.Segments.u, IPA.Segments.U]));
    Add(new VowelListClass([IPA.Segments.oh, IPA.Segments.O]));
    Add(new VowelListClass([IPA.Segments.euh, IPA.Segments.LongOpenMidBackRounded]));
    Add(new VowelListClass([IPA.Segments.eh, IPA.Segments.Eh]));
    Add(new VowelListClass([IPA.Segments.uu, IPA.Segments.o]));
    Add(NasalVowels);
    Add(Vowels);
    Add(NasalConsonants);
    Add(NonSylabicSonorants);
    Add(Consonants);
    GetFilters;
  }
}
//======================================================================

class PartitionHintClass {
  var            Rate;
  PartitionClass P1,
                 P2;

  Constructor(rate, PartitionClass p1, PartitionClass p2) {
    Rate = rate;
    P1   = p1;
    P2   = p2;
  }

  AddGroup(PartitionClass p) = VBox {
    HAlign: HAligns.Center;
    HBox {
      TextBackground: 90%;
      Span {
        p.Filter.Name;
      };
    };
    HBox {
      Results.ShowFilterSegments(p.Filter, ParAlignments.Center);
    };
  };

  override GetPopup = HBox {
    VAlign: VAligns.Top;
    if (P1 != P2)
      AddGroup(P1);
    HBox {
      MarginLR: 5;
      PaddingLR: 5;
      Background: 90%;
      VBox {
        HAlign: HAligns.Center;
        Lang.Rate;
        Span {
          Bold;
          TextHeight: 14 pts;
          TextDigits: 3;
          Rate;
        }
      };
    };
    AddGroup(P2);
  };
}
//======================================================================

class TransitionClass {
  var       Frequencies,
            Rates;
  RuleClass Rule;

  Constructor(RuleClass rule) {
    Rule = rule;
  }

  RandomArray(max) {
    var list = new ListClass(Rule.Filters.Length);
    foreach (var f in Rule.Filters)
      list.Add(Math.Random(0..1));
    return list.Values;
  }

  void ReadFrequencies {
    // This is temporary until we get actual data

    Frequencies = RandomArray(1);
    var list = new ListClass(Rule.Filters.Length);
    foreach (var f in Rule.Filters)
      list.Add(RandomArray(10));
    Rates = list.Values;
  }

  void StaticFrequencies {
    var list  = new ListClass(Rule.Filters.Length);
    var flist = new ListClass(Rule.Filters.Length);
    foreach (var f0 in Rule.Filters) {
      var s0  = Rule.GetSegments(f0);
      var sum = Math.Sum((each s0).UsedCount);

      flist.Add(sum);

      var t  = Results.TransitionCount;
      var l1 = new ListClass(Rule.Filters.Length);
      foreach (var f1 in Rule.Filters) {
        var s1 = Rule.GetSegments(f1);

        var count = 0;
        foreach (var s0i in s0) {
          foreach (var s1i in s1) {
            var tl = t.GetValue(s0i.Index, s1i.Index);
            if (valid tl)
              count += tl.Length;
          }
        }

        l1.Add(count);
      }
      list.Add(l1.Values);
    }
    Frequencies = flist.Values;
    Rates       = list.Values;
  }
}
//======================================================================

class TranClass {
  var List,
      Percent;

  Constructor(list, percent) {
    List    = list;
    Percent = percent;
  }

  override GetPopup = Frame {
    var first = List.FirstElement;
    Paragraph {
      first.Word1.Padded[first.Index].ShowSegment;
      Tex.to;
      first.Word2.Padded[first.Index].ShowSegment;
    };
    Paragraph {
      List.Length; " transitions";
    };
    Paragraph {
      TextDigits: 1;
      Percent * 100.0; "% of max";
    };

    var count = Math.Min([List.Length, 30]);

    Width: Min([count*3, 6]) inches;

    Paragraph {
      Separator: Space;
      foreach (var p in List[0..count])
        p.ShowDescription(10 pts);
    };

    if (count < List.Length)
      "More...";
  };
}
//======================================================================

class CalcRatesClass {
  TransitionClass Transition;
  RuleClass       Rule;
  var             MaxLine,
                  ArrowGap,
                  GapAngle,
                  LoopRadius,
                  LoopDistance,
                  MaxExtent,
                  MaxRadius,
                  RateScale;

  Constructor(TransitionClass transition) {
    Rule       = transition.Rule;
    Transition = transition;
    ArrowGap   = 10 pts;
    GapAngle   = 80.0 degrees;
  }

  void Calibrate(size) {
    var middle = Point(size.Width * 0.5, size.Height * 0.5);

    MaxExtent    = Min([middle.X, middle.Y]);
    MaxRadius    = MaxExtent * 0.13;
    MaxLine      = MaxRadius * 0.3;
    LoopRadius   = MaxRadius * 0.25;
    LoopDistance = LoopRadius * 0.5;


    var fmax = MaxRadius / Sqrt(Real(Max(Transition.Frequencies))); // Proportional to area, so use SQRT of frequency

    RateScale = MaxLine / Max(Max(each Transition.Rates));

    foreach (var partition in Rule.Partitions) {
      partition.Angle  = (2 * EachIndex *  Graphics.OneEighty / Rule.Partitions.Length) - Graphics.Ninety;
      partition.Radius = Sqrt(Real(Transition.Frequencies[EachIndex])) * fmax;
    }

    var maxradius = 0.0;
    foreach (var partition in Rule.Partitions)
      maxradius = Max([maxradius, partition.Radius + Transition.Rates[EachIndex][EachIndex] * RateScale]);
    maxradius = MaxExtent - maxradius - LoopRadius - LoopDistance - ArrowGap;

    foreach (var partition in Rule.Partitions)
      partition.Center = Graphics.ExtendPoint(middle, maxradius, partition.Angle);
  }

  private MainDiagram(min) = Canvas {
    var size = Size(min, min);

    TransformFit: true;
    Calibrate(size);
    Size: size;

    foreach (var p1 in Rule.Partitions) {
      var pi = EachIndex;
      foreach (var p2 in Rule.Partitions) {
        var  rate = Transition.Rates[pi][EachIndex];
        var  hint = new PartitionHintClass(rate, p1, p2);
        var  line = new LineStyleClass(rate * RateScale, 0.25, 1);
        if (p1 == p2) {
          var c = Graphics.ExtendPoint(p1.Center, p1.Radius + LoopDistance - line.LineSize*0.5, p1.Angle);
          Graphics.CircleArrow(line, c, LoopRadius, p1.Angle - Graphics.OneEighty, GapAngle) {
            Fill: Colors.Black;
            Popup: hint;
          };
        }
        else {
          var angle = Graphics.GetAngle(p1.Center, p2.Center);
          var c1    = Graphics.Adjust(p1.Center, p1.Radius + ArrowGap, angle);
          var c2    = Graphics.Adjust(p2.Center, p2.Radius + ArrowGap, angle + Graphics.OneEighty);

          Graphics.TwoArrowLine(line, c1, c2) {
            Fill: Color(0, 0, 0/*, Integer(128 + rate * RateScale / MaxLine * 127.0)*/);
            Popup: hint;
          };
        }
      }
    }

    foreach (var p1 in Rule.Partitions) {
      var pos   = p1.Center - p1.Radius;
      var fsize = p1.Radius*2;

      Figure {
        Fill: ChartColor(EachIndex);
        Stroke: 0.5 pt;
        Ellipse(Rect(pos, fsize));
        Popup: p1;
      };

      var c = LayoutSize(TestText(p1)).Width;
      CircleText(p1, pos, fsize, p1.Radius * 16 / c);
    }
  };

  TestText(PartitionClass p) = Paragraph {
    TextHeight: 10 pts;
    p.Filter;
  };

  CircleText(PartitionClass p, pos, fsize, textheight) = HBox {
    Position: pos;
    Height: fsize;
    Frame {
      VAlignment: VAligns.Center;
      Width: fsize;
      TextHeight: textheight;
      ParAlignment: ParAlignments.Center;
      p.Filter;
    };
  };

  PartitionDiagram(SizeClass wholesize) = VBox {
    Width: wholesize.Width;
    HAlign: HAligns.Center;

    HBox {
      VAlign: VAligns.Center;

      VBox {
        Table {
          TextHeight: 10 pts;
          Columns: [20 pts, 1 inch];

          foreach (var partition in Rule.Partitions) {
            Row {
              Span {
                EachOne;
                ". ";
              };
              Paragraph {
                LeftIndent: 15 pts;
                FirstIndent: -15 pts;
                Figure {
                  Fill: ChartColor(EachIndex);
                  Ellipse(Rect(0, 10 pts));
                };
                Tab;
                partition.Filter.Name;
              }
            }
          }
        };
      };

      MainDiagram(Min([wholesize.Width, wholesize.Height]));
    };
  };

  GetColor(SegmentClass s) = ChartColor(s.PartitionIndex);// * 30%;

  TranLink(i0, i1) = "Tran{0}:{1}"(i0, i1);

  TranPar(list) = Block {
    var first = list.FirstElement;
    Paragraph {
      list.Length; " transitions: ";

      var s0 = first.Word1.Padded[first.Index];
      s0.ShowSegment;

      Tex.to;
      var s1 = first.Word2.Padded[first.Index];
      s1.ShowSegment;

      LocationMark: TranLink(s0.Index, s1.Index);
    };

    Paragraph {
      Separator: Space;
      foreach (var p in list)
        p.ShowDescription(9 pts);
    };
    Paragraph {
      SpaceBefore: 4 pts;
      SpaceAfter: 4 pts;
      BorderT: 1 {Color: 80%};
    }
  };

  PartitionBlock = Block {
    PartitionBox(Size(DocMetrics.SlideContent.Width, DocMetrics.PageContent.Height * 0.8), true);
    PageBreak;

    Block {
      TextHeight: 9 pts;

      var t = Results.TransitionCount;
      foreach (var s0 in Results.PartSegments) {
        foreach (var s1 in Results.PartSegments) {
          if (s0.Index != s1.Index) {
            var tlist = t.GetValue(s0.Index, s1.Index);
            if (exists tlist && tlist.Length < Info.LinkMin)
              TranPar(tlist);
          }
        }
      }
    }
  };

  PartitionBox(SizeClass framesize, link) = Paragraph {
    var grid   = 0.125 pts;
    var gcolor = 65%;

    var border = 0.5 pts;
    var size   = framesize - border;
    Canvas {
      Border: border;
      Size: framesize;

      var d = size / (Results.PartSegments.Length+1);
      TextHeight: d.Width * 0.5;

      var t   = Results.TransitionCount;
      var max = 1.0 / Results.TransitionMax;
      var y   = d.Height;
      foreach (var s0 in Results.PartSegments) {
        var x = d.Width;
        foreach (var s1 in Results.PartSegments) {
          if (s0.Index != s1.Index) {
            var tlist = t.GetValue(s0.Index, s1.Index);
            if (exists tlist) {
              var f = Integer((1.0 - tlist.Length * max) * 255.0);
              Canvas {
                HAlign: HAligns.Center;
                VAlign: VAligns.Center;
                X: x;
                Y: y;
                Size: d;
                if (f > 0)
                  Background: Color(255, f, f);

                Popup: new TranClass(tlist, tlist.Length*max);

                Span {
                  tlist.Length;
                  if (link && tlist.Length < Info.LinkMin)
                    Link: TranLink(s0.Index, s1.Index);
                }
              };
            }
          }
          x += d.Width;
        }
        y += d.Height;
      }

      y = d.Height;
      var p = 0;
      foreach (var s in Results.PartSegments) {
        Canvas {
          Size: d;
          Background: GetColor(s);
          Width: d.Width;
          HAlign: HAligns.Center;
          Y: y;
          s.ShowSegment;
        };
        if (p != s.PartitionIndex) {
          Canvas {
            Y: y;
            Size: Size(size.Width, grid);
            Background: gcolor;
          };
          p = s.PartitionIndex;
        }
        y += d.Height;
      }

      Canvas {
        Height: d.Height;
        Width: size.Width;

        var x = d.Width;
        p = 0;
        foreach (var s in Results.PartSegments) {
          Canvas {
            Size: d;
            Background: GetColor(s);
            HAlign: HAligns.Center;
            X : x;
            s.ShowSegment;
          };
          if (p != s.PartitionIndex) {
            Canvas {
              X: x;
              Size: Size(grid, size.Height);
              Background: gcolor;
            };
            p = s.PartitionIndex;
          }
          x += d.Width;
        }
      };
    };
  };
}
//======================================================================

with Figures.FrequencyDiagramExperiment {
  Caption = FigureCaption {
    var rule = Results.CalcExperiment.Rule;

    "For the "; Quote{rule.Name}; " model, states were grouped into "; rule.Partitions.Length; " sets. ";
    "Here, the area of the circles is proportional to the estimated equilibrium frequencies for each group. ";
    "The width of the lines is proportional to the estimated rates. ";
    PaperSections.WordTransformation.Note;
  };

  Body = FigureBody {
    Results.CalcExperiment.PartitionDiagram(Size(6.6 inches, 5 inches));
  };
}
//======================================================================

with Figures.FrequencyDiagramStatic {
  Caption = FigureCaption {
    var rule = Results.CalcStatic.Rule;

    "For the "; Quote{rule.Name}; " model, states were grouped into "; rule.Partitions.Length; " sets. ";
    "Here, the area of the circles is proportional to the occurance frequencies for each group. ";
    "The width of the lines is proportional to the rates of transition between the each partition. ";
  };

  Body = FigureBody {
    Results.CalcStatic.PartitionDiagram(Size(6.6 inches, 5 inches));
  };
}
//======================================================================

with Figures.FrequencyBoxStatic {
  Caption = FigureCaption {
    "This chart shows the number of times that each segment (on the left vertical bar) differs from any other other segment in the same cognate set at the same aligned segment position. ";
    "The rates of transitions to gaps and from gaps are ignored. ";
    "The segments are grouped into partitions, represented by the  sections divided by lines. ";
    "Within each partition, the segments are ordered from highest to lowest frequency of occurrance. ";
    "Transition counts are shown with the number in a red box, where the darker reds are larger numbers. ";
    "The chart has diagonal symmetry.";
  };

  Body = FigureBody {
    Results.CalcStatic.PartitionBox(Size(6.6 inches, 5 inches), true);
  };
}
//======================================================================

with Figures.SegmentFrequencies {
  Caption = FigureCaption {
    "Frequency of occurance of segments in the lexicon";
    Citation {References.Phoible};
  };

  Body = FigureBody {
    Results.FrequencyChart(Size(DocMetrics.PageContent.Width, 2 inches));
  };
}
//======================================================================

