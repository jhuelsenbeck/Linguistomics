using Format, Units, SegmentFeatures, Math, Style, LinkTypes;
//======================================================================

class FilterClass {
  field        Name;
  var          CircleName;
  DataSetClass Data;
  RuleClass    Rule;

  Constructor(DataSetClass data, RuleClass rule, name) {
    Data       = data;
    Rule       = rule;
    Name       = name;
    CircleName = name.Substitute(name.FindIndex(c => c == Space), LineBreak);
  }

  virtual Matches(SegmentClass segment) = true;

  override GetLayoutSpan = Span {
    TipAction: this;
    Name;
  };

  override GetLayoutTip = Frame {
    Width: 2 inches;
    Paragraph {
      ParAlignment: ParAlignments.Center;
      TextHeight: 16 pts;
      Border: BorderB(1);
      Name;
    };
    Rule.ShowFilterSegments(Data.UniqueSegments, this, ParAlignments.Left);
  };
}
//======================================================================

class PartitionClass: FactClass {
  field          Name;
  SegmentClass[] Segments;
  PointClass     Center;
  FilterClass    Filter;
  ColorClass     Color;
  var            Index,
                 Radius,
                 Angle,
                 Outer;

  Constructor(index, FilterClass filter, SegmentClass[] segments) {
    super.Constructor(filter.Name);
    Name     = filter.Name;
    Color    = ChartColor(index);
    Index    = index;
    Filter   = filter;
    Segments = segments;
    Link.Connect(this, segments);
  }

  override IconClass GetIcon = Icons.sort;

  override GetLayoutTip = Filter.GetLayoutTip;
}
//======================================================================

abstract class RuleClass {
  DataSetClass           Data;
  ListClass<FilterClass> FilterList;
  FilterClass[]          Filters,
                         FiltersPlus;
  PartitionClass[]       Partitions;
  SegmentClass[]         PartSegments;
  var                    Name,
                         Matrix,
                         Numbers;

  Constructor(DataSetClass data, name) {
    Data       = data;
    Name       = name;
    Numbers    = false;
    FilterList = new(128);
  }

  MatchesRule(FilterClass filter, SegmentClass segment) {
    foreach (var f in FiltersPlus) {
      if (f == filter)
        return f.Matches(segment);
      if (f.Matches(segment))
        return false;
    }
    return false;
  }

  virtual GetFilterIndex(SegmentClass segment) {
    var c = 0;
    foreach (var filter in FiltersPlus) {
      if (MatchesRule(filter, segment))
        return c;
      ++c;
    }
    return c;
  }

  void SetSegmentCharacter(SegmentClass segment) {
    if (not Numbers) {
      if (segment.Index < Nexus.CharacterList.Length)
        segment.CharacterLetter = Nexus.CharacterList[segment.Index];
      else
        System.Assert(false, "Too many characters");
    }
  }

  void GetFilters {
    Filters = FilterList.Values;
    FilterList.Add(new FilterClass(Data, this, "Residue"));
    FiltersPlus = FilterList.Values;
  }

  virtual void AssignCharacters(SegmentClass[] segments) {
    var last = Nexus.CharacterList.Length-1;
    foreach (var segment in segments) {
      var index = GetFilterIndex(segment);
      if (index > last)
        index = last;
      SetSegmentCharacter(segment);
    }
    GetFilters;
  }

  void AssignPartitions(SegmentClass[] segments) {
    var list = new ListClass<PartitionClass>(segments.Length);
    var i    = 0;
    foreach (var filter in FiltersPlus) {
      var find = GetMatching(segments, filter);
      if (valid find) {
        list.Add(new PartitionClass(i, filter, find));
        foreach (var s in find)
          s.PartitionIndex = i;
        ++i;
      }
    }
    Partitions   = list.Values;
    PartSegments = Data.UniqueSegments.Sort(true, ref ComparePartSegments);
  }

  static ComparePartSegments(SegmentClass s0, SegmentClass s1, options) {
    var i = s1.PartitionIndex - s0.PartitionIndex;
    if (i == 0)
      i = s0.UsedCount - s1.UsedCount;
    return i;
  }

  SegmentClass[] GetMatching(SegmentClass[] segments, FilterClass filter) {
    return segments.FindSlice(segment => MatchesRule(filter, segment));
  }

  ShowFilterSegments(SegmentClass[] segments, FilterClass filter, align) = Frame {
    Width: 2 inches;
    Paragraph {
      ParAlignment: align;

      TextHeight: 18 pts;
      var matching = GetMatching(segments, filter);
      if (valid matching) {
        Separator: Space;
        (each matching).ShowSegment;
      }
    }
  };

  ShowLegend(textheight, width) = VBox {
    Table {
      TextHeight: textheight;
      Columns: [textheight*1.7, textheight, width - textheight * 2.7];

      foreach (var partition in Partitions) {
        Row {
          VAlign: VAligns.Center;
          Span {each1; ")"};
          Span {
            TextColor: partition.Color;
            TextHeight: 125%;
            Tex.blackcirc;
          };
          partition.Filter;
        }
      }
    };
  };

  ShowPartitions = Block {
    var th = ExtentWidth * 0.03;
    var tw = th * 0.65;

    Paragraph {
      TextHeight: 20 pts;
      "Model: ";
      Style.DQuote {Name};
    };

    Table {
      TextHeight: th;

      Columns: [tw * 3, tw * 15, tw * 20];
      TextHeight: 12 pts;
      Border: BorderB(1);

      Row {
        Border: BorderB(1);
        Cell {
          ColSpan: 3;
          TextHeight: 16 pts;
        };
      };

      foreach (var partition in Partitions) {
        Row {
          Cell {
            HAlign: HAligns.Right;
            Span {each1; ") "};
            Padding: PadR(3 pts);
          };
          partition.Filter.Name;
          Span {
            Separator: Space;
            (each partition.Segments).ShowSegment;
          };
        };
      }
    };
  };

  ShowDescription(SegmentClass[] segments) = Block {
    Paragraph {
      TextHeight: 14 pts;
      Name;
    };

    Paragraph {
      Separator: Space;

      var i = 0;
      foreach (var filter in FiltersPlus) {
        var matching = GetMatching(segments, filter);
        if (valid matching) {
          HBox {
            VAlign: VAligns.Center;
            Margin: 2;
            Padding: PadLR(1);
            Border: 0.25 pts {Color: 80%};
            Span {
              TextFixed: true;
              HAlign: HAligns.Center;
              if (Numbers) {
                i++;
                i;
              }
              else if (i < Nexus.CharacterList.Length)
                Nexus.CharacterList[i++];
              else
                System.Assert(false);
            };
            Space*5;
            Span {
              TextHeight: 18 pts;
              Separator: Space;
              (each matching).ShowSegment;
            };
          }
        }
      }
    }
  };
}
//======================================================================

class SingleFilterClass: FilterClass {
  SegmentClass Segment;

  Constructor(DataSetClass data, RuleClass rule, SegmentClass segment) {
    super.Constructor(data, rule, segment.Ipa);
    Segment = segment;
  }

  override Matches(SegmentClass segment) = segment == Segment;
}
//======================================================================

class FeatureMaskClass: FilterClass {
  var Mask,
      Flags;

  Constructor(DataSetClass data, RuleClass rule, name, mask, flag) {
    super.Constructor(data, rule, name);
    Mask  = mask;
    Flags = flag;
  }

  override Matches(SegmentClass segment) = segment.Features.HasFlagMask(Mask, Flags);
}
//======================================================================

class SegmentListClass: FilterClass {
  SegmentClass[] List;

  Constructor(DataSetClass data, RuleClass rule, name, SegmentClass[] list) {
    super.Constructor(data, rule, name);
    List = list;
  }

  override Matches(SegmentClass segment) = List.FindAny(segment);
}
//======================================================================

class VowelListClass: SegmentListClass {
  Constructor(DataSetClass data, RuleClass rule, SegmentClass[] list) {
    super.Constructor(data, rule, list.FirstElement.Ipa, list);
  }

  override Matches(SegmentClass segment) = List.FindAny(segment);
}
//======================================================================

class NaturalPartitionClass: RuleClass {
  Constructor(DataSetClass data) {
    super.Constructor(data, "Natural Class");
    Numbers = true;

    FilterList.Add(new FeatureMaskClass(data, this, "Long Vowel", Vowel LongVowel, Vowel LongVowel));
    FilterList.Add(new FeatureMaskClass(data, this, "Nasal Vowel", Vowel Nasal, Vowel Nasal));
    FilterList.Add(new FeatureMaskClass(data, this, "Diphthong", Diphthong, Diphthong));
    FilterList.Add(new FeatureMaskClass(data, this, "Short Vowel", Vowel, Vowel));
    FilterList.Add(new FeatureMaskClass(data, this, "Nasal Consonant", Nasal, Nasal));
    FilterList.Add(new FeatureMaskClass(data, this, "Liquid", Vowel Liquid, Liquid));
    FilterList.Add(new FeatureMaskClass(data, this, "Approximant", Vowel Approximant, Approximant));
    FilterList.Add(new FeatureMaskClass(data, this, "Affricate", Vowel Affricate, Affricate));
    FilterList.Add(new FeatureMaskClass(data, this, "Fricatives", Vowel Fricative, Fricative));
    FilterList.Add(new FeatureMaskClass(data, this, "Consonant", Vowel, NoFeature));
    GetFilters;
    AssignPartitions(data.UniqueSegments);
  }
}
//======================================================================

class PartitionActionClass: ActionClass {
  StatClass      Rate;
  PartitionClass P1,
                 P2;
  RuleClass      Rule;
  DataSetClass   Data;

  Constructor(DataSetClass data, RuleClass rule, StatClass rate, PartitionClass p1, PartitionClass p2) {
    super.Constructor(Actions.ToSource, Rule);
    Rule = rule;
    Data = data;
    Rate = rate;
    P1   = p1;
    P2   = p2;
  }

  AddGroup(PartitionClass p) = VBox {
    HAlign: HAligns.Center;
    HBox {
      TextBackground: 90%;
      Span {
        p.Filter.Name;
      };
    };
    HBox {
      Rule.ShowFilterSegments(Data.UniqueSegments, p.Filter, ParAlignments.Center);
    };
  };

  override GetLayoutTip = HBox {
    VAlign: VAligns.Top;
    AddGroup(P1);
    var t = PadLR(5);
    HBox {
      Margin: t;
      Padding: t;
      VBox {
        HAlign: HAligns.Center;
        Span {Lang.Rate; "%"};
        Rate.ShowBox;
      };
    };
    AddGroup(P2);
  };
}
//======================================================================

class TransitionClass {
  var         MaxRate,
              MaxFrequency;
  MatrixClass Rates;
  RuleClass   Rule;

  Constructor(ResultsClass results, RuleClass rule) {
    Rule = rule;
    var stats = results.TransitionStats;

    var length = stats.Length;
    Rates = new(length, length, null);

    var max = 0.0;
    foreach (var r in stats) {
      var i = each0;
      foreach (var c in r) {
        var f = c?.Upper ?? 0.0;
        if (f > max)
          max = f;
        Rates.SetValue(i, each0, c);
      }
    }
    MaxRate      = max;
    MaxFrequency = 1.0;
  }
}
//======================================================================

class TranActionClass: ActionClass {
  WordPairClass[] List;
  var             Percent;

  Constructor(WordPairClass[] list, percent) {
    super.Constructor(Actions.TipDocument, list);
    List    = list;
    Percent = percent;
  }

  override GetQuery = MatchAny WordClass {
    (each List).Word1 + (each List).Word2;
  };

  ShowSegments(count) = Block {
    var first = List.FirstElement;
    Paragraph {
      first.Word1.Padded[first.Index].ShowSegment;
      Tex.To;
      first.Word2.Padded[first.Index].ShowSegment;
    };
    Paragraph {
      List.Length; " transitions";
    };
    Paragraph {
      TextDigits: 1;
      Percent * 100.0; "% of max";
    };

    Paragraph {
      Separator: Space;
      foreach (var p in List[0..count])
        p.ShowDescription(10 pts);
    };

    if (count < List.Length)
      "More...";
  };

  override GetDocument = Block {
    ShowSegments(List.Length);
  };

  override GetLayoutTip = Frame {
    var count = Math.Min(List.Length, 30);
    Width: Min(count*3, 6) inches;
    ShowSegments(count);
  };
}
//======================================================================

class CalcRatesClass {
  DataSetClass    Data;
  TransitionClass Transition;
  RuleClass       Rule;
  ResultsClass    Results;
  var             MaxLine,
                  ArrowGap,
                  GapAngle,
                  LoopRadius,
                  LoopDistance,
                  MaxExtent,
                  MaxRadius,
                  RateScale;

  Constructor(ResultsClass results, DataSetClass data, RuleClass rule) {
    Results    = results;
    Data       = data;
    Rule       = rule;
    ArrowGap   = 8 pts;
    GapAngle   = 80.0 degrees;
    Transition = new TransitionClass(results, rule);
  }

  void Calibrate(size) {
    var middle = new PointClass(size.Width * 0.5, size.Height * 0.5);

    MaxExtent    = Min(middle.X, middle.Y);
    MaxRadius    = MaxExtent * 0.2;
    MaxLine      = MaxRadius * 0.3;
    LoopRadius   = MaxRadius * 0.25;
    LoopDistance = LoopRadius * 0.5;


    var fmax = MaxRadius / Sqrt(Transition.MaxFrequency); // Proportional to area, so use SQRT of frequency

    RateScale = MaxLine / Transition.MaxRate;

    var mult = Math.PI2 / Rule.Partitions.Length;
    var eq   = Results.EquilibriumFrequencies;

    foreach (var partition in Rule.Partitions) {
      partition.Angle  = mult * each0 - Graphics.Ninety;
      partition.Radius = Sqrt(eq[each0]) * fmax;
    }

    var maxradius = 0.0;
    foreach (var partition in Rule.Partitions)
      maxradius = Max(maxradius, partition.Radius + Transition.Rates.GetValue(each0, each0).Upper * RateScale);
    maxradius = MaxExtent - maxradius - LoopRadius - LoopDistance - ArrowGap;

    foreach (var partition in Rule.Partitions)
      partition.Center = Graphics.ExtendPoint(middle, maxradius, partition.Angle);
  }

  private MainDiagram(min) = Canvas {
    var size = new SizeClass(min);

    TransformFit: true;
    Calibrate(size);
    Size: size;

    foreach (var p1 in Rule.Partitions) {
      var i = each0;

      foreach (var p2 in Rule.Partitions) {
        var rate = Transition.Rates.GetValue(each0, i);
        if (valid rate) {
          var  hover = new PartitionActionClass(Data, Rule, rate, p1, p2);

          if (p1 == p2) {
            var line2 = new LineStyleClass(rate.Mean * RateScale, 0.25, 1);
            var c     = Graphics.ExtendPoint(p1.Center, p1.Radius + LoopDistance - line2.LineSize*0.5, p1.Angle);
            Graphics.CircleLine(line2, c, LoopRadius + line2.LineSize, p1.Angle + Graphics.OneEighty, GapAngle) {
              TipAction: hover;
            };
          }
          else if (each0 < i) {
            var  r    = rate.Mean * RateScale / MaxLine;
            var frac  = Math.Round(Math.Max(1.0, r) * 255.0);
            var angle = Graphics.GetAngle(p1.Center, p2.Center);
            var c1    = Graphics.Adjust(p1.Center, p1.Radius + ArrowGap, angle + Graphics.OneEighty);
            var c2    = Graphics.Adjust(p2.Center, p2.Radius + ArrowGap, angle);

            Graphics.Line(new(rate.Mean * RateScale, 0.25, 1), c1, c2) {
              TipAction: hover;
            }
          }
        }
      }
    }

    foreach (var p1 in Rule.Partitions) {
      var pos   = p1.Center - p1.Radius;
      var fsize = p1.Radius*2;

      Figure {
        Fill: p1.Color;
        Stroke: 0.5 pt;
        Ellipse(new(pos, new(fsize)));
        TipAction: p1;
      };

      var textheight = Math.Min(14 pts, fsize * 0.5);

      HBox {
        Position: pos;
        Height: fsize;
        Frame {
          VAlignment: VAligns.Center;
          Width: fsize;
          TextHeight: textheight;
          TextColor: p1.Color.TextCompliment;
          ParAlignment: ParAlignments.Center;
          p1.Index+1;
        };
      };

    }
  };


  PartitionDiagram = HBox {
    VAlign: VAligns.Center;

    var legend = 1.5 inches;
    Rule.ShowLegend(10 pts, legend);
    MainDiagram(Min(ExtentWidth - legend, ExtentHeight));
  };

  TranLink(i0, i1) = "Tran{0}:{1}"(i0, i1);

  static CompareLength(l1, l2, options) = l2.Length - l1.Length;

  GetSorted {
    var all      = new ListClass(128);
    var t        = Data.TransitionCount;
    var segments = Rule.PartSegments;

    foreach (var s0 in segments) {
      foreach (var s1 in segments) {
        if (s0.Index != s1.Index) {
          var tlist = t.GetValue(s0.Index, s1.Index);
          if (valid tlist and tlist.Length < Info.LinkMin)
            all.Add(tlist);
        }
      }
    }

    return all.Sort(true, ref CompareLength);
  }

}
//======================================================================

