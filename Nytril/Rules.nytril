using Format, Units, FeatureSet, Math;
//======================================================================

class FilterClass {
  var Name,
      Color;

  Constructor(name) {
    Name = name;
  }

  virtual Matches(segment) = true;
}
//======================================================================

abstract class RuleClass {
  var Name,
      Letter,
      Symbol,
      Filters;

  Constructor(name) {
    Name    = name;
    Letter  = "Kappa";
    Symbol  = Tex.kappa;
  }

  void InitFilters {
    foreach (var filter in Filters)
      filter.Color = ChartColor(EachIndex);
  }

  MatchesRule(filter, segment) {
    foreach (var f in Filters) {
      if (f == filter)
        return f.Matches(segment);
      if (f.Matches(segment))
        return false;
    }
    return false;
  }

  FindRule(segment) {
    if (segment.Punctuation)
      return null;

    foreach (var f in Filters) {
      if (f.Matches(segment))
        return f;
    }
    return null;
  }

  virtual ShowDescription = Block {
    Paragraph {
      TextHeight: 14 pts;
      BorderB: 1 pt;
      SpaceAfter: 10 pts;
      Letter;
      "({0})"(Symbol);
      Tab;
      Name;
    }
  };

  ShowFile = TextBlock {
    Span {
      Letter;
      ":";
      Span {
        Separator:",";
        ShowGroup(each Filters);
      };
    }
  };

  ShowLegend = Paragraph {
    Separator: Space*2;
    foreach (var filter in Filters) {
      Span {
        Canvas {
          Border: 0.25;
          Width: 10 pts;
          Height: 8 pts;
          Background: filter.Color;
        };
        Space;
        filter.Name;
      }
    }
  };

  GetSegments(filter) = FindSlice(Results.DisplaySegments, segment => MatchesRule(filter, segment));

  ShowGroup(g) = Span {
    "(";
    (each GetSegments(g)).ShowCharacter;
    ")";
  };

  override ShowDescription = Block {
    Table {
      PaddingLR: 1;
      Columns: [15 pts, 1.4 inches, DocMetrics.PageContent.Width - 1.55 inches];
      Row {
        Bold;
        Style.TitleBackground;
        "#";
        Lang.Filter;
        Lang.Segments;
      };

      var i = 0;
      foreach (var filter in Filters) {
        var segments = GetSegments(filter);
        if (segments.Length > 0) {
          Row {
            Cell {
              Style.MonoFamily;
              Style.TitleBackground;
              Bold;
              HAlign: HAligns.Center;
              Nexus.CharacterList[i++];
            };
            filter.Name;
            Cell {
              TextHeight: 14 pts;
              Span {
                Separator: Space;
                (each segments).ShowSegment;
              };
            };
          };
        }
      }
    }
  };
}
//======================================================================

class SingleClass: FilterClass {
  var Segment;

  Constructor(segment) {
    super.Constructor(segment.Ipa);
    Segment = segment;
  }

  override Matches(segment) = segment == Segment;
}
//======================================================================

class FeatureMaskClass: FilterClass {
  var Mask,
      Flags;

  Constructor(name, mask, flag) {
    super.Constructor(name);
    Mask  = mask;
    Flags = flag;
  }

  override Matches(segment) = segment.Features.HasFlagMask(Mask, Flags);
}
//======================================================================

class LabiovelarFilterClass: FilterClass {
  Constructor {
    super.Constructor("Labiovelar");
  }

  override Matches(segment) = segment.Features.HasFlagMask(Vowel, NoFeature) and segment.Place == Places.LabialVelar;
}
//======================================================================

class LongShortClass: FilterClass {
  var Root;

  Constructor(root) {
    Root = root;
    super.Constructor("Long & Short " + root.Name);
  }

  override Matches(segment) = segment.Root == Root and segment.Features.HasFlagMask(Vowel Nasal, Vowel);
}
//======================================================================

class NasalClass: FilterClass {
  var Root;

  Constructor(root) {
    Root = root;
    super.Constructor("Nasal " + root.Name);
  }

  override Matches(segment) = segment.Root == Root and segment.Features.HasFlag(Vowel Nasal);
}
//======================================================================

class RootVowelClass: FilterClass {
  Constructor() {
    super.Constructor("Root vowels");
  }

  override Matches(segment) = segment.Features.HasFlag(Vowel) and segment.Root != RootVowels.None;
}
//======================================================================

Residue             = new FilterClass("Residue");
NasalVowels         = new FeatureMaskClass("Nasal Vowel", Vowel Nasal, Vowel Nasal);
RoundedVowels       = new FeatureMaskClass("Rounded Vowel", Vowel Rounded, Vowel Rounded);
LongVowels          = new FeatureMaskClass("Long Vowel", Vowel LongVowel, Vowel LongVowel);
ShortVowels         = new FeatureMaskClass("Short Vowel", Vowel LongVowel, Vowel);
AllRootVowels       = new RootVowelClass;
Vowels              = new FeatureMaskClass("Vowel", Vowel, Vowel);
VoicelessStops      = new FeatureMaskClass("Voiceless Stop", Voiced Stop, Stop);
VoicedStops         = new FeatureMaskClass("Voiced Stop", Voiced Stop, Voiced Stop);
VoicedAffricates    = new FeatureMaskClass("Voiced Affricate", Voiced Affricate, Voiced Affricate);
VoicelessAffricates = new FeatureMaskClass("Voiceless Affricate", Voiced Affricate, Affricate);
NasalConsonants     = new FeatureMaskClass("Nasal Consonant", Nasal, Nasal);
Rhotics             = new FeatureMaskClass("Rhotic", Rhotic, Rhotic);
Sibilants           = new FeatureMaskClass("Sibilants", Sibilant, Sibilant);
Approximants        = new FeatureMaskClass("Approximant", Approximant, Approximant);
Pulmonics           = new FeatureMaskClass("Pulmonic", Pulmonic, Pulmonic);
VoicedFricatives    = new FeatureMaskClass("Voiced Fricatives", Pulmonic Voiced Fricative, Pulmonic Voiced Fricative);
VoicelessFricatives = new FeatureMaskClass("Voiceless Fricatives", Pulmonic, Pulmonic Fricative);
Laterals            = new FeatureMaskClass("Lateral", Lateral, Lateral);
Labiovelars         = new LabiovelarFilterClass;


LongShortRoot = new LongShortClass(each RootVowels[1..]);
NasalRoot     = new NasalClass(each RootVowels[1..]);
//======================================================================


class GroupRuleClass: RuleClass {
  Constructor {
    super.Constructor("Clusters");

    Filters = LongShortRoot + NasalRoot + [
      NasalVowels,
      RoundedVowels,
      Vowels,
      Labiovelars,
      VoicelessStops,
      VoicedStops,
      VoicedAffricates,
      VoicelessAffricates,
      NasalConsonants,
      Laterals,
      Rhotics,
      Sibilants,
      Approximants,
      VoicedFricatives,
      VoicelessFricatives,
      Residue,
    ];
    InitFilters;
  }
}
//======================================================================

// This produces a tree with Catalan and Spanish in the same clade
class SimpleRuleClass: RuleClass {
  Constructor {
    super.Constructor("Simple");

    Filters = [
      NasalVowels,
      RoundedVowels,
      LongVowels,
      Vowels,
      VoicelessStops,
      VoicedStops,
      VoicedAffricates,
      VoicelessAffricates,
      NasalConsonants,
      Rhotics,
      Sibilants,
      Pulmonics,
      Residue,
    ];
    InitFilters;
  }
}
//======================================================================

class ExRuleClass: RuleClass {
  Constructor {
    super.Constructor("Ex");

    Filters = [
      NasalVowels,
      RoundedVowels,
      LongVowels,
      AllRootVowels,
      Vowels,
      Labiovelars,
      VoicelessStops,
      VoicedStops,
      VoicedAffricates,
      VoicelessAffricates,
      NasalConsonants,
      Laterals,
      Rhotics,
      Sibilants,
      Approximants,
      VoicedFricatives,
      VoicelessFricatives,
      Residue,
    ];
    InitFilters;
  }
}
//======================================================================
// Here is the active rule group

//Rule = new GroupRuleClass;
//Rule = new SimpleRuleClass;
Rule = new ExRuleClass;
//======================================================================

