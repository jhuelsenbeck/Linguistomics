using Format, Units, SegmentFeatures, LinkTypes;
//======================================================================

class PartitionClass: FactClass {
  field string       Name;
  var SegPartClass[] Segments;
  var PointClass     Center;
  var ColorClass     Color,
                     TextColor;
  var                Marker,
                     Index,
                     Radius,
                     Angle,
                     Outer;

  Constructor(index, name, SegPartClass[] segments) {
    super.Constructor(guid.FromHash(name));
    Name      = name;
    Color     = ChartColor(index);
    Marker    = Markers.Dot(Color);
    TextColor = Color.TextCompliment;
    Index     = index;
    Segments  = segments;

    foreach (var s in segments)  {
      s.SetPartition(this, index);
      Link.Connect(this, s.Segment);
    }
  }

  override IconClass GetIcon = Icons.sort;

  ShowFilterSegments(align) = Frame(PaperStyle.SegmentWidth) {
    Paragraph {
      ParAlignment: align;
      TextHeight: 18 pts;
      Separator: Space;
      (each Segments).ShowSegment;
    }
  };

  override GetLayoutTip = Frame(PaperStyle.SegmentWidth) {
    Paragraph(BorderB(1)) {
      ParAlignment: ParAlignments.Center;
      TextHeight: 16 pts;
      Name;
    };
    ShowFilterSegments(ParAlignments.Left);
  };

  override GetLayoutSpan = Span {
    TipAction: this;
    Name;
  };
}
//======================================================================

class PartitionInfoClass {
  var Name,
      SegmentIndices;

  Constructor(name, segments) {
    Name           = name;
    SegmentIndices = segments;
  }
}

//======================================================================

class FilterClass {
  field string  Name;
  var RuleClass Rule;

  Constructor(RuleClass rule, name) {
    Rule = rule;
    Name = name;
  }

  virtual bool Matches(SegmentClass segment) = true;

  override GetLayoutSpan = Span {
    TipAction: this;
    Name;
  };
}
//======================================================================

abstract class RuleClass {
  var ListClass<FilterClass> FilterList;
  var FilterClass[]          Filters,
                             FiltersPlus;
  var PartitionClass[]       Partitions;
  var SegPartClass[]         Segments;
  var                        Name,
                             Matrix,
                             Numbers;

  Constructor(name) {
    Name       = name;
    Numbers    = false;
    FilterList = new(128);
  }

  void Init(SegPartClass[] segments) {
    Filters = FilterList.ToArray;
    FilterList.Add(new FilterClass(this, "Residue"));
    FiltersPlus = FilterList.ToArray;

    var list = new ListClass<PartitionClass>(segments.Length);
    var i    = 0;
    foreach (var filter in FiltersPlus) {
      var find = GetMatching(segments, filter);
      if (find is valid) {
        var part = new PartitionClass(i, filter.Name, find);
        list.Add(part);
        ++i;
      }
    }
    Partitions = list.ToArray;
    Segments   = segments.ToSortedArray(true, @ComparePartSegments);
  }

  bool MatchesRule(FilterClass filter, SegmentClass segment) {
    foreach (var f in FiltersPlus) {
      if (f == filter)
        return f.Matches(segment);
      if (f.Matches(segment))
        return false;
    }
    return false;
  }

  virtual int GetFilterIndex(SegmentClass segment) {
    var c = 0;
    foreach (var filter in FiltersPlus) {
      if (MatchesRule(filter, segment))
        return c;
      ++c;
    }
    return c;
  }

  static int ComparePartSegments(SegPartClass s0, SegPartClass s1) {
    var i = s1.PartitionIndex - s0.PartitionIndex;
    if (i == 0)
      i = s0.UsedCount - s1.UsedCount;
    return i;
  }

  SegPartClass[] GetMatching(SegPartClass[] segments, FilterClass filter) {
    return segments.FindSlice(part => MatchesRule(filter, part.Segment));
  }

  ShowLegend(textheight, width, padding) = VBox(width, null, padding) {
    Table(null, null, [textheight*1.7, textheight, width - textheight*2.7]) {
      PaperStyle.SansSerif;
      TextHeight: textheight;

      foreach (var partition in Partitions) {
        Row {
          VAlign: VAligns.Center;
          Span {each1; ")"};
          Span {
            TextColor: partition.Color;
            TextHeight: 125%;
            Tex.blackcirc;
          };
          partition;
        }
      }
    };
  };

  ShowBlockLegend(PartitionClass[] partitions, textheight) = Frame {
    Paragraph {
      ParAlignment: ParAlignments.Center;
      Separator: Space*4;
      TextHeight: textheight;
      foreach (var p in partitions) {
        HBox {
          VAlign: VAligns.Center;
          Separation: 3 pts;
          Canvas (textheight, textheight) {
            BorderRadius: PaperStyle.BorderSize;
            Background: p.Color;
          };
          p;
        }
      }
    }
  };

  GetCaption(ContentStyleClass style) = Span {
    "Model: ";
    style.DQuote {Name};
  };

  ShowPartitions(textheight) = Block {
    Table(BorderB(1), null, [textheight * 3, textheight * 10, textheight * 15]) {
      TextHeight: textheight;

      Row(BorderB(1)) {
        Cell(null, 3);
      };

      foreach (var partition in Partitions) {
        Row {
          Cell(PadR(3 pts)) {
            HAlign: HAligns.Right;
            Span {each1; ") "};
          };
          Cell(PadR(10 pts)) {
            partition.Name;
          };

          Span {
            Separator: Space;
            (each partition.Segments).ShowSegment;
          };
        };
      }
    };
  };

  ShowDescription(SegPartClass[] segments) = Block {
    Paragraph {
      TextHeight: 14 pts;
      Name;
    };

    Paragraph {
      Separator: Space;

      var i = 0;
      foreach (var filter in FiltersPlus) {
        var matching = GetMatching(segments, filter);
        if (matching is valid) {
          HBox(null, null, new EdgeClass(0.25 pts, 1, 80%)) {
            VAlign: VAligns.Center;
            Margin: 2;
            Span {
              TextFixed: true;
              if (Numbers) {
                i++;
                i;
              }
              else if (i < Nexus.CharacterList.Length)
                Nexus.CharacterList[i++];
              else
                System.Assert(false);
            };
            Space*5;
            Span {
              TextHeight: 18 pts;
              Separator: Space;
              (each matching).ShowSegment;
            };
          }
        }
      }
    }
  };
}
//======================================================================

class SingleFilterClass: FilterClass {
  var SegmentClass Segment;

  Constructor(RuleClass rule, SegmentClass segment) {
    super.Constructor(rule, segment.Ipa);
    Segment = segment;
  }

  override bool Matches(SegmentClass segment) = segment == Segment;
}
//======================================================================

class FeatureMaskClass: FilterClass {
  var Mask,
      Flags;

  Constructor(RuleClass rule, name, mask, flag) {
    super.Constructor(rule, name);
    Mask  = mask;
    Flags = flag;
    rule.FilterList.Add(this);
  }

  override bool Matches(SegmentClass segment) = segment.Features.HasFlagMask(Mask, Flags);
}
//======================================================================

class SegmentListClass: FilterClass {
  var SegmentClass[] List;

  Constructor(RuleClass rule, name, SegmentClass[] list) {
    super.Constructor(rule, name);
    List = list;
  }

  override bool Matches(SegmentClass segment) = List.FindElementIndex(segment) >= 0;
}
//======================================================================

class VowelListClass: SegmentListClass {
  Constructor(RuleClass rule, SegmentClass[] list) {
    super.Constructor(rule, list.FirstElement.Ipa, list);
  }

  override bool Matches(SegmentClass segment) = List.FindElementIndex(segment) >= 0;
}
//======================================================================

class NaturalPartitionClass: RuleClass {
  Constructor {
    super.Constructor("Natural Class");
    Numbers = true;

    new FeatureMaskClass(this, "Long Vowel", Vowel LongVowel, Vowel LongVowel);
    new FeatureMaskClass(this, "Nasal Vowel", Vowel Nasal, Vowel Nasal);
    new FeatureMaskClass(this, "Diphthong", Diphthong, Diphthong);
    new FeatureMaskClass(this, "Short Vowel", Vowel, Vowel);
    new FeatureMaskClass(this, "Nasal Consonant", Nasal, Nasal);
    new FeatureMaskClass(this, "Liquid", Vowel Liquid, Liquid);
    new FeatureMaskClass(this, "Approximant", Vowel Approximant, Approximant);
    new FeatureMaskClass(this, "Affricate", Vowel Affricate, Affricate);
    new FeatureMaskClass(this, "Fricatives", Vowel Fricative, Fricative);
    new FeatureMaskClass(this, "Stops", Vowel, NoFeature);
  }
}
//======================================================================

class PartitionActionClass: ActionClass {
  var StatClass      Rate;
  var PartitionClass P1,
                     P2;

  Constructor(RuleClass rule, StatClass rate, PartitionClass p1, PartitionClass p2) {
    super.Constructor(Actions.ToSource, rule);
    Rate = rate;
    P1   = p1;
    P2   = p2;
  }

  AddGroup(PartitionClass p) = VBox {
    HAlign: HAligns.Center;
    HBox {
      TextBackground: 90%;
      Span {
        p.Name;
      };
    };
    HBox {
      p.ShowFilterSegments(ParAlignments.Center);
    };
  };

  override GetLayoutTip = HBox {
    VAlign: VAligns.Top;
    AddGroup(P1);
    var t = PadLR(5);
    HBox(null, null, t) {
      Margin: t;
      VBox {
        HAlign: HAligns.Center;
        Span {Lang.Rate; "%"};
        Rate.ShowBox;
      };
    };
    AddGroup(P2);
  };
}
//======================================================================

class TransitionClass {
  var             MaxRate,
                  MaxFrequency;
  var MatrixClass Rates;
  var RuleClass   Rule;

  Constructor(ResultsClass results, RuleClass rule) {
    Rule = rule;
    var stats = results.TransitionStats;
    var count = stats.Rows;
    Rates = new(count, count, null);

    var max = 0.0;
    for (int i = 0; i < count; ++i) {
      for (int j = 0; j < count; ++j) {
        var c = stats[i, j];
        var f = c?.Upper ?? 0.0;
        if (f > max)
          max = f;
        Rates.SetValue(i, j, c);
      }
    }
    MaxRate      = max;
    MaxFrequency = 1.0;
  }
}
//======================================================================

class TranActionClass: ActionClass {
  var WordPairClass[] List;
  var                 Percent;

  Constructor(WordPairClass[] list, percent) {
    super.Constructor(Actions.TipDocument, list);
    List    = list;
    Percent = percent;
  }

  override GetQuery = MatchAny(WordClass) {
    (each List).Word1 + (each List).Word2;
  };

  ShowSegments(count) = Block {
    var first = List.FirstElement;
    Paragraph {
      first.Word1.Padded[first.Index].ShowSegment;
      Tex.To;
      first.Word2.Padded[first.Index].ShowSegment;
    };
    Paragraph {
      List.Length; " transitions";
    };
    Paragraph {
      TextDigits: 1;
      Percent * 100.0;
      Lang.PercentOfMax;
    };

    Paragraph {
      Separator: Space;
      foreach (var p in List[0..count])
        p.ShowDescription(10 pts);
    };

    if (count < List.Length)
      "More...";
  };

  override GetDocument = Block {
    ShowSegments(List.Length);
  };

  override GetLayoutTip {
    var count = Math.Min(List.Length, 30);
    return Frame(Math.Min(count*3, 6) inches) {
      ShowSegments(count);
    };
  }
}
//======================================================================

class AlignSortClass {
  var AlignDataClass  Data;
  var AlignIndexClass Congate;

  Constructor(AlignDataClass data, AlignIndexClass cognate) {
    Data    = data;
    Congate = cognate;
  }
}

//======================================================================

class RateClass: ActionClass {
  var AlignedCountClass Count;
  var SegPartClass      S0,
                        S1;
  var SegmentFeatures   F0,
                        F1;
  var                   Original,
                        Rate,
                        Reverse,
                        Direction;
  var bool              Diagonal,
                        Symmetric;

  Constructor(AlignedCountClass count, SegPartClass s0, SegPartClass s1, rate, reverse, bool symmetric, bool diagonal) {
    super.Constructor(Actions.TipDocument, s0);

    Count     = count;
    S0        = s0;
    S1        = s1;
    F0        = s0.Features;
    F1        = s1.Features;
    Original  = rate;
    Rate      = GetLogRate(rate);
    Reverse   = GetLogRate(reverse);
    Direction = Rate - Reverse;
    Symmetric = symmetric;
    Diagonal  = diagonal;
  }

  static int CompareRate(RateClass a0, RateClass a1) = a0.Rate.Compare(a1.Rate);

  static int CompareDirection(RateClass a0, RateClass a1) = a0.Direction.Compare(a1.Direction);

  static bool SortDescending = true;

  static GetLogRate(r) {
    if (r < 0)
      return Math.Min(0, -11 - Math.Log(-r, 10));
    else if (r > 0)
      return Math.Max(0, 11 + Math.Log(r, 10));
    return 0;
  }

  bool IsPair(ipa0, ipa1) {
    return S0.Segment.Ipa == ipa0 and S1.Segment.Ipa == ipa1;
  }

  static ColorClass Greenish(frac) {
    return ColorClass.FromHSLA(124, 0.8, frac);
  }

  static ColorClass Redish(frac) {
    return ColorClass.FromHSLA(9, 0.8, frac);
  }

  ColorClass RateColor {
    var r = 1.0 - Rate * (Diagonal ? Count.DiagFactor : Count.RateFactor);
    return r < 0 ? Redish(-r) : Greenish(r);
  }

  ColorClass DirectionColor {
    var r = 1.0 - Direction * Count.DirFactor;
    return r < 0 ? Redish(-r) : Greenish(r);
  }

  ShowPartition(SegPartClass s, textheight) = Canvas(textheight * 2.5) {
    BorderRadius: PaperStyle.BorderSize;
    HAlign: HAligns.Center;
    Background: s.Partition.Color;
    TextColor: s.Partition.TextColor;
    s.ShowSegment;
  };

  ShowBox(textheight) = HBox {
    TextHeight: textheight;
    VAlign: VAligns.Center;
    ShowPartition(S0, textheight);
    Space;
    Span {
      TipAction: this;
      Symmetric ? Tex.leftrightarrow : Tex.rightarrow;
    };
    Space;
    ShowPartition(S1, textheight);
    Tip: this;
  };

  override GetLayoutSpan = ShowBox(11 pts);

  private ShowNumber(name, number) = Paragraph {
    name;
    ": ";
    Span {
      TextDigits: 5;
      number;
    };
  };

  GetExamples(int max) = Block {
    TextHeight: 14 pts;
    GetLayoutSpan;
    Paragraph {
      "Value: ";
      TextScientific: true;
      TextDigits: 2;
      Original;
    };

    ShowNumber(RateDescriptor(Lang.RateFactor), Rate);
    if (!Symmetric) {
      ShowNumber(RateDescriptor("Reverse Factor"), Reverse);
      Span {
        var c = DirectionColor;
        TextBackground: c;
        TextColor: c.TextCompliment;
        ShowNumber(RateDescriptor("Direction"), Direction);
      }
    }

    var sorted = GetList;
    max = Math.Min(sorted.Length, max);
    if (sorted is valid) {
      Paragraph {
        SpaceBefore: 6 pts;
        "Examples:";
      };

      Paragraph {
        Separator: Space;
        for (var i = 0; i < max; ++i) {
          var s = sorted[i];
          new AlignPairClass(Count.Results.Data, s.Congate).ShowFigureData(s.Congate, s.Data);
        }
      };
    }
  };

  override GetLayoutTip = GetExamples(10);

  override GetDocument = GetExamples(100);

  static int CompareProb(AlignSortClass s1, AlignSortClass s2) = s1.Data.Prob.Compare(s2.Data.Prob);

  ListClass<AlignSortClass> GetList {
    // Find cognate sets that have the first segment in one language and the second in another language

    var i0   = S0.Index;
    var i1   = S1.Index;
    var list = new ListClass<AlignSortClass>(1024);

    foreach (var cognate in Count.Results.Alignments) {
      AlignDataClass found = null;

      foreach (var alignment in cognate.Alignments) {
        foreach (var w1 in alignment.WordSet) {
          foreach (var seg in w1) {
            if (seg == i0) {
              var ni = each0;
              foreach (var w2 in alignment.WordSet) {
                if (w2[ni] == i1) {
                  found = alignment;
                  break;
                }
              }
            }
            if (found is valid)
              break;
          }
          if (found is valid)
            break;
        }
        if (found is valid)
          break;
      }

      if (found is valid)
        list.Add(new(found, cognate));
    }
    list.Sort(true, @CompareProb);
    return list;
  }
}

//======================================================================

class CalcRatesClass {
  var DataSetClass    Data;
  var TransitionClass Transition;
  var RuleClass       Rule;
  var ResultsClass    Results;
  var                 MaxLine,
                      ArrowGap,
                      GapAngle,
                      LoopRadius,
                      LoopDistance,
                      MaxExtent,
                      MaxRadius,
                      RateScale;

  Constructor(ResultsClass results) {
    Results    = results;
    Data       = results.Data;
    Rule       = results.Rule;
    ArrowGap   = 8 pts;
    GapAngle   = 80.0 degrees;
    Transition = new TransitionClass(results, Rule);
  }

  void Calibrate(SizeClass size) {
    var middle = new PointClass(size.Width * 0.5, size.Height * 0.5);

    MaxExtent    = Math.Min(middle.X, middle.Y);
    MaxRadius    = MaxExtent * 0.2;
    MaxLine      = MaxRadius * 0.3;
    LoopRadius   = MaxRadius * 0.25;
    LoopDistance = LoopRadius * 0.5;


    var fmax = MaxRadius / Math.Sqrt(Transition.MaxFrequency); // Proportional to area, so use SQRT of frequency

    RateScale = MaxLine / Transition.MaxRate;

    var mult = Math.PI2 / Rule.Partitions.Length;
    var eq   = Results.EquilibriumFrequencies;

    foreach (var partition in Rule.Partitions) {
      partition.Angle  = mult * each0 - Graphics.Ninety;
      partition.Radius = Math.Sqrt(eq[each0]) * fmax;
    }

    var maxradius = 0.0;
    foreach (var partition in Rule.Partitions)
      maxradius = Math.Max(maxradius, partition.Radius + Transition.Rates[each0, each0].Upper * RateScale);
    maxradius = MaxExtent - maxradius - LoopRadius - LoopDistance - ArrowGap;

    foreach (var partition in Rule.Partitions)
      partition.Center = Graphics.ExtendPoint(middle, maxradius, partition.Angle);
  }

  private MainDiagram(min) = Canvas(min, min) {
    TransformFit: true;
    PaperStyle.SansSerif;

    Calibrate(new(min));

    foreach (var p1 in Rule.Partitions) {
      var i = each0;

      foreach (var p2 in Rule.Partitions) {
        var rate = Transition.Rates[each0, i];
        if (rate is valid) {
          var  hover = new PartitionActionClass(Rule, rate, p1, p2);

          if (p1 == p2) {
            var line2 = new LineStyleClass(rate.Mean * RateScale, 0.25, 1);
            var c     = Graphics.ExtendPoint(p1.Center, p1.Radius + LoopDistance - line2.LineSize*0.5, p1.Angle);
            Graphics.CircleLine(line2, c, LoopRadius + line2.LineSize, p1.Angle + Graphics.OneEighty, GapAngle) {
              TipAction: hover;
            };
          }
          else if (each0 < i) {
            var angle = Graphics.GetAngle(p1.Center, p2.Center);
            var c1    = Graphics.Adjust(p1.Center, p1.Radius + ArrowGap, angle + Graphics.OneEighty);
            var c2    = Graphics.Adjust(p2.Center, p2.Radius + ArrowGap, angle);

            Graphics.Line(new(rate.Mean * RateScale, 0.25, 1), c1, c2) {
              TipAction: hover;
            }
          }
        }
      }
    }

    foreach (var p1 in Rule.Partitions) {
      var pos        = p1.Center - p1.Radius;
      var fsize      = p1.Radius*2;
      var textheight = Math.Min(14 pts, fsize * 0.5);

      Shape(p1.Color, 0.5 pt) {
        EllipsePath(new(pos, new(fsize)));
        TipAction: p1;
      };

      Canvas(fsize, fsize) {
        X: pos.X;
        Y: pos.Y;
        HAlign: HAligns.Center;
        VAlign: VAligns.Center;
        Span {
          TextHeight: textheight;
          TextColor: p1.Color.TextCompliment;
          p1.Index+1;
        };
      };
    }
  };


  PartitionDiagram = HBox {
    VAlign: VAligns.Center;

    var legend = 1.5 inches;
    Rule.ShowLegend(10 pts, legend, 0);
    MainDiagram(Math.Min(ExtentWidth - legend, ExtentHeight));
  };

  TranLink(i0, i1) = "Tran{0}:{1}"(i0, i1);
}
//======================================================================

