using Format, Units, FeatureSet, Math, Style;
//======================================================================

class FilterClass {
  field        Name;
  ResultsClass Results;

  Constructor(ResultsClass results, name) {
    Results = results;
    Name    = name;
  }

  virtual Matches(SegmentClass segment) = true;

  override GetLayoutDoc = Span {
    Hover: new HoverClass(this, HoverTypes.Tip);
    Name;
  };

  override GetLayoutTip = Frame {
    Width: 2 inches;
    Paragraph {
      ParAlignment: ParAlignments.Center;
      TextHeight: 16 pts;
      BorderB: 1;
      Name;
    };
    Results.ShowFilterSegments(Results.UniqueSegments, this, ParAlignments.Left);
  };
}
//======================================================================

class PartitionClass: FactClass {
  field          Name;
  SegmentClass[] Segments;
  var            Index,
                 Center,
                 Radius,
                 Angle,
                 Outer;
  FilterClass    Filter;

  Constructor(index, FilterClass filter, SegmentClass[] segments) {
    super.Constructor(filter.Name);
    Name     = filter.Name;
    Index    = index;
    Filter   = filter;
    Segments = segments;
    LinkTypes.Link.Connect(this, segments);
  }

  override GetLayoutTip = Filter.GetLayoutTip;
}
//======================================================================

abstract class RuleClass {
  ResultsClass     Results;
  ListClass        FilterList;
  FilterClass[]    Filters,
                   FiltersPlus;
  PartitionClass[] Partitions;
  var              Name,
                   Matrix,
                   Numbers;

  Constructor(ResultsClass results, name) {
    Results    = results;
    Name       = name;
    Numbers    = false;
    FilterList = new ListClass(128);
  }

  void Add(FilterClass filter) {
    FilterList.Add(filter);
  }

  MatchesRule(FilterClass filter, SegmentClass segment) {
    foreach (var f in FiltersPlus) {
      if (f == filter)
        return f.Matches(segment);
      if (f.Matches(segment))
        return false;
    }
    return false;
  }

  virtual GetFilterIndex(SegmentClass segment) {
    var c = 0;
    foreach (var filter in FiltersPlus) {
      if (MatchesRule(filter, segment))
        return c;
      ++c;
    }
    return c;
  }

  void SetSegmentCharacter(SegmentClass segment, index) {
    segment.CharacterIndex = index;
    if (Numbers)
      segment.CharacterLetter = index;
    else if (index < Rev.CharacterList.Length)
      segment.CharacterLetter = Rev.CharacterList[index];
    else
      System.Assert(false, "Too many characters");
  }

  void GetFilters {
    Filters = FilterList.Values;
    Add(new FilterClass(Results, "Residue"));
    FiltersPlus = FilterList.Values;
  }

  virtual void AssignCharacters(SegmentClass[] segments) {
    var last = Rev.CharacterList.Length-1;
    foreach (var segment in segments) {
      var index = GetFilterIndex(segment);
      if (index > last)
        index = last;
      SetSegmentCharacter(segment, index);
    }
    GetFilters;
  }

  void AssignPartitions(SegmentClass[] segments) {
    var list = new ListClass(segments.Length, PartitionClass);
    var i    = 0;
    foreach (var filter in FiltersPlus) {
      var find = GetMatching(segments, filter);
      if (valid find) {
        list.Add(new PartitionClass(i, filter, find));
        foreach (var s in find)
          s.PartitionIndex = i;
        ++i;
      }
    }
    Partitions = list.Values;
  }

  SegmentClass[] GetMatching(SegmentClass[] segments, FilterClass filter) = segments.FindSlice(segment => MatchesRule(filter, segment));

  ShowPartitions = Block {
    Paragraph {
      TextHeight: 16 pts;
      "Model: ";
      Style.DQuote {Name};
      BorderB: 1;
    };

    foreach (var partition in Partitions) {
      Paragraph {
        TextHeight: 14 pts;
        SpaceBefore: 6 pts;
        TabStops: [0.35 inch];
        LeftIndent: 2.85 inches;
        FirstIndent: -2.85 inches;
        EachOne;
        ")"
        Tab;
        partition.Filter.Name;
        Tab;
        Span {
          Separator: Space;
          (each partition.Segments).ShowSegment;
        }
      }
    }
  };

  ShowDescription(SegmentClass[] segments) = Block {
    Paragraph {
      TextHeight: 14 pts;
      Name;
    };

    Paragraph {
      Separator: Space;

      var i = 0;
      foreach (var filter in FiltersPlus) {
        var matching = GetMatching(segments, filter);
        if (valid matching) {
          HBox {
            VAlign: VAligns.Center;
            Margin: 2;
            PaddingLR: 1;
            Border: 0.25 pts {Color: 80%};
            Span {
              Style.MonoFamily;
              HAlign: HAligns.Center;
              if (Numbers) {
                i++;
                i;
              }
              else if (i < Rev.CharacterList.Length)
                Rev.CharacterList[i++];
              else
                System.Assert(false);
            };
            Space*5;
            Span {
              TextHeight: 18 pts;
              Separator: Space;
              (each matching).ShowSegment;
            };
          }
        }
      }
    }
  };
}
//======================================================================

class SingleFilterClass: FilterClass {
  SegmentClass Segment;

  Constructor(ResultsClass results, SegmentClass segment) {
    super.Constructor(results, segment.Ipa);
    Segment = segment;
  }

  override Matches(SegmentClass segment) = segment == Segment;
}
//======================================================================

class FeatureMaskClass: FilterClass {
  var Mask,
      Flags;

  Constructor(ResultsClass results, name, mask, flag) {
    super.Constructor(results, name);
    Mask  = mask;
    Flags = flag;
  }

  override Matches(SegmentClass segment) = segment.Features.HasFlagMask(Mask, Flags);
}
//======================================================================

class RootVowelClass: FilterClass {
  Constructor(ResultsClass results) {
    super.Constructor(results, "Root vowel");
  }

  override Matches(SegmentClass segment) = segment.Features.HasFlag(Vowel) and valid segment.Root;
}
//======================================================================

class DiphthongFilterClass: FilterClass {
  var Root;

  Constructor(ResultsClass results, root) {
    super.Constructor(results, "Root+Diphthongs");
    Root = root;
  }

  override Matches(SegmentClass segment) = segment == Root or (segment.Features.HasFlag(Diphthong) and segment.Root == Root);
}
//======================================================================

class SegmentListClass: FilterClass {
  SegmentClass[] List;

  Constructor(ResultsClass results, name, SegmentClass[] list) {
    super.Constructor(results, name);
    List = list;
  }

  override Matches(SegmentClass segment) = List.FindAny(segment);
}
//======================================================================

class VowelListClass: SegmentListClass {
  Constructor(ResultsClass results, SegmentClass[] list) {
    super.Constructor(results, list.FirstElement.Ipa, list);
  }

  override Matches(SegmentClass segment) = List.FindAny(segment);
}
//======================================================================

class DiphthongRuleClass: RuleClass {
  Constructor(ResultsClass results) {
    super.Constructor(results, "Diphthongs Separated");
    Add(new FeatureMaskClass(results, "Diphthong", Diphthong, Diphthong));
  }

  override GetFilterIndex(SegmentClass segment) {
    var c = FilterList.Length;
    if (segment.Features.HasFlag(Diphthong))
      return c;
    FilterList.Add(new SingleFilterClass(segment));
    return c;
  }
}
//======================================================================

class DiphthongPairRuleClass: RuleClass {
  Constructor(ResultsClass results) {
    super.Constructor(results, "Diphthongs Paired with Vowels");
  }

  override void AssignCharacters(SegmentClass[] segments) {
    var count = 0;
    foreach (var segment in segments) {
      var dr = segment.Root;
      if (valid dr and segment.Features.HasFlag(Diphthong)) {
        var fi = -1;
        foreach (var f in FilterList) {
          if (f.Matches(segment)) {
            fi = EachIndex;
            break;
          }
        }
        if (fi < 0) {
          SetSegmentCharacter(segment, count);
          SetSegmentCharacter(dr, count);
          Add(new DiphthongFilterClass(dr));
          ++count;
        }
        else
          SetSegmentCharacter(segment, fi);
      }
    }

    foreach (var segment in segments) {
      if (segment.CharacterIndex < 0) {
        SetSegmentCharacter(segment, count++);
        Add(new SingleFilterClass(segment));
      }
    }
    GetFilters;
  }
}
//======================================================================

class SingletonRuleClass: RuleClass {
  Constructor(ResultsClass results) {
    super.Constructor(results, "Each segment gets a different number");
    Numbers = true;
  }

  override void AssignCharacters(SegmentClass[] segments) {
    foreach (var segment in segments) {
      SetSegmentCharacter(segment, EachIndex);
      Add(new SingleFilterClass(Results, segment));
    }
    GetFilters;
  }
}
//======================================================================

class Partition2Class: RuleClass {
  Constructor(ResultsClass results) {
    super.Constructor(results, "Linguistically Informed");
    Numbers = true;

    Add(new VowelListClass(results, [IPA.Segments.ay, IPA.Segments.ai]));
    Add(new VowelListClass(results, [IPA.Segments.e, IPA.Segments.E]));
    Add(new VowelListClass(results, [IPA.Segments.ah, IPA.Segments.A]));
    Add(new VowelListClass(results, [IPA.Segments.u, IPA.Segments.U]));
    Add(new VowelListClass(results, [IPA.Segments.oh, IPA.Segments.O]));
    Add(new VowelListClass(results, [IPA.Segments.euh, IPA.Segments.LongOpenMidBackRounded]));
    Add(new VowelListClass(results, [IPA.Segments.eh, IPA.Segments.Eh]));
    Add(new VowelListClass(results, [IPA.Segments.uu, IPA.Segments.o]));
    Add(new FeatureMaskClass(results, "Nasal Vowel", Vowel Nasal, Vowel Nasal));
    Add(new FeatureMaskClass(results, "Vowel", Vowel, Vowel));
    Add(new FeatureMaskClass(results, "Nasal Consonant", Nasal, Nasal));
    Add(new SegmentListClass(results, "Non Sylabic Sonorant", [IPA.Segments.l, IPA.Segments.r, IPA.Segments.n, IPA.Segments.m, IPA.Segments.jg, IPA.Segments.w]));
    Add(new FeatureMaskClass(results, "Consonant", Vowel, NoFeature));
    GetFilters;
  }
}
//======================================================================

class PartitionHintClass {
  var            Rate;
  PartitionClass P1,
                 P2;
  ResultsClass   Results;

  Constructor(ResultsClass results, rate, PartitionClass p1, PartitionClass p2) {
    Results = results;
    Rate    = rate;
    P1      = p1;
    P2      = p2;
  }

  AddGroup(PartitionClass p) = VBox {
    HAlign: HAligns.Center;
    HBox {
      TextBackground: 90%;
      Span {
        p.Filter.Name;
      };
    };
    HBox {
      Results.ShowFilterSegments(Results.UniqueSegments, p.Filter, ParAlignments.Center);
    };
  };

  override GetLayoutTip = HBox {
    VAlign: VAligns.Top;
    if (P1 != P2)
      AddGroup(P1);
    HBox {
      MarginLR: 5;
      PaddingLR: 5;
      Background: 90%;
      VBox {
        HAlign: HAligns.Center;
        "Transitions";
        Span {
          Bold;
          TextHeight: 14 pts;
          TextDigits: 0;
          Rate;
        }
      };
    };
    AddGroup(P2);
  };
}
//======================================================================

class TransitionClass {
  var       Frequencies,
            Rates;
  RuleClass Rule;

  Constructor(RuleClass rule) {
    Rule = rule;
  }

  RandomArray {
    var list = new ListClass(Rule.Filters.Length);
    foreach (var f in Rule.Filters)
      list.Add(Math.Random(0..1000));
    return list.Values;
  }

  void ReadFrequencies {
    // This is temporary until we get actual data

    Frequencies = RandomArray;
    var list = new ListClass(Rule.Filters.Length);
    foreach (var f in Rule.Filters)
      list.Add(RandomArray);
    Rates = list.Values;
  }

  void StaticFrequencies(SegmentClass[] segments, MatrixClass tcount) {
    var list  = new ListClass(Rule.Filters.Length);
    var flist = new ListClass(Rule.Filters.Length);
    foreach (var f0 in Rule.Filters) {
      var s0  = Rule.GetMatching(segments, f0);
      var sum = Math.Sum((each s0).UsedCount);

      flist.Add(sum);

      var l1 = new ListClass(Rule.Filters.Length);
      foreach (var f1 in Rule.Filters) {
        var s1 = Rule.GetMatching(segments, f1);

        var count = 0;
        foreach (var s0i in s0) {
          foreach (var s1i in s1) {
            var tl = tcount.GetValue(s0i.Index, s1i.Index);
            if (valid tl)
              count += tl.Length;
          }
        }

        l1.Add(count);
      }
      list.Add(l1.Values);
    }
    Frequencies = flist.Values;
    Rates       = list.Values;
  }
}
//======================================================================

class TranClass {
  var List,
      Percent;

  Constructor(list, percent) {
    List    = list;
    Percent = percent;
  }

  override GetLayoutTip = Frame {
    var first = List.FirstElement;
    Paragraph {
      first.Word1.Padded[first.Index].ShowSegment;
      Tex.To;
      first.Word2.Padded[first.Index].ShowSegment;
    };
    Paragraph {
      List.Length; " transitions";
    };
    Paragraph {
      TextDigits: 1;
      Percent * 100.0; "% of max";
    };

    var count = Math.Min([List.Length, 30]);

    Width: Min([count*3, 6]) inches;

    Paragraph {
      Separator: Space;
      foreach (var p in List[0..count])
        p.ShowDescription(10 pts);
    };

    if (count < List.Length)
      "More...";
  };
}
//======================================================================

class CalcRatesClass {
  ResultsClass    Results;
  TransitionClass Transition;
  RuleClass       Rule;
  var             MaxLine,
                  ArrowGap,
                  GapAngle,
                  LoopRadius,
                  LoopDistance,
                  MaxExtent,
                  MaxRadius,
                  RateScale;

  Constructor(ResultsClass results, TransitionClass transition) {
    Results    = results;
    Rule       = transition.Rule;
    Transition = transition;
    ArrowGap   = 10 pts;
    GapAngle   = 80.0 degrees;
  }

  void Calibrate(size) {
    var middle = Point(size.Width * 0.5, size.Height * 0.5);

    MaxExtent    = Min([middle.X, middle.Y]);
    MaxRadius    = MaxExtent * 0.13;
    MaxLine      = MaxRadius * 0.3;
    LoopRadius   = MaxRadius * 0.25;
    LoopDistance = LoopRadius * 0.5;


    var fmax = MaxRadius / Sqrt(Real(Max(Transition.Frequencies))); // Proportional to area, so use SQRT of frequency

    RateScale = MaxLine / Max(Max(each Transition.Rates));

    foreach (var partition in Rule.Partitions) {
      partition.Angle  = (2 * EachIndex *  Graphics.OneEighty / Rule.Partitions.Length) - Graphics.Ninety;
      partition.Radius = Sqrt(Real(Transition.Frequencies[EachIndex])) * fmax;
    }

    var maxradius = 0.0;
    foreach (var partition in Rule.Partitions)
      maxradius = Max([maxradius, partition.Radius + Transition.Rates[EachIndex][EachIndex] * RateScale]);
    maxradius = MaxExtent - maxradius - LoopRadius - LoopDistance - ArrowGap;

    foreach (var partition in Rule.Partitions)
      partition.Center = Graphics.ExtendPoint(middle, maxradius, partition.Angle);
  }

  private MainDiagram(min) = Canvas {
    var size = Size(min, min);

    TransformFit: true;
    Calibrate(size);
    Size: size;

    foreach (var p1 in Rule.Partitions) {
      var pi = EachIndex;
      foreach (var p2 in Rule.Partitions) {
        var  rate = Transition.Rates[pi][EachIndex];
        var  hint = new PartitionHintClass(Results, rate, p1, p2);
        var  line = new LineStyleClass(rate * RateScale, 0.25, 1);
        if (p1 == p2) {
          var c = Graphics.ExtendPoint(p1.Center, p1.Radius + LoopDistance - line.LineSize*0.5, p1.Angle);
          Graphics.CircleArrow(line, c, LoopRadius, p1.Angle - Graphics.OneEighty, GapAngle) {
            Fill: Colors.Black;
            Hover: new HoverClass(hint, HoverTypes.Tip);
          };
        }
        else {
          var angle = Graphics.GetAngle(p1.Center, p2.Center);
          var c1    = Graphics.Adjust(p1.Center, p1.Radius + ArrowGap, angle);
          var c2    = Graphics.Adjust(p2.Center, p2.Radius + ArrowGap, angle + Graphics.OneEighty);

          Graphics.TwoArrowLine(line, c1, c2) {
            Fill: Color(0, 0, 0/*, Integer(128 + rate * RateScale / MaxLine * 127.0)*/);
            Hover: new HoverClass(hint, HoverTypes.Tip);
          };
        }
      }
    }

    foreach (var p1 in Rule.Partitions) {
      var pos   = p1.Center - p1.Radius;
      var fsize = p1.Radius*2;

      Figure {
        Fill: ChartColor(EachIndex);
        Stroke: 0.5 pt;
        Ellipse(Rect(pos, fsize));
        Hover: new HoverClass(p1, HoverTypes.Tip);
      };

      var c = LayoutSize(TestText(p1)).Width;
      CircleText(p1, pos, fsize, p1.Radius * 16 / c);
    }
  };

  TestText(PartitionClass p) = Paragraph {
    TextHeight: 10 pts;
    p.Filter;
  };

  CircleText(PartitionClass p, pos, fsize, textheight) = HBox {
    Position: pos;
    Height: fsize;
    Frame {
      VAlignment: VAligns.Center;
      Width: fsize;
      TextHeight: textheight;
      ParAlignment: ParAlignments.Center;
      p.Filter;
    };
  };

  PartitionDiagram(SizeClass wholesize) = VBox {
    Width: wholesize.Width;
    HAlign: HAligns.Center;

    HBox {
      VAlign: VAligns.Center;

      VBox {
        Table {
          TextHeight: 10 pts;
          Columns: [20 pts, 1 inch];

          foreach (var partition in Rule.Partitions) {
            Row {
              Span {
                EachOne;
                ". ";
              };
              Paragraph {
                LeftIndent: 15 pts;
                FirstIndent: -15 pts;
                Figure {
                  Fill: ChartColor(EachIndex);
                  Ellipse(Rect(0, 10 pts));
                };
                Tab;
                partition.Filter;
              }
            }
          }
        };
      };

      MainDiagram(Min([wholesize.Width, wholesize.Height]));
    };
  };

  GetColor(SegmentClass s) = ChartColor(s.PartitionIndex);// * 30%;

  TranLink(i0, i1) = "Tran{0}:{1}"(i0, i1);

  TranPar(list) = Block {
    var first = list.FirstElement;
    Paragraph {
      var s0 = first.Word1.Padded[first.Index];
      s0.ShowSegment;

      Tex.To;
      var s1 = first.Word2.Padded[first.Index];
      s1.ShowSegment;

      LocationMark: TranLink(s0.Index, s1.Index);
      KeepWithNext: true;
    };

    Paragraph {
      SpaceBefore: 4 pts;
      SpaceAfter: 6 pts;
      Separator: Space;
      foreach (var p in list)
        p.ShowDescription(9 pts);
    }
  };

  CompareLength(l1, l2) = l2.Length - l1.Length;

  GetSorted {
    var all  = new ListClass(128);
    var t    = Results.TransitionCount;
    foreach (var s0 in Results.PartSegments) {
      foreach (var s1 in Results.PartSegments) {
        if (s0.Index != s1.Index) {
          var tlist = t.GetValue(s0.Index, s1.Index);
          if (exists tlist && tlist.Length < Info.LinkMin)
            all.Add(tlist);
        }
      }
    }

    return all.Sort(true, ref CompareLength);
  }

  PartitionBlock = Block {
    PartitionBox(Size(DocMetrics.SlideContent.Width, DocMetrics.PageContent.Height * 0.8), true);
    PageBreak;

    Block {
      TextHeight: 9 pts;
      TranPar(each GetSorted);
    }
  };

  PartitionBox(SizeClass framesize, link) = Paragraph {
    var grid   = 0.125 pts;
    var gcolor = 65%;
    var border = 0.5 pts;
    var size   = framesize - border;
    var d      = size / (Results.PartSegments.Length+1);
    Canvas {
      TextHeight: d.Width * 0.5;
      Border: border;
      Size: framesize;

      var t   = Results.TransitionCount;
      var max = 1.0 / Results.TransitionMax;
      var y   = d.Height;
      foreach (var s0 in Results.PartSegments) {
        var x = d.Width;
        foreach (var s1 in Results.PartSegments) {
          if (s0.Index != s1.Index) {
            var tlist = t.GetValue(s0.Index, s1.Index);
            if (exists tlist) {
              Canvas {
                HAlign: HAligns.Center;
                VAlign: VAligns.Center;
                X: x;
                Y: y;
                Size: d;

                var count = 0;
                foreach (var e in tlist) {
                  var c0 = e.Word1.Padded[e.Index];
                  var c1 = e.Word2.Padded[e.Index];
                  if (c0.Features.HasFlag(FeatureSet.Vowel) != c1.Features.HasFlag(FeatureSet.Vowel))
                    ++count;
                }

                if (count > 0) {
                  var f = Integer(255.0 * (1.0 - count / tlist.Length));
                  Background: Color(f, 255, f);
                }
                else {
                  var f = Integer((1.0 - tlist.Length * max) * 255.0);
                  Background: Color(255, f, f);
                }

                Span {
                  tlist.Length;
                  var tip = new TranClass(tlist, tlist.Length*max);
                  if (link && tlist.Length < Info.LinkMin)
                    Hover: new HoverClass(TranLink(s0.Index, s1.Index), HoverTypes.LocationMark, tip);
                  else
                    Hover: new HoverClass(tip, HoverTypes.Tip);
                }
              };
            }
          }
          x += d.Width;
        }
        y += d.Height;
      }

      y = d.Height;
      var p = 0;
      foreach (var s in Results.PartSegments) {
        Canvas {
          Size: d;
          Background: GetColor(s);
          Width: d.Width;
          HAlign: HAligns.Center;
          Y: y;
          s.ShowSegment;
        };
        if (p != s.PartitionIndex) {
          Canvas {
            Y: y;
            Size: Size(size.Width, grid);
            Background: gcolor;
          };
          p = s.PartitionIndex;
        }
        y += d.Height;
      }

      Canvas {
        Height: d.Height;
        Width: size.Width;

        var x = d.Width;
        p = 0;
        foreach (var s in Results.PartSegments) {
          Canvas {
            Size: d;
            Background: GetColor(s);
            HAlign: HAligns.Center;
            X : x;
            s.ShowSegment;
          };
          if (p != s.PartitionIndex) {
            Canvas {
              X: x;
              Size: Size(grid, size.Height);
              Background: gcolor;
            };
            p = s.PartitionIndex;
          }
          x += d.Width;
        }
      };
    };
  };
}
//======================================================================

