using Format, Units, FeatureSet, Math;
//======================================================================

class FilterClass {
  var Name;

  Constructor(name) {
    Name = name;
  }

  virtual Matches(segment) = true;
}
//======================================================================

class PartitionClass {
  var Index,
      Filter,
      Segments;

  Constructor(index, filter, segments) {
    Index    = index;
    Filter   = filter;
    Segments = segments;
  }
}
//======================================================================

abstract class RuleClass {
  var Name,
      Filters,
      Partitions,
      Numbers;

  Constructor(name) {
    Name    = name;
    Numbers = false;
  }

  virtual void GetFilters {
  }

  MatchesRule(filter, segment) {
    foreach (var f in Filters) {
      if (f == filter)
        return f.Matches(segment);
      if (f.Matches(segment))
        return false;
    }
    return false;
  }

  virtual GetFilterIndex(segment) {
    var c = 0;
    foreach (var filter in Filters) {
      if (MatchesRule(filter, segment))
        return c;
      ++c;
    }
    return c;
  }

  void SetSegmentCharacter(SegmentClass segment, index) {
    segment.CharacterIndex = index;
    if (Numbers)
      segment.CharacterLetter = index;
    else if (index < Rev.CharacterList.Length)
      segment.CharacterLetter = Rev.CharacterList[index];
    else
      System.Assert(false, "Too many characters");
  }

  virtual void AssignCharacters(segments) {
    var last = Rev.CharacterList.Length-1;
    foreach (var segment in segments) {
      var index = GetFilterIndex(segment);
      if (index > last)
        index = last;
      SetSegmentCharacter(segment, index);
    }
    GetFilters;
  }

  virtual void AssignPartitions(segments) {
    var list = new ListClass(segments.Length);
    var i    = 0;
    foreach (var filter in Filters) {
      var find = GetSegments(segments, filter);
      if (valid find) {
        list.Add(new PartitionClass(i, filter, find));
        foreach (var s in find)
          s.PartitionIndex = i;
        ++i;
      }
    }
    Partitions = list.ToArray;
  }

  GetSegments(segments, filter) = FindSlice(segments, segment => MatchesRule(filter, segment));

  ShowPartitions = Block {
    Paragraph {
      TextHeight: 14 pts;
      Name;
    };

    foreach (var partition in Partitions) {
      Paragraph {
        BorderB: 0.5;
        TabStops: [0.25 inch];

        partition.Index+1;
        Tab;
        partition.Filter.Name; Bold
      };

      Paragraph {
        TextHeight: 16 pts;
        LeftIndent: 0.25 inches;

        Span {
          Separator: Space;
          (each partition.Segments).ShowSegment;
        }
      }
    }
  };

  ShowDescription = Block {
    Paragraph {
      TextHeight: 14 pts;
      Name;
    };

    Paragraph {
      Separator: Space*2;

      var i = 0;
      foreach (var filter in Filters) {
        var segments = GetSegments(Results.UniqueSegments, filter);
        if (segments.Length > 0) {
          HBox {
            VAlign: VAligns.Center;
            Margin: 2;
            PaddingLR: 1;
            Border: 0.25 pts {Color: 80%};
            Span {
              Style.MonoFamily;
              HAlign: HAligns.Center;
              if (Numbers)
                i++;
              else if (i < Rev.CharacterList.Length)
                Rev.CharacterList[i++];
              else
                System.Assert(false);
            };
            Space*5;
            Span {
              TextHeight: 18 pts;
              Separator: Space;
              (each segments).ShowSegment;
            };
          }
        }
      }
    }
  };
}
//======================================================================

class SingleFilterClass: FilterClass {
  var Segment;

  Constructor(segment) {
    super.Constructor(segment.Ipa);
    Segment = segment;
  }

  override Matches(segment) = segment == Segment;
}
//======================================================================

class FeatureMaskClass: FilterClass {
  var Mask,
      Flags;

  Constructor(name, mask, flag) {
    super.Constructor(name);
    Mask  = mask;
    Flags = flag;
  }

  override Matches(segment) = segment.Features.HasFlagMask(Mask, Flags);
}
//======================================================================

class LabiovelarFilterClass: FilterClass {
  Constructor {
    super.Constructor("Labiovelar");
  }

  override Matches(segment) = segment.Features.HasFlagMask(Vowel, NoFeature) and segment.Place == Places.LabialVelar;
}
//======================================================================

class DiphthongClass: FilterClass {
  var Diphthong;

  Constructor(diphthong) {
    super.Constructor("Diphthong " + diphthong);
  }

  override Matches(segment) = segment.Features.HasFlagMask(Vowel, NoFeature) and segment.Place == Places.LabialVelar;
}
//======================================================================

class LongShortClass: FilterClass {
  var Root;

  Constructor(root) {
    Root = root;
    super.Constructor("Long & Short " + root.Name);
  }

  override Matches(segment) = segment.Root == Root and segment.Features.HasFlagMask(Vowel Nasal, Vowel);
}
//======================================================================

class RootMaskClass: FeatureMaskClass {
  var Root;

  Constructor(name, mask, flag, root) {
    super.Constructor(name + Space + root, mask, flag);
    Root = root;
  }

  override Matches(segment) = segment.Root == Root and segment.Features.HasFlagMask(Mask, Flags);
}
//======================================================================

class RootVowelClass: FilterClass {
  Constructor() {
    super.Constructor("Root vowel");
  }

  override Matches(segment) = segment.Features.HasFlag(Vowel) and segment.Root != RootVowels.None;
}
//======================================================================

class DiphthongFilterClass: FilterClass {
  var Root;

  Constructor(root) {
    super.Constructor("Root+Diphthongs");
    Root = root;
  }

  override Matches(segment) = segment == Root or segment.DiphthongRoot == Root;
}
//======================================================================

class SegmentListClass: FilterClass {
  var List;

  Constructor(name, list) {
    super.Constructor(name);
    List = list;
  }

  override Matches(segment) = FindAny(List, s => s == segment);
}
//======================================================================

Residue             = new FilterClass("Residue");
NasalVowels         = new FeatureMaskClass("Nasal Vowel", Vowel Nasal, Vowel Nasal);
RoundedVowels       = new FeatureMaskClass("Rounded Vowel", Vowel Rounded, Vowel Rounded);
LongVowels          = new FeatureMaskClass("Long Vowel", Vowel LongVowel, Vowel LongVowel);
ShortVowels         = new FeatureMaskClass("Short Vowel", Vowel LongVowel, Vowel);
AllRootVowels       = new RootVowelClass;
Vowels              = new FeatureMaskClass("Vowel", Vowel, Vowel);
VoicelessStops      = new FeatureMaskClass("Voiceless Stop", Voiced Stop, Stop);
VoicedStops         = new FeatureMaskClass("Voiced Stop", Voiced Stop, Voiced Stop);
VoicedAffricates    = new FeatureMaskClass("Voiced Affricate", Voiced Affricate, Voiced Affricate);
VoicelessAffricates = new FeatureMaskClass("Voiceless Affricate", Voiced Affricate, Affricate);
NasalConsonants     = new FeatureMaskClass("Nasal Consonant", Nasal, Nasal);
Rhotics             = new FeatureMaskClass("Rhotic", Rhotic, Rhotic);
Sibilants           = new FeatureMaskClass("Sibilant", Sibilant, Sibilant);
Approximants        = new FeatureMaskClass("Approximant", Approximant, Approximant);
Pulmonics           = new FeatureMaskClass("Pulmonic", Pulmonic, Pulmonic);
VoicedFricatives    = new FeatureMaskClass("Voiced Fricative", Pulmonic Voiced Fricative, Pulmonic Voiced Fricative);
VoicelessFricatives = new FeatureMaskClass("Voiceless Fricative", Pulmonic, Pulmonic Fricative);
Laterals            = new FeatureMaskClass("Lateral", Lateral, Lateral);
Diphthongs          = new FeatureMaskClass("Diphthong", Diphthong, Diphthong);
Consonants          = new FeatureMaskClass("Consonants", Vowel, NoFeature);
Labiovelars         = new LabiovelarFilterClass;
LongShortRoot       = new LongShortClass(each RootVowels[1..]);
NasalRoot           = new RootMaskClass("Nasal", Vowel Nasal LongVowel, Vowel Nasal, each RootVowels[1..]);
LongRoot            = new RootMaskClass("Long", Vowel Nasal LongVowel, Vowel LongVowel, each RootVowels[1..]);
ShortRoot           = new RootMaskClass("Short", Vowel Nasal LongVowel, Vowel, each RootVowels[1..]);
Consonants1         = new SegmentListClass("Consonant Group 1", [IPA.Segments.l, IPA.Segments.r, IPA.Segments.n, IPA.Segments.m, IPA.Segments.jg, IPA.Segments.w]);
//======================================================================


class VowelsSeparatedRuleClass: RuleClass {
  Constructor {
    super.Constructor("Vowels Separated");

    Filters = LongRoot + ShortRoot + NasalRoot + [
      NasalVowels,
      RoundedVowels,
      Vowels,
      Labiovelars,
      VoicelessStops,
      VoicedStops,
      VoicedAffricates,
      VoicelessAffricates,
      NasalConsonants,
      Laterals,
      Rhotics,
      Sibilants,
      Approximants,
      VoicedFricatives,
      VoicelessFricatives,
      Residue,
    ];
  }
}
//======================================================================

// This produces a tree with Catalan and Spanish in the same clade
class SegmentTypesRuleClass: RuleClass {
  Constructor {
    super.Constructor("Segment Types");

    Filters = [
      NasalVowels,
      RoundedVowels,
      LongVowels,
      AllRootVowels,
      Vowels,
      VoicelessStops,
      VoicedStops,
      VoicedAffricates,
      VoicelessAffricates,
      NasalConsonants,
      Rhotics,
      Sibilants,
      Pulmonics,
      Residue,
    ];
  }
}
//======================================================================

class DiphthongRuleClass: RuleClass {
  var FilterList;

  Constructor {
    super.Constructor("Diphthongs Separated");
    FilterList = new ListClass(128);
  }

  override GetFilterIndex(segment) {
    var c = FilterList.Length;
    if (segment.Features.HasFlag(Diphthong))
      return c;
    FilterList.Add(new SingleFilterClass(segment));
    return c;
  }

  override void GetFilters {
    FilterList.Add(Diphthongs);
    Filters = FilterList.ToArray;
  }
}
//======================================================================

class DiphthongPairRuleClass: RuleClass {
  var FilterList;

  Constructor {
    super.Constructor("Diphthongs Paired with Vowels");
    FilterList = new ListClass(128);
  }

  override void AssignCharacters(segments) {
    var count = 0;
    foreach (var segment in segments) {
      var dr = segment.DiphthongRoot;
      if (valid dr) {
        var fi = -1;
        foreach (var f in FilterList) {
          if (f.Matches(segment)) {
            fi = EachIndex;
            break;
          }
        }
        if (fi < 0) {
          SetSegmentCharacter(segment, count);
          SetSegmentCharacter(dr, count);
          FilterList.Add(new DiphthongFilterClass(dr));
          ++count;
        }
        else
          SetSegmentCharacter(segment, fi);
      }
    }

    foreach (var segment in segments) {
      if (segment.CharacterIndex < 0) {
        SetSegmentCharacter(segment, count++);
        FilterList.Add(new SingleFilterClass(segment));
      }
    }
    GetFilters;
  }

  override void GetFilters {
    Filters = FilterList.ToArray;
  }
}
//======================================================================

class SingletonRuleClass: RuleClass {
  var FilterList;

  Constructor {
    super.Constructor("Each segment gets a different number");
    FilterList = new ListClass(128);
    Numbers    = true;
  }

  override void AssignCharacters(segments) {
    foreach (var segment in segments) {
      SetSegmentCharacter(segment, EachIndex);
      FilterList.Add(new SingleFilterClass(segment));
    }
    Filters = FilterList.ToArray;
  }
}
//======================================================================

class Partition1Class: RuleClass {
  Constructor {
    super.Constructor("David's basic rules");
    Numbers = true;

    Filters = [
      NasalVowels,
      Vowels,
      Consonants1,
      Consonants,
      Residue,
    ];
  }
}
//======================================================================

