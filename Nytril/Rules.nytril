using Format, Units, SegmentFeatures, LinkTypes;
//======================================================================

class PartitionClass: FactClass {
  field string       Name;
  var string         PluralName;
  var SegPartClass[] Segments;
  var PointClass     Center;
  var ColorClass     Color,
                     TextColor;
  var                Marker,
                     Index,
                     Radius,
                     Angle,
                     Outer;

  Constructor(index, name, plural, SegPartClass[] segments) {
    super.Constructor(guid.FromHash(name));
    Name       = name;
    PluralName = plural;
    Color      = ColorClass.ChartColor(index);
    Marker     = Markers.Dot(Color);
    TextColor  = Color.TextCompliment;
    Index      = index;
    Segments   = segments;

    foreach (var s in segments)  {
      s.SetPartition(this, index);
      Link.Connect(this, s.Segment);
    }
  }

  override IconClass GetIcon = Icons.sort;

  ShowFilterSegments(align) = Frame(PaperStyle.SegmentWidth) {
    Paragraph {
      ParAlignment: align;
      TextHeight: 18 pts;
      Separator: Space;
      (each Segments).ShowSegment;
    }
  };

  override GetLayoutTip = Frame(PaperStyle.SegmentWidth) {
    Paragraph(BorderB(1)) {
      ParAlignment: ParAlignments.Center;
      TextHeight: 16 pts;
      PluralName;
    };
    ShowFilterSegments(ParAlignments.Left);
  };

  ShowPlural = Span {
    TipAction: this;
    PluralName;
  };

  override GetLayoutSpan = Span {
    TipAction: this;
    Name;
  };
}

//======================================================================

class PartitionInfoClass {
  var Name,
      SegmentIndices;

  Constructor(name, segments) {
    Name           = name;
    SegmentIndices = segments;
  }
}

//======================================================================

class FilterClass {
  field string  Name;
  var string    PluralName;
  var RuleClass Rule;

  Constructor(RuleClass rule, name, plural) {
    Rule       = rule;
    Name       = name;
    PluralName = plural ?? name;
  }

  virtual bool Matches(SegmentClass segment) = true;

  override GetLayoutSpan = Span {
    TipAction: this;
    Name;
  };
}

//======================================================================

abstract class RuleClass {
  var ListClass<FilterClass> FilterList;
  var FilterClass[]          Filters,
                             FiltersPlus;
  var PartitionClass[]       Partitions;
  var SegPartClass[]         Segments;
  var                        Name,
                             Matrix,
                             Numbers;

  Constructor(name) {
    Name       = name;
    Numbers    = false;
    FilterList = new(128);
  }

  void Init(SegPartClass[] segments) {
    Filters = FilterList.ToArray;
    FilterList.Add(new FilterClass(this, "Residue", "Residues"));
    FiltersPlus = FilterList.ToArray;

    var list = new ListClass<PartitionClass>(segments.Length);
    var i    = 0;
    foreach (var filter in FiltersPlus) {
      var find = GetMatching(segments, filter);
      if (find is valid) {
        var part = new PartitionClass(i, filter.Name, filter.PluralName, find);
        list.Add(part);
        ++i;
      }
    }
    Partitions = list.ToArray;
    Segments   = segments.ToSortedArray(true, @ComparePartSegments);
  }

  bool MatchesRule(FilterClass filter, SegmentClass segment) {
    foreach (var f in FiltersPlus) {
      if (f == filter)
        return f.Matches(segment);
      if (f.Matches(segment))
        return false;
    }
    return false;
  }

  virtual int GetFilterIndex(SegmentClass segment) {
    var c = 0;
    foreach (var filter in FiltersPlus) {
      if (MatchesRule(filter, segment))
        return c;
      ++c;
    }
    return c;
  }

  static int ComparePartSegments(SegPartClass s0, SegPartClass s1) {
    var i = s1.PartitionIndex - s0.PartitionIndex;
    if (i == 0)
      i = s0.UsedCount - s1.UsedCount;
    return i;
  }

  SegPartClass[] GetMatching(SegPartClass[] segments, FilterClass filter) {
    return segments.FindSlice(part => MatchesRule(filter, part.Segment));
  }

  ShowLegend(ContentStyleClass style, textheight, width, padding) = VBox(width, null, padding) {
    Table(null, null, [textheight*1.7, textheight, width - textheight*2.7]) {
      style.SansSerif;
      TextHeight: textheight;

      foreach (var partition in Partitions) {
        Row {
          VAlign: VAligns.Center;
          Span {each1; ")"};
          Span {
            TextColor: partition.Color;
            TextHeight: 125%;
            Tex.blackcirc;
          };
          partition;
        }
      }
    };
  };

  ShowBlockLegend(PartitionClass[] partitions, textheight) = Frame {
    Paragraph {
//      ParAlignment: ParAlignments.Center;
      Separator: Space*4;
      TextHeight: textheight;
      foreach (var p in partitions) {
        HBox {
          VAlign: VAligns.Center;
          Separation: 3 pts;
          Canvas (textheight, textheight) {
            BorderRadius: PaperStyle.BorderSize;
            Background: p.Color;
          };
          p;
        }
      }
    }
  };

  GetCaption(ContentStyleClass style) = Span {
    "Model: ";
    style.DQuote {Name};
  };

  ShowPartitions {
    var textheight = Math.Min(ExtentWidth * 0.04, 10 pts);
    return Table(BorderB(1), null, [textheight * 2, textheight * 9, ColumnClass.Expand]) {
      TextHeight: textheight;

      foreach (var partition in Partitions) {
        Row(each0 == 0 ? BorderT(1) : null) {
          VAlign: VAligns.Top;
          Cell(PadR(2 pts)) {
            HAlign: HAligns.Right;
            Span {each1; ") "};
          };
          partition.Name;
          Span {
            Separator: Space;
            (each partition.Segments).ShowSegment;
          }
        };
      }
    };
  }

  ShowDescription(SegPartClass[] segments) = Block {
    Paragraph {
      TextHeight: 14 pts;
      Name;
    };

    Paragraph {
      Separator: Space;

      var i = 0;
      foreach (var filter in FiltersPlus) {
        var matching = GetMatching(segments, filter);
        if (matching is valid) {
          HBox(null, null, new EdgeClass(0.25 pts, 1, 80%)) {
            VAlign: VAligns.Center;
            Margin: 2;
            Span {
              TextFixed: true;
              if (Numbers) {
                i++;
                i;
              }
              else if (i < Nexus.CharacterList.Length)
                Nexus.CharacterList[i++];
              else
                System.Assert(false);
            };
            Space*5;
            Span {
              TextHeight: 18 pts;
              Separator: Space;
              (each matching).ShowSegment;
            };
          }
        }
      }
    }
  };
}

//======================================================================

class SingleFilterClass: FilterClass {
  var SegmentClass Segment;

  Constructor(RuleClass rule, SegmentClass segment) {
    super.Constructor(rule, segment.Ipa, null);
    Segment = segment;
  }

  override bool Matches(SegmentClass segment) = segment == Segment;
}

//======================================================================

class FeatureMaskClass: FilterClass {
  var Mask,
      Flags;

  Constructor(RuleClass rule, name, plural, mask, flag) {
    super.Constructor(rule, name, plural);
    Mask  = mask;
    Flags = flag;
    rule.FilterList.Add(this);
  }

  override bool Matches(SegmentClass segment) = segment.Features.HasFlagMask(Mask, Flags);
}

//======================================================================

class SegmentListClass: FilterClass {
  var SegmentClass[] List;

  Constructor(RuleClass rule, name, plural, SegmentClass[] list) {
    super.Constructor(rule, name, plural);
    List = list;
  }

  override bool Matches(SegmentClass segment) = List.FindElementIndex(segment) >= 0;
}

//======================================================================

class VowelListClass: SegmentListClass {
  Constructor(RuleClass rule, SegmentClass[] list) {
    super.Constructor(rule, list.FirstElement.Ipa, null, list);
  }

  override bool Matches(SegmentClass segment) = List.FindElementIndex(segment) >= 0;
}

//======================================================================

class NaturalPartitionClass: RuleClass {
  Constructor {
    super.Constructor("Natural Class");
    Numbers = true;

    new FeatureMaskClass(this, "Long Vowel", "Long Vowels", Vowel LongVowel, Vowel LongVowel);
    new FeatureMaskClass(this, "Nasal Vowel", "Nasal Vowels", Vowel Nasal, Vowel Nasal);
    new FeatureMaskClass(this, "Diphthong", "Diphthongs", Diphthong, Diphthong);
    new FeatureMaskClass(this, "Short Vowel", "Short Vowels", Vowel, Vowel);
    new FeatureMaskClass(this, "Nasal Consonant", "Nasal Consonants", Nasal, Nasal);
    new FeatureMaskClass(this, "Liquid", "Liquids", Vowel Liquid, Liquid);
    new FeatureMaskClass(this, "Approximant", "Approximants", Vowel Approximant, Approximant);
    new FeatureMaskClass(this, "Affricate", "Affricates", Vowel Affricate, Affricate);
    new FeatureMaskClass(this, "Fricative", "Fricatives", Vowel Fricative, Fricative);
    new FeatureMaskClass(this, "Stop", "Stops", Vowel, NoFeature);
  }
}

//======================================================================

