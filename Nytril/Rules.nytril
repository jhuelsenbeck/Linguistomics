using Format, Units, FeatureSet, Math;
//======================================================================

class FilterClass {
  var Name,
      Color;

  Constructor(name) {
    Name = name;
  }

  virtual Matches(segment) = true;
}
//======================================================================

abstract class RuleClass {
  var Name,
      Letter,
      Symbol,
      Filters;

  Constructor(name, letter, symbol) {
    Name    = name;
    Letter  = letter;
    Symbol  = symbol;
  }

  void InitFilters {
    foreach (var filter in Filters)
      filter.Color = ChartColor(EachIndex);
  }

  MatchesRule(filter, segment) {
    foreach (var f in Filters) {
      if (f == filter)
        return f.Matches(segment);
      if (f.Matches(segment))
        return false;
    }
    return false;
  }

  FindRule(segment) {
    if (segment.Punctuation)
      return null;

    foreach (var f in Filters) {
      if (f.Matches(segment))
        return f;
    }
    return null;
  }

  virtual ShowDescription = Block {
    Paragraph {
      TextHeight: 14 pts;
      BorderB: 1 pt;
      SpaceAfter: 10 pts;
      Letter;
      "({0})"(Symbol);
      Tab;
      Name;
    }
  };

  ShowFile = TextBlock {
    Span {
      Letter;
      ":";
      Span {
        Separator:",";
        ShowGroup(each Filters);
      };
    }
  };

  ShowLegend = Paragraph {
    Separator: Space*2;
    foreach (var filter in Filters) {
      Span {
        Canvas {
          Border: 0.25;
          Width: 10 pts;
          Height: 8 pts;
          Background: filter.Color;
        };
        Space;
        filter.Name;
      }
    }
  };

  GetSegments(filter) = FindSlice(Results.DisplaySegments, segment => MatchesRule(filter, segment));

  ShowGroup(g) = Span {
    "(";
    (each GetSegments(g)).ShowCharacter;
    ")";
  };

  override ShowDescription = Block {
    Table {
      Columns: [15 pts, 1.4 inches, DocMetrics.PageContent.Width - 1.55 inches];
      Row {
        Bold;
        Background: 90%;
        "#";
        Lang.Filter;
        Lang.Segments;
      };

      foreach (var filter in Filters) {
        Row {
          Nexus.CharacterList[EachIndex];
          filter.Name;
          Cell {
            TextHeight: 14 pts;
            Span {
              Separator: Space;
              (each GetSegments(filter)).ShowSegment;
            };
          };
        };
      }
    }
  };
}
//======================================================================

class SingleClass: FilterClass {
  var Segment;

  Constructor(segment) {
    super.Constructor(segment.Ipa);
    Segment = segment;
  }

  override Matches(segment) = segment == Segment;
}
//======================================================================

class FeatureMaskClass: FilterClass {
  var Mask,
      Flags;

  Constructor(name, mask, flag) {
    super.Constructor(name);
    Mask  = mask;
    Flags = flag;
  }

  override Matches(segment) = segment.Features.HasFlagMask(Mask, Flags);
}
//======================================================================

class LRClass: FilterClass {
  Constructor {
    super.Constructor("LR");
  }

  override Matches(segment) = segment == IPA.Segments.l or segment == IPA.Segments.r;
}
//======================================================================

class GroupRuleClass: RuleClass {
  Constructor {
    super.Constructor("Consonant-Vowel-Nasal clusters", "Kappa", Tex.kappa);

    Filters = [
      // Vowels
      new FeatureMaskClass("Nasal Vowel", Vowel Nasal, Vowel Nasal),
      new FeatureMaskClass("Rounded Vowel", Vowel Rounded, Vowel Rounded),
      new FeatureMaskClass("Long Vowel", Vowel LongVowel, Vowel LongVowel),
      new FeatureMaskClass("Vowel", Vowel, Vowel),

      // Specially selected
      new SingleClass(IPA.Segments.j),
      new SingleClass(IPA.Segments.w),

      // Consonants
      new FeatureMaskClass("Voiceless Stop", Voiced Stop, Stop),
      new FeatureMaskClass("Voiced Stop", Voiced Stop, Voiced Stop),
      new FeatureMaskClass("Voiced Affricate", Voiced Affricate, Voiced Affricate),
      new FeatureMaskClass("Voiceless Affricate", Voiced Affricate, Affricate),
      new FeatureMaskClass("Nasal Consonant", Nasal, Nasal),
      new FeatureMaskClass("Rhotic", Rhotic, Rhotic),
      new FeatureMaskClass("Sibilants", Sibilant, Sibilant),
      new FeatureMaskClass("Pulmonic", Pulmonic, Pulmonic),
      new FilterClass("Consonant"),
    ];
    InitFilters;
  }
}
//======================================================================

