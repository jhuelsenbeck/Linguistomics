using Format, Units, FeatureSet, Math, SegmentGroups, Style;
//======================================================================

class FilterClass {
  var Name;

  Constructor(name) {
    Name = name;
  }

  virtual Matches(SegmentClass segment) = true;

  override GetPopup = Results.ShowFilterSegments(this);

  override GetLayout = Span {
    Popup: this;
    Name;
  };
}
//======================================================================

class PartitionClass {
  SegmentClass[] Segments;
  var            Index,
                 Center,
                 Radius,
                 Angle,
                 Outer;
  FilterClass    Filter;

  Constructor(index, FilterClass filter, SegmentClass[] segments) {
    Index    = index;
    Filter   = filter;
    Segments = segments;
  }
}
//======================================================================

abstract class RuleClass {
  ListClass        FilterList;
  FilterClass[]    Filters,
                   FiltersPlus;
  PartitionClass[] Partitions;
  var              Name,
                   Matrix,
                   Numbers;

  Constructor(name) {
    Name       = name;
    Numbers    = false;
    FilterList = new ListClass(128);
  }

  void Add(FilterClass filter) {
    FilterList.Add(filter);
  }

  MatchesRule(FilterClass filter, SegmentClass segment) {
    foreach (var f in FiltersPlus) {
      if (f == filter)
        return f.Matches(segment);
      if (f.Matches(segment))
        return false;
    }
    return false;
  }

  virtual GetFilterIndex(SegmentClass segment) {
    var c = 0;
    foreach (var filter in FiltersPlus) {
      if (MatchesRule(filter, segment))
        return c;
      ++c;
    }
    return c;
  }

  void SetSegmentCharacter(SegmentClass segment, index) {
    segment.CharacterIndex = index;
    if (Numbers)
      segment.CharacterLetter = index;
    else if (index < Rev.CharacterList.Length)
      segment.CharacterLetter = Rev.CharacterList[index];
    else
      System.Assert(false, "Too many characters");
  }

  void GetFilters {
    Filters = FilterList.Values;
    Add(Residue);
    FiltersPlus = FilterList.Values;
  }

  virtual void AssignCharacters {
    var last = Rev.CharacterList.Length-1;
    foreach (var segment in Results.UniqueSegments) {
      var index = GetFilterIndex(segment);
      if (index > last)
        index = last;
      SetSegmentCharacter(segment, index);
    }
    GetFilters;
  }

  virtual void AssignPartitions {
    var list = new ListClass(Results.UniqueSegments.Length, PartitionClass);
    var i    = 0;
    foreach (var filter in FiltersPlus) {
      var find = GetSegments(filter);
      if (valid find) {
        list.Add(new PartitionClass(i, filter, find));
        foreach (var s in find)
          s.PartitionIndex = i;
        ++i;
      }
    }
    Partitions = list.Values;
  }

  GetSegments(FilterClass filter) = Math.FindSlice(Results.UniqueSegments, segment => MatchesRule(filter, segment));

  ShowPartitions = Block {
    Paragraph {
      TextHeight: 16 pts;
      "Model: ";
      Style.DQuote {Name};
    };

    foreach (var partition in Partitions) {
      Paragraph {
        SpaceBefore: 12 pts;
        BorderB: 0.25 pts;
        TabStops: [0.25 inch];

        EachOne;
        Tab;
        Span {partition.Filter.Name; Bold};
      };

      Paragraph {
        TextHeight: 16 pts;
        LeftIndent: 0.25 inches;

        Span {
          Separator: Space;
          (each partition.Segments).ShowSegment;
        }
      }
    }
  };

  ShowDescription = Block {
    Paragraph {
      TextHeight: 14 pts;
      Name;
    };

    Paragraph {
      Separator: Space;

      var i = 0;
      foreach (var filter in FiltersPlus) {
        var segments = GetSegments(filter);
        if (segments.Length > 0) {
          HBox {
            VAlign: VAligns.Center;
            Margin: 2;
            PaddingLR: 1;
            Border: 0.25 pts {Color: 80%};
            Span {
              Style.MonoFamily;
              HAlign: HAligns.Center;
              if (Numbers) {
                i++;
                i;
              }
              else if (i < Rev.CharacterList.Length)
                Rev.CharacterList[i++];
              else
                System.Assert(false);
            };
            Space*5;
            Span {
              TextHeight: 18 pts;
              Separator: Space;
              (each segments).ShowSegment;
            };
          }
        }
      }
    }
  };
}
//======================================================================

class SingleFilterClass: FilterClass {
  SegmentClass Segment;

  Constructor(SegmentClass segment) {
    super.Constructor(segment.Ipa);
    Segment = segment;
  }

  override Matches(SegmentClass segment) = segment == Segment;
}
//======================================================================

class FeatureMaskClass: FilterClass {
  var Mask,
      Flags;

  Constructor(name, mask, flag) {
    super.Constructor(name);
    Mask  = mask;
    Flags = flag;
  }

  override Matches(SegmentClass segment) = segment.Features.HasFlagMask(Mask, Flags);
}
//======================================================================

class LabiovelarFilterClass: FilterClass {
  Constructor {
    super.Constructor("Labiovelar");
  }

  override Matches(SegmentClass segment) = segment.Features.HasFlagMask(Vowel, NoFeature) and segment.Place == Places.LabialVelar;
}
//======================================================================

class DiphthongClass: FilterClass {
  var Diphthong;

  Constructor(diphthong) {
    super.Constructor("Diphthong " + diphthong);
  }

  override Matches(SegmentClass segment) = segment.Features.HasFlagMask(Vowel, NoFeature) and segment.Place == Places.LabialVelar;
}
//======================================================================

class LongShortClass: FilterClass {
  var Root;

  Constructor(root) {
    Root = root;
    super.Constructor("Long & Short " + root.Name);
  }

  override Matches(SegmentClass segment) = segment.Root == Root and segment.Features.HasFlagMask(Vowel Nasal, Vowel);
}
//======================================================================

class RootMaskClass: FeatureMaskClass {
  var Root;

  Constructor(name, mask, flag, root) {
    super.Constructor(name + Space + root, mask, flag);
    Root = root;
  }

  override Matches(SegmentClass segment) = segment.Root == Root and segment.Features.HasFlagMask(Mask, Flags);
}
//======================================================================

class RootVowelClass: FilterClass {
  Constructor() {
    super.Constructor("Root vowel");
  }

  override Matches(SegmentClass segment) = segment.Features.HasFlag(Vowel) and segment.Root != RootVowels.None;
}
//======================================================================

class DiphthongFilterClass: FilterClass {
  var Root;

  Constructor(root) {
    super.Constructor("Root+Diphthongs");
    Root = root;
  }

  override Matches(SegmentClass segment) = segment == Root or segment.DiphthongRoot == Root;
}
//======================================================================

class SegmentListClass: FilterClass {
  SegmentClass[] List;

  Constructor(name, SegmentClass[] list) {
    super.Constructor(name);
    List = list;
  }

  override Matches(SegmentClass segment) = FindAny(List, s => s == segment);
}
//======================================================================

with SegmentGroups {
  NasalVowels         = new FeatureMaskClass("Nasal Vowel", Vowel Nasal, Vowel Nasal);
  RoundedVowels       = new FeatureMaskClass("Rounded Vowel", Vowel Rounded, Vowel Rounded);
  LongVowels          = new FeatureMaskClass("Long Vowel", Vowel LongVowel, Vowel LongVowel);
  ShortVowels         = new FeatureMaskClass("Short Vowel", Vowel LongVowel, Vowel);
  AllRootVowels       = new RootVowelClass;
  Vowels              = new FeatureMaskClass("Vowel", Vowel, Vowel);
  VoicelessStops      = new FeatureMaskClass("Voiceless Stop", Voiced Stop, Stop);
  VoicedStops         = new FeatureMaskClass("Voiced Stop", Voiced Stop, Voiced Stop);
  VoicedAffricates    = new FeatureMaskClass("Voiced Affricate", Voiced Affricate, Voiced Affricate);
  VoicelessAffricates = new FeatureMaskClass("Voiceless Affricate", Voiced Affricate, Affricate);
  NasalConsonants     = new FeatureMaskClass("Nasal Consonant", Nasal, Nasal);
  Rhotics             = new FeatureMaskClass("Rhotic", Rhotic, Rhotic);
  Sibilants           = new FeatureMaskClass("Sibilant", Sibilant, Sibilant);
  Approximants        = new FeatureMaskClass("Approximant", Approximant, Approximant);
  Pulmonics           = new FeatureMaskClass("Pulmonic", Pulmonic, Pulmonic);
  VoicedFricatives    = new FeatureMaskClass("Voiced Fricative", Pulmonic Voiced Fricative, Pulmonic Voiced Fricative);
  VoicelessFricatives = new FeatureMaskClass("Voiceless Fricative", Pulmonic, Pulmonic Fricative);
  Laterals            = new FeatureMaskClass("Lateral", Lateral, Lateral);
  Diphthongs          = new FeatureMaskClass("Diphthong", Diphthong, Diphthong);
  Consonants          = new FeatureMaskClass("Consonant", Vowel, NoFeature);
  Labiovelars         = new LabiovelarFilterClass;
  LongShortRoot       = new LongShortClass(each RootVowels[1..]);
  NasalRoot           = new RootMaskClass("Nasal", Vowel Nasal LongVowel, Vowel Nasal, each RootVowels[1..]);
  LongRoot            = new RootMaskClass("Long", Vowel Nasal LongVowel, Vowel LongVowel, each RootVowels[1..]);
  ShortRoot           = new RootMaskClass("Short", Vowel Nasal LongVowel, Vowel, each RootVowels[1..]);
  NonSylabicSonorants = new SegmentListClass("Non Sylabic Sonorant", [IPA.Segments.l, IPA.Segments.r, IPA.Segments.n, IPA.Segments.m, IPA.Segments.jg, IPA.Segments.w]);
  Residue             = new FilterClass("Residue");
}
//======================================================================

class VowelsSeparatedRuleClass: RuleClass {
  Constructor {
    super.Constructor("Vowels Separated");

    Add(LongRoot);
    Add(ShortRoot);
    Add(NasalRoot);
    Add(NasalVowels);
    Add(RoundedVowels)
    Add(Vowels);
    Add(Labiovelars);
    Add(VoicelessStops);
    Add(VoicedStops);
    Add(VoicedAffricates);
    Add(VoicelessAffricates);
    Add(NasalConsonants);
    Add(Laterals);
    Add(Rhotics);
    Add(Sibilants);
    Add(Approximants);
    Add(VoicedFricatives);
    Add(VoicelessFricatives);
  }
}
//======================================================================

// This produces a tree with Catalan and Spanish in the same clade
class SegmentTypesRuleClass: RuleClass {
  Constructor {
    super.Constructor("Segment Types");

    Add(NasalVowels);
    Add(RoundedVowels);
    Add(LongVowels);
    Add(AllRootVowels);
    Add(Vowels);
    Add(VoicelessStops);
    Add(VoicedStops);
    Add(VoicedAffricates);
    Add(VoicelessAffricates);
    Add(NasalConsonants);
    Add(Rhotics);
    Add(Sibilants);
    Add(Pulmonics);
  }
}
//======================================================================

class DiphthongRuleClass: RuleClass {
  Constructor {
    super.Constructor("Diphthongs Separated");
    Add(Diphthongs);
  }

  override GetFilterIndex(SegmentClass segment) {
    var c = FilterList.Length;
    if (segment.Features.HasFlag(Diphthong))
      return c;
    FilterList.Add(new SingleFilterClass(segment));
    return c;
  }
}
//======================================================================

class DiphthongPairRuleClass: RuleClass {
  Constructor {
    super.Constructor("Diphthongs Paired with Vowels");
  }

  override void AssignCharacters {
    var count = 0;
    foreach (var segment in Results.UniqueSegments) {
      var dr = segment.DiphthongRoot;
      if (valid dr) {
        var fi = -1;
        foreach (var f in FilterList) {
          if (f.Matches(segment)) {
            fi = EachIndex;
            break;
          }
        }
        if (fi < 0) {
          SetSegmentCharacter(segment, count);
          SetSegmentCharacter(dr, count);
          Add(new DiphthongFilterClass(dr));
          ++count;
        }
        else
          SetSegmentCharacter(segment, fi);
      }
    }

    foreach (var segment in Results.UniqueSegments) {
      if (segment.CharacterIndex < 0) {
        SetSegmentCharacter(segment, count++);
        Add(new SingleFilterClass(segment));
      }
    }
    GetFilters;
  }
}
//======================================================================

class SingletonRuleClass: RuleClass {
  Constructor() {
    super.Constructor("Each segment gets a different number");
    Numbers = true;
  }

  override void AssignCharacters {
    foreach (var segment in Results.UniqueSegments) {
      SetSegmentCharacter(segment, EachIndex);
      Add(new SingleFilterClass(segment));
    }
    GetFilters;
  }
}
//======================================================================

class Partition1Class: RuleClass {
  Constructor {
    super.Constructor("Linguistically Informed");
    Numbers = true;

    Add(NasalVowels);
    Add(Vowels);
    Add(NasalConsonants);
    Add(NonSylabicSonorants);
    Add(Consonants);
    GetFilters;
  }
}
//======================================================================

class PartitionHintClass {
  var            Rate;
  PartitionClass P1,
                 P2;

  Constructor(rate, PartitionClass p1, PartitionClass p2) {
    Rate = rate;
    P1   = p1;
    P2   = p2;
  }

  AddGroup(PartitionClass p) = VBox {
    HAlign: HAligns.Center;
    Span {
      Bold;
      p.Filter.Name;
    };
    Results.ShowFilterSegments(p.Filter);
  };

  override GetPopup = HBox {
    VAlign: VAligns.Center;
    if (P1 != P2)
      AddGroup(P1);
    HBox {
      Margin: 5;
      Padding: 5;
      Background: 90%;
      VBox {
        HAlign: HAligns.Center;
        "Rate";
        Span {
          Bold;
          TextHeight: 14 pts;
          Rate;
        }
      };
    };
    AddGroup(P2);
  };
}
//======================================================================

class GroupRatesClass {
  var          PartitionRule,
               MaxLine,
               ArrowGap,
               GapAngle,
               LoopRadius,
               LoopDistance,
               MaxExtent,
               MaxRadius,
               RateScale;

  Constructor() {
    PartitionRule = Results.PartitionRule;
    MaxLine       = 10;
    ArrowGap      = 10 pts;
    GapAngle      = 80.0 degrees;
  }

  void Calibrate(size) {
    var middle = Point(size.Width * 0.5, size.Height * 0.5);

    MaxExtent    = Min([middle.X, middle.Y]);
    MaxRadius    = MaxExtent * 0.25;
    LoopRadius   = MaxRadius * 0.25;
    LoopDistance = LoopRadius * 0.5;


    var fmax   = MaxRadius / Max(Sqrt(each Results.Frequencies)); // Proportional to area, so use SQRT of frequency

    RateScale = MaxLine / Max(Max(each Results.Rates));

    foreach (var partition in PartitionRule.Partitions) {
      partition.Angle  = (2 * EachIndex *  Graphics.OneEighty / PartitionRule.Partitions.Length) - Graphics.Ninety;
      partition.Radius = Sqrt(Results.Frequencies[EachIndex]) * fmax;
    }

    var maxradius = 0.0;
    foreach (var partition in PartitionRule.Partitions)
      maxradius = Max([maxradius, partition.Radius + Results.Rates[EachIndex][EachIndex] * RateScale]);
    maxradius = MaxExtent - maxradius - LoopRadius - LoopDistance - ArrowGap;

    foreach (var partition in PartitionRule.Partitions)
      partition.Center = Graphics.ExtendPoint(middle, maxradius, partition.Angle);
  }

  PartitionDiagram(size) = Canvas {
    TransformFit: true;
    Calibrate(size);
    Size: size;

    foreach (var p1 in PartitionRule.Partitions) {
      var pi = EachIndex;
      foreach (var p2 in PartitionRule.Partitions) {
        var  rate = Results.Rates[pi][EachIndex];
        var  hint = new PartitionHintClass(rate, p1, p2);
        var  line = new LineStyleClass(rate * RateScale, 0.7, 2);
        if (p1 == p2) {
          var c = Graphics.ExtendPoint(p1.Center, p1.Radius + LoopDistance - line.LineSize*0.5, p1.Angle);
          Graphics.CircleArrow(line, c, LoopRadius, p1.Angle - Graphics.OneEighty, GapAngle) {
            Fill: Colors.Black;
            Popup: hint;
          };
        }
        else {
          var angle = Graphics.GetAngle(p1.Center, p2.Center);
          var c1    = Graphics.Adjust(p1.Center, p1.Radius + ArrowGap, angle);
          var c2    = Graphics.Adjust(p2.Center, p2.Radius + ArrowGap, angle + Graphics.OneEighty);

          Graphics.TwoArrowLine(line, c1, c2) {
            Fill: Colors.Black;
            Popup: hint;
          };
        }
      }
    }

    foreach (var p1 in PartitionRule.Partitions) {
      var pos   = p1.Center - p1.Radius;
      var fsize = p1.Radius*2;

      Figure {
        Fill: ChartColor(EachIndex);
        Stroke: 0.5 pt;
        Ellipse(Rect(pos, fsize));
      };
      HBox {
        Position: pos;
        Height: fsize;
        Frame {
          VAlignment: VAligns.Center;
          Width: fsize;
          TextHeight: p1.Radius * 0.3;
          ParAlignment: ParAlignments.Center;
          Span {
            TextHeight: 18 pts;
            Bold;
            EachOne;
          };
          p1.Filter;
          Popup: Results.ShowFilterSegments(p1.Filter);
        };
      };
    }
  };

  FrequencyChart(size) = Chart {
    Size: size;
    Type: ChartTypes.Bar;

    XAxis: ChartAxis {
      TextHeight: 8 pts;
      (each PartitionRule.Partitions).Filter;
    };
    ValueLabel: "Estimated Equilibrium Frequency";
    ValueAxis: ChartAxis;
    ChartSeries {
      foreach (var partition in PartitionRule.Partitions)
        new DataPointClass(EachIndex, Results.Frequencies[EachIndex] * 100.0) {Reference: partition.Filter};
    };
  };
}
//======================================================================

with Figures.FrequencyDiagram {
  Caption = FigureCaption {
    var rule = Results.PartitionRule;

    "For the "; Quote{rule.Name}; " model, states were grouped into five sets: ";
    Span {
      Separator: CommaSpace;
      LastSeparator: Style.AndSpace;
      foreach (var partition in rule.Partitions) {
        Span {
          partition.Filter.Name;
          " ("; EachOne; ")";
        }
      }
    };
    Style.eos;
    "Here, the area of the circles is proportional to the estimated equilibrium frequencies for each group. ";
    "The width of the arrows is proportional to the estimated rates. ";
    PaperSections.WordTransformation.Note;
  };

  Body = FigureBody {
    new GroupRatesClass.PartitionDiagram(Size(5 inches));
  };
}
//======================================================================

with Figures.SegmentFrequencies {
  Caption = FigureCaption {
    "Frequency of occurance of segments in the lexicon";
    Citation {References.Phoible};
  };

  Body = FigureBody {
    Results.FrequencyChart(Size(DocMetrics.PageContent.Width, 2 inches));
  };
}
//======================================================================

