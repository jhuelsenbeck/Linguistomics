using Format, Units, Math, IO, LinkTypes;

//======================================================================

namespace Info {
  Title          = "Understanding Linguistic History Using an Event-Based Model";
  Generations    = 50_000;
  PreBurn        = 1000;
  LinkMin        = 5;
  EXEFolder      = Folders.Repository;
  EXERelative    = Folder("x64") Folder("release");
  ReaderEXE      = EXEFolder Folder("TongueTwisterReader") EXERelative FileName("tonguetwisterreader.exe");
  MCMCEXE        = EXEFolder Folder("TongueTwister") EXERelative FileName("tonguetwister.exe");
  MacFolder      = Folder("../../../../../");

  MacReaderEXE   = MacFolder Folder("TongueTwisterReader") FileName("ttread");
  MacMCMCEXE     = MacFolder Folder("TongueTwister") FileName("tonguetwister");
  ImageFolder    = Folders.Source Folder("Images");
  ConfigFile     = FileName("config") Extensions.JSON;
  ExperimentRoot = Folders.Repository Folder("Experiments");
  WordFile       = FileName("Words") Extensions.Nytril;
  ExecuteFolder  = Folder("Execute");
  TreeFile       = ExecuteFolder FileName("consensus.tre");
  OutFileName    = ExecuteFolder Folder("out");
}

namespace DocMetrics {
  ExtentClass DocExtent = new(new(0.75 inches, 0.9 inches, 0.75 inches, 1 inches));
}

ShowString(text) = Span {
  if (valid text) {
    TextColor: Style.StringColor;
    QuoteString(text);
  }
  else
    "Empty";
};

//======================================================================

class ConfigFileClass {
  ExperimentClass    Experiment;
  RunExperimentClass Run;

  Constructor(ExperimentClass experiment, RunExperimentClass run) {
    Experiment = experiment;
    Run        = run;
  }

  AddScope = TextBlock {
    IndentSpace: 2;
    Begin: "{";
    End: "}";
  };

  AddWord(WordClass word, last) = Span {
    "  {";
    Variable("Taxon");
    var n = word.Language.GetVariableName;
    ShowString(n);
    CommaSpace;
    Space * (Experiment.Data.MaxLanguageName - n.Length);
    Variable("Segments");
    "[";
    Span {
      Separator: CommaSpace;
      (each word.Padded).Index;
    };
    Span {
      "]}";
      if (not last)
         ",";
    };
  };

  AddCognate(CognateClass cognate, last) = TextBlock {
    Span {
      "{";
      Variable("Name");
      ShowString(cognate.GetSource);
      CommaSpace;
      Variable("Data"); "[";
    };

    TextBlock {
      var good = cognate.Words.FindSlice(w => valid w.Aligned);
      var lg   = good.Length-1;
      foreach (var word in good)
        AddWord(word, each0 == lg);
    };

    Span {
      "]}";
      if (not last)
        Comma;
    };
  };

  Variable(v) = Span {
    TextColor: Style.VariableColor;
    QuoteString(v) ": ";
  };

  ArraySpan(v) = Span {
    Begin: Variable(v) {"["};
    End: "],";
  };

  AddVar(name, text, comma=true) = Span {
    Variable(name);
    text;
    if (comma)
      Comma;
  };

  StringVar(name, text, comma=true) = AddVar(name, ShowString(text), comma);

  BoolVar(name, value, comma=true) = StringVar(name, value ? "Yes" : "No", comma);

  Show = AddScope {
    TextFixed: true;
    TextHeight: 9 pts;

    Span {
      Variable("Tree");
      Quote;
      Nexus.Newick(Experiment.PriorTree);
      ";"; Quote; ",";
    };

    var data = Experiment.Data;

    TextBlock {
      Span {Variable("NumberOfStates"); data.UniqueSegments.Length; CommaSpace};

      Span {Variable("McmcSettings"); "{"};
        StringVar("Model", ToLower(Run.Mode.Model.Model));
        BoolVar("OnlyCompleteWords", false);
        AddVar("Seed", Run.Seed);
        BoolVar("CalcMarginal", Run.Marginal);
        AddVar("PrintFreq", Run.Print);
        if (Run.Marginal) {
          AddVar("FirstBurnLength", 1_000_000);
          AddVar("PreburnLength", Run.PreBurn);
          AddVar("TuneLength", 0);
          AddVar("BurnLength", 10_000);
          AddVar("SampleLength", 25_000);
          AddVar("SampleFreq", 50);
        }
        else {
          AddVar("NumCycles", Run.Generations);
          AddVar("SampleFreq", 100);
        }
        AddVar("TreeLengthPriorVal", 0.15, false);
      "},";
    };

/*
    Model              -- Substitution model (jc69/gtr/custom)
    BrlenPriorVal      -- Parameter of exponential branch length prior
    OnlyCompleteWords  -- Use only completely sampled words (no/yes)
                       -- Number of gamma rate categories (=1 is no rate variation)
                       -- Number of gamma indel categories (=1 is no indel rate variation)
    CalcMarginal       -- Calculate marginal likelihood (no/yes)
    Seed               -- Seed for pseudo random number generator
    NumCycles          -- Number of MCMC cycles
    PrintFreq          -- Print-to-screen frequency
    SampleFreq         -- Chain sample frequency
    CheckPtFreq        -- Check point file frequency
    NumTunings         -- Number of tunings
    TuneLength         -- Tune length
    PreburnLength      -- Preburnin length
    StoneSampleLength  -- Sample length
    StoneSampleFreq    -- Stone sample frequency
*/

    ArraySpan("Taxa") {
      Separator: CommaSpace;
      ShowString(each (each data.Taxa).Variable);
    };

    ArraySpan("PriorFrequencies") {
      TextDigits: 6;
      Separator: CommaSpace;
      (each data.UniqueSegments).UsedFrequency;
    };

    ArraySpan("PartitionSets") {
      Separator: Comma;
      foreach (var partition in Experiment.Rule.Partitions) {
        Span {
          "{";
          Variable("Name");
          ShowString(partition.Name);
          CommaSpace;
          Variable("Set");
          "[";
          Span {
            Separator: CommaSpace;
            (each partition.Segments).Index;
          };
          "]}";
        }
      }
    };

    Span {
      Variable("Words"); "[";
    };
    TextBlock {
      var last = data.UsedCognates.Length-1;
      foreach (var cognate in data.UsedCognates)
        AddCognate(cognate, each0 == last);
    };
    "]";
  };
}
//======================================================================

