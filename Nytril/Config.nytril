using Format, Units, Math, IO, LinkTypes;

//======================================================================

namespace Info {
  LinkMin          = 5;
  EXEFolder        = Folders.Repository;
  EXERelative      = Folder("x64") Folder("release");
  ReaderEXE        = EXEFolder Folder("TongueTwisterReader") EXERelative FileName("tonguetwisterreader.exe");
  MCMCEXE          = EXEFolder Folder("TongueTwister") EXERelative FileName("tonguetwister.exe");
  MacFolder        = Folder("../../../../../");

  MacReaderEXE     = MacFolder Folder("TongueTwisterReader") FileName("ttread");
  MacMCMCEXE       = MacFolder Folder("TongueTwister") FileName("tonguetwister");
  ImageFolder      = Folders.Source Folder("Images");
  ConfigFile       = FileName("config") Extensions.JSON;
  ExecuteFolder    = Folder("Execute");
  ExperimentFolder = Folder("Experiments");
  WordFile         = FileName("Words") Extensions.Nytril;
}

//======================================================================

class ConfigFileClass {
  ExperimentClass    Experiment;
  RunExperimentClass Run;

  Constructor(ExperimentClass experiment, RunExperimentClass run) {
    Experiment = experiment;
    Run        = run;
  }

  AddScope = TextBlock {
    IndentSpace: 2;
    Begin: "{";
    End: "}";
  };

  AddWord(WordClass word, last) = Span {
    "  {";
    Variable("Taxon");
    var n = word.Language.GlobalVariableName;
    ShowString(n);
    CommaSpace;
    Space * (Experiment.Data.MaxLanguageName - n.Length);
    Variable("Segments");
    "[";
    Span {
      Separator: CommaSpace;
      (each word.Padded).Index;
    };
    Span {
      "]}";
      if (not last)
         ",";
    };
  };

  AddCognate(CognateClass cognate, last) = TextBlock {
    Span {
      "{";
      Variable("Name");
      ShowString(cognate.GetSource);
      CommaSpace;
      Variable("Data"); "[";
    };

    TextBlock {
      var good = cognate.Words.FindSlice(w => valid w.Aligned);
      var lg   = good.Length-1;
      foreach (var word in good)
        AddWord(word, each0 == lg);
    };

    Span {
      "]}";
      if (not last)
        Comma;
    };
  };

  ShowString(text) = Span {
    TextColor: Style.StringColor;
    QuoteString(text);
  };

  Variable(v) = Span {
    TextColor: Style.VariableColor;
    QuoteString(v) ": ";
  };

  ArraySpan(v) = Span {
    Begin: Variable(v) {"["};
    End: "],";
  };

  AddVar(name, text, comma=true) = Span {
    Variable(name);
    text;
    if (comma)
      Comma;
  };

  StringVar(name, text, comma=true) = AddVar(name, ShowString(text), comma);

  BoolVar(name, value, comma=true) = StringVar(name, value ? "Yes" : "No", comma);

  Show = AddScope {
    TextFixed: true;
    TextHeight: 9 pts;

    Span {
      Variable("Tree");
      Quote;
      Nexus.Newick(Experiment.PriorTree);
      ";"; Quote; ",";
    };

    var data = Experiment.Data;

    TextBlock {
      Span {Variable("NumberOfStates"); data.UniqueSegments.Length; CommaSpace};

      Span {Variable("McmcSettings"); "{"};
        StringVar("Model", ToLower(Run.Mode.Model.Model));
        BoolVar("OnlyCompleteWords", false);
        AddVar("Seed", Run.Seed);
        BoolVar("CalcMarginal", Run.Marginal);
        AddVar("PrintFreq", Run.Print);
        if (Run.Marginal) {
          AddVar("NumTunings", 2);
          AddVar("TuneLength", 1000);
          AddVar("PreburnLength", Run.PreBurn);
          AddVar("StoneSampleLength", 10_000);
          AddVar("StoneSampleFreq", 50);
        }
        else {
          AddVar("NumCycles", Run.Generations);
          AddVar("SampleFreq", 100);
        }
        AddVar("TreeLengthPriorVal", 0.15, false);
      "},";
    };

/*
    Model              -- Substitution model (jc69/gtr/custom)
    BrlenPriorVal      -- Parameter of exponential branch length prior
    OnlyCompleteWords  -- Use only completely sampled words (no/yes)
                       -- Number of gamma rate categories (=1 is no rate variation)
                       -- Number of gamma indel categories (=1 is no indel rate variation)
    CalcMarginal       -- Calculate marginal likelihood (no/yes)
    Seed               -- Seed for pseudo random number generator
    NumCycles          -- Number of MCMC cycles
    PrintFreq          -- Print-to-screen frequency
    SampleFreq         -- Chain sample frequency
    CheckPtFreq        -- Check point file frequency
    NumTunings         -- Number of tunings
    TuneLength         -- Tune length
    PreburnLength      -- Preburnin length
    StoneSampleLength  -- Sample length
    StoneSampleFreq    -- Stone sample frequency
*/

    ArraySpan("Taxa") {
      Separator: CommaSpace;
      ShowString(each (each data.Taxa).Variable);
    };

    ArraySpan("PriorFrequencies") {
      Span {
        TextDigits: 6;
        Separator: Comma;
        (each data.UniqueSegments).UsedFrequency;
      };
    };

    ArraySpan("PartitionSets") {
      Span {
        Separator: Comma;
        foreach (var partition in Experiment.Rule.Partitions) {
          Span {
            "{";
            Variable("Name");
            ShowString(partition.Filter.Name);
            CommaSpace;
            Variable("Set");
            "[";
            Span {
              Separator: CommaSpace;
              (each partition.Segments).Index;
            };
            "]}";
          }
        }
      };
    };

    Span {
      Variable("Words"); "[";
    };
    TextBlock {
      var last = data.UsedCognates.Length-1;
      foreach (var cognate in data.UsedCognates)
        AddCognate(cognate, each0 == last);
    };
    "]";
  };
}
//======================================================================

