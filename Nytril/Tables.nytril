using Format, Units, IPA, SegmentFeatures, Math;
//======================================================================

class EulerDiagramClass {
  Constructor {
  }

  TitleStyle = {TextColor: 70%};
  ChartSize  = 6 inches;
  EX(x)      = ChartSize * x * 0.01;
  EY(y)      = ChartSize * y * 0.01;

  Enclosure(x, y, w, h, ColorClass color) = Canvas(EX(w), EY(h), 1 pt) {
    BorderRadius: 6 pts;
    Background: color;
    X: EX(x);
    Y: EY(y);
  };

  NameBox(name, angle=0) = HBox {
    Transform: Rotate(angle);
    TransformFit: true;
    Paragraph {
      TitleStyle;
      Space;
      name;
      Space;
    };
  };

  VNameFrame(name, x, y, width, height, ColorClass color) = Enclosure(x, y, width, height, color) {
    VAlign: VAligns.Center;
    NameBox(name, 90 degrees)
  };

  FeatureMask = Vowel Nasal Vocoid Approximant Vibrant Lateral Affricate Occlusive Strident Sibilant Obstruent Continuant Fricative Rhotic Liquid Trill TapFlap;

  FeatureSegments(SegmentClass[] segments, features) = segments.FindSlice(s => s.Features.HasFlagMask(FeatureMask, features));

  FeatureFrame(SegmentClass[] segments, x, y, width, name, features) = Canvas {
    X: EX(x);
    Y: EY(y);
    Frame(EX(width)) {
      ParAlignment: ParAlignments.Center;
      if (name is valid)
        Span {TitleStyle; name};
      Paragraph {
        Separator: Space;
        (each FeatureSegments(segments, features)).ShowSegment;
      }
    }
  };

  FeatureChart(SegmentClass[] segments) = Canvas {
    TextHeight: 16 pts;

    VNameFrame(Lang.Occlusive, 10, 0, 90, 34, new(255, 238, 238)) {
      HAlign: HAligns.Right;
    };
    VNameFrame(Lang.Continuant, 10, 35, 90, 37, new(229, 255, 255)) {
      HAlign: HAligns.Right;
    };
    VNameFrame(Lang.Obstruent, 0, 11, 94, 40, new(238, 238, 255, 50%));
    VNameFrame(Lang.Vocoid, 0, 52, 78, 21, new(238, 255, 238, 50%));
    VNameFrame(Lang.Vibrant, 20, 74, 65, 17, new(238, 238, 255));

    Enclosure(11, 1, 83, 9, new(255, 246, 246));   // Nasals
    Enclosure(31, 12, 62, 21, new(246, 242, 250));  // Affricates
    Enclosure(11, 12, 19, 21, new(246, 243, 250));  // Plosives
    Enclosure(11, 36, 80, 14, new(240, 247, 255));  // Fricatives

    Enclosure(25, 75, 59, 7, new(247, 247, 255)) {
      HAlign: HAligns.Left;
      VAlign: VAligns.Center;
      NameBox(Lang.TapFlap);
    };

    Enclosure(25, 83, 53, 7, new(247, 247, 255)) {
      HAlign: HAligns.Left;
      VAlign: VAligns.Center;
      NameBox(Lang.Trill);
    };

    Enclosure(53, 13, 39, 36, new(233, 248, 235, 50%)) {
      HAlign: HAligns.Center;
      NameBox(Lang.Strident);
    };

    Enclosure(62, 18, 25, 24, new(245, 252, 220, 50%)); // Sibilants
    Enclosure(11, 53, 21, 18, new(240, 255, 247));      // Vowels
    Enclosure(33, 53, 61, 18, new(240, 255, 247, 50%)) {
      HAlign: HAligns.Left;
      NameBox(Lang.Approximant);
    };

    Enclosure(35, 59, 21, 11, new(248, 255, 225)); // Semivowels

    Enclosure(64, 43, 26, 59, new(255, 238, 238, 50%)) {
      HAlign: HAligns.Center;
      VAlign: VAligns.Bottom;
      NameBox(Lang.Liquid);
    };

    Enclosure(65, 44, 14, 52, new(255, 247, 221, 50%)) {
      HAlign: HAligns.Center;
      VAlign: VAligns.Bottom;
      NameBox(Lang.Rhotic);
    };

    Enclosure(80, 44, 9, 44, new(238, 247, 230, 70%)) {
      HAlign: HAligns.Right;
      VAlign: VAligns.Bottom;
      NameBox(Lang.Lateral, 90 degrees);
    };

    FeatureFrame(segments, 11, 1, 84, Lang.Nasal, Nasal Occlusive);
    FeatureFrame(segments, 12, 14, 17, Lang.Plosive, Stop Occlusive);
    FeatureFrame(segments, 32, 14, 20, Lang.Affricate, Affricate Occlusive);
    FeatureFrame(segments, 54, 20, 7, null, Affricate Occlusive Strident);
    FeatureFrame(segments, 65, 18, 18, Lang.Sibilant, Affricate Occlusive Strident Sibilant);
    FeatureFrame(segments, 14, 38, 22, Lang.Fricative, Fricative Obstruent Continuant);
    FeatureFrame(segments, 54, 38, 6, null, Fricative Obstruent Continuant Strident);
    FeatureFrame(segments, 64, 36, 20, null, Fricative Obstruent Continuant Strident Sibilant);
    FeatureFrame(segments, 66, 44, 10, null, Fricative Obstruent Continuant Strident Rhotic Liquid);
    FeatureFrame(segments, 80, 44, 10, null, Fricative Obstruent Continuant Strident Lateral Liquid);
    FeatureFrame(segments, 12, 53, 19, Lang.Vowel, Vowel Vocoid Continuant);
    FeatureFrame(segments, 36, 60, 19, Lang.SemiVowel, Vocoid Semivowel Approximant Continuant);
    FeatureFrame(segments, 57, 62, 5, null, Vocoid Approximant);
    FeatureFrame(segments, 66, 60, 10, null, Vocoid Approximant Rhotic Liquid);
    FeatureFrame(segments, 82, 58, 5, null, Vocoid Approximant Rhotic Liquid Lateral);
    FeatureFrame(segments, 54, 76, 10, null, Vibrant TapFlap);
    FeatureFrame(segments, 66, 76, 10, null, Vibrant TapFlap Rhotic Liquid);
    FeatureFrame(segments, 77, 77, 10, null, Vibrant TapFlap Rhotic Liquid Lateral);
    FeatureFrame(segments, 54, 84, 10, null, Vibrant Trill);
    FeatureFrame(segments, 66, 84, 10, null, Vibrant Trill Rhotic Liquid);
  };
}
//======================================================================

readonly namespace DisplayWords {
  WordRow(WordClass word, index) = Style.RowBar(index) {
    Span {
      Style.SansSerif;
      word.Cognate.GetTitle;
    };

    Cell {
      word.ShowPlain;
    };
    Cell {
      Span {
        (each word.Segments).ShowBlock;
      }
    }
  };

  HeaderCell(d) = Cell(new(new(0, 2 pts), new(0, 2 pts), new(0, 2 pts), new(1, 2 pts))) {
    Style.SansSerif;
    Style.TitleBackground;
    d
  };

  ShowLanguage(DataSetClass data, TaxonClass taxon) = Block {
    Style.TitleBar {taxon.Language};
    Table(0.5, null, [new(ColumnClass.Fit(2.1 inches), null, PadLR(5)), new(ColumnClass.Fit(1 inches), null, PadR(5)), ColumnClass.Expand]) {
      Row {
        HeaderCell(Lang.Cognate);
        HeaderCell(Lang.IPA);
        HeaderCell(Lang.Segments);
      };

      var i = 0;
      foreach (var cognate in data.GetSortedCognates) {
        foreach (var word in cognate.Words[taxon.Index]) {
          if (word.Segments is valid)
            WordRow(word, i++);
        }
      }
    };
    Paragraph;
  };

  ShowWordsByLanguage(DataSetClass data) = Block {
    ShowLanguage(data, each data.Taxa);
  };
}
//======================================================================

readonly namespace AllWords {
  AddCell(TaxonClass taxon, CognateClass cognate, textheight) = Cell {
    Background: each0 mod 2 == 0 ? 97% : null;
    cognate.Words[taxon.Index].ShowPaddedBlocks(textheight);
  };

  AddRow(TaxonClass taxon, CognateClass[] cognates, textheight) = Row {
    Cell(PadL(1 pt)) {
      Style.SansSerif;
      TextColor: Colors.DarkGray;
      taxon.Language;
    };
    AddCell(taxon, each cognates, textheight)
  };

  ConceptTable(DataSetClass data, textheight, wordsperline, CognateClass[] cognates) = HBox {
    var first = 84 pts;
    var w     = (ExtentWidth - first) / wordsperline;
    Table(0.5, null, [first] + [w] * wordsperline) {
      Style.IPAFamily;
      Row {
        Style.TitleBackground;
        Style.SansSerif;
        Empty;
        (each cognates).GetTitle;
      };

      AddRow(each data.Taxa, cognates, textheight);
    };
    Paragraph;
  };

  ShowConceptTable(DataSetClass data, CognateClass cognate) = ConceptTable(data, 10 pts, 7, [cognate]);

  ShowTable(textheight, DataSetClass data, int max=1000000) = Block {
    TextHeight: textheight;
    var wordsperline = Math.Round(ExtentWidth / (13 * (textheight intu pixels)));

    foreach (var cognates in (data.GetSortedCognates / wordsperline)) {
      if (each0 >= max)
        break;
      ConceptTable(data, textheight, wordsperline, cognates);
    }
  };
}

readonly namespace MatchCell {
  SegmentText(HashSetClass set, SegPartClass segment) {
    if (not segment.Segment.Impossible) {
      set.Add(segment);
      return segment.ShowSegment;
    }
    return null;
  }

  SegmentBox(HashSetClass set, SegPartClass segment, color) = Canvas(DocMetrics.BoxSize.Width, DocMetrics.BoxSize.Height) {
    HAlign: HAligns.Center;
    if (segment.?Ipa is valid) {
      TextHeight: DocMetrics.BoxSize.Height - 6 pts;
      TextColor: color;
      SegmentText(set, segment)
    }
    else
      Style.ImpossibleBackground;
  };

  ShowBox(HashSetClass set, SegPartClass segment, color) = SegmentBox(set, segment, color) {
    if (segment.Features.HasFlag(Voiced))
      X: DocMetrics.BoxSize.Width;
  };

  ErrorMatches(HashSetClass set, matches) = Span {
    Separator: CommaSpace;
    TextColor: Colors.Red;
    MatchCell.SegmentText(set, each matches);
  };
}
//======================================================================

class TabOptionsClass {
   var Title,
       Exclude,
       Include,
       All,
       Manners,
       RowMask,
       Notes,
       RowLabels;

  Constructor(title) {
    Title = title;
  }

  CheckFlags(sflags, rflags) {
    return sflags.NotFlag(Exclude) and
           sflags.HasFlag(Include) and
           sflags.HasFlagMask(RowMask | rflags, rflags);
  }

  MatchError(matches) = matches.Length > 2 or (matches.Length == 2 and matches[0].Features.HasFlag(Voiced) == matches[1].Features.HasFlag(Voiced));

  SegmentBlock(SegmentSetClass set, matches) = Cell {
    if (matches is valid) {
      if (matches.Length == 1 and matches[0].Segment.Impossible)
        Style.ImpossibleBackground;
      else {
        Span {
          if (MatchError(matches))
            MatchCell.ErrorMatches(set, matches);
          else {
            Canvas(DocMetrics.CellSize.Width, DocMetrics.CellSize.Height) {
              MatchCell.ShowBox(set, each matches, Colors.Black)
            }
          }
        }
      }
    }
  };

  AddRow(DataSetClass data, SegmentSetClass set, Places[] places, manner) = Row(Style.SegmentBottom) {
    Cell {
      VAlign: VAligns.Center;
      Style.TitleBackground;
      TextHeight: 7 pts;

      if (RowLabels is valid)
        RowLabels[each0];
      else
        manner;
    };

    var features = manner | All;
    var all      = data.UniqueSegments + new SegPartClass(each ImpossibleSegments);
    foreach (var place in places)
      SegmentBlock(set, all.FindSlice(s => s.Segment.?Place == place and CheckFlags(s.Features, features)));
  };

  MatchInclude(SegPartClass segment, Places place) {
    return segment.Segment.?Place == place and
           segment.Features.NotFlag(Exclude) and
           segment.Features.HasFlag(Include) and
           Manners.FindAny(manner => CheckFlags(segment.Features, manner | All));
  }

  MatchPlace(DataSetClass data, place) {
    return data.UniqueSegments.FindAny(segment => MatchInclude(segment, place));
  }

  ShowTable(DataSetClass data, SegmentSetClass set) = Block {
    Style.TitleBar {
      Title
    };

    var places = Places.Values.FindSlice(place => MatchPlace(data, place));
    if (places.Length == 0)
      Lang.None;
    else {
      var first  = 75 pts;
      var cw     = Math.Min((ExtentWidth - first) / places.Length, 75 pts);

      Table(Style.TableBorder, null, [new ColumnClass(first, BorderR(0.5 pts))] + [new ColumnClass(cw, null, null, HAligns.Center)]) {
        Row {
          TextHeight: 6 pts;
          Style.HeaderCell {
            Bold;
            Lang.Manner;
          };

          foreach (var place in places) {
            Style.HeaderCell {
              place;
            };
          }
        };
        AddRow(data, set, places, each Manners);
      };

      Style.TableNotes {
        Lang.ImpossibleShaded;
        Space;
        Notes;
      };
    }
  };
}
//======================================================================

readonly namespace MatchingConsonants {
  PulmonicTable = new TabOptionsClass(Lang.PConsonants) {
    Exclude: Affricate Ejective;
    Include: Pulmonic;
    All: NoFeature;
    Manners: [Nasal Stop, Nasal, Stop, Sibilant Fricative, Fricative, Approximant, TapFlap, Trill, Lateral Fricative, Lateral Approximant, Lateral TapFlap];
    RowMask: Nasal Stop Sibilant Fricative Approximant TapFlap Trill Lateral Velarized;
    Notes: Lang.SymbolPairVoiced
  };

  NonPulmonicTable = new TabOptionsClass(Lang.NPConsonants) {
    Exclude: Vowel Pulmonic Central;
    Include: Ejective Click Implosive Palatalized Implosive Lateral Approximant;
    All: NoFeature;
    Manners: [Stop, Ejective Stop, Ejective Fricative, Ejective Lateral Fricative, Click Tenuis, Click Nasal, Click Tenuis Lateral, Implosive, Lateral Approximant];
    RowMask: Lateral;
    Notes: Lang.SymbolPairVoiced
  };

  PulmonicAffricatesTable = new TabOptionsClass(Lang.PulmonicAffricates) {
    Exclude: Vowel;
    Include: Affricate Sibilant Lateral;
    All: Pulmonic Affricate;
    RowLabels: [Lang.Sibilant, Lang.Lateral, "Voiced", Lang.NonSibilant];
    Manners: [Sibilant, Lateral, Voiced, NoFeature];
    RowMask: Pulmonic Affricate Sibilant Fricative Lateral;
  };

  EjectiveAffricatesTable = new TabOptionsClass(Lang.EjectiveAffricates) {
    Exclude: Vowel Click Implosive Pulmonic;
    Include: Ejective Affricate Central Lateral;
    All: Ejective Affricate;
    Manners: [Central, Lateral];
    RowMask: Pulmonic Approximant Central Lateral;
  };
}
//======================================================================

readonly namespace MatchingVowels {
  FeatureMask = Vowel LongVowel Nasal Diphthong NonSylabic;

  AddCell(SegPartClass[] segments, SegmentSetClass set, open, backness, features) = Cell(Style.SegmentBottom) {
    HAlign: HAligns.Center;
    TextHeight: DocMetrics.BoxSize.Height;

    var filter  = s => s.Segment.Backness == backness and s.Segment.Open == open and s.Features.HasFlagMask(FeatureMask, features);
    var matches = segments.FindSlice(filter);
    switch (matches.Length) {
      case 0:
        break;

      case 1:
        MatchCell.SegmentText(set, matches[0]);
        break;

      case 2:
        Span {
          MatchCell.SegmentText(set, matches[0]);
          "â€¢" {TextColor: Colors.LightGray};
          MatchCell.SegmentText(set, matches[1]);
        };
        break;

      default:
        MatchCell.ErrorMatches(set, matches);
        break;
    }
  };

  AddRow(SegPartClass[] segments, SegmentSetClass set, open, features) = Row {
    Cell {
      VAlign: VAligns.Center;
      Style.TitleBackground;
      open.Name;
    };
    AddCell(segments, set, open, each Backnesses, features)
  };

  ShowVowelTable(SegPartClass[] segments, SegmentSetClass set, features) = Block {
    Style.TitleBar {
      Separator: "-";
      each features
    };

    var border = BorderR(0.5 pts);
    Table(Style.TableBorder, null, [new ColumnClass(1 inch, border)] + [new ColumnClass(DocMetrics.BoxSize.Width*4, border)]) {
      HAlign: HAligns.Center;
      Row {
        TextHeight: 10 pts;
        Style.HeaderCell;
        foreach (var b in Backnesses) {
          Style.HeaderCell {
            b;
          };
        }
      };
      AddRow(segments, set, each Opens, features);
    };
  };

  ShowTable(SegPartClass[] segments, SegmentSetClass set) = Block {
    Lang.SymbolPairRounded;
    ShowVowelTable(segments, set, Vowel);
    ShowVowelTable(segments, set, Vowel LongVowel);
    ShowVowelTable(segments, set, Vowel Nasal);
    ShowVowelTable(segments, set, Vowel LongVowel Nasal);
    ShowVowelTable(segments, set, Vowel Diphthong);
    ShowVowelTable(segments, set, Vowel Nasal Diphthong);
    ShowVowelTable(segments, set, Vowel NonSylabic);
    ShowVowelTable(segments, set, Vowel NonSylabic Diphthong);
  };
}
//======================================================================
// Diacritic markers
//======================================================================

readonly namespace MatchingDiacritics {
  ColumnDiv = 3;

  AddCell(SegmentClass segment) = Cell {
    Paragraph {
      LeftIndent: 30 pts;
      FirstIndent: -30 pts;
      DocFields.Anchor(segment.GetVariable);
      segment.ShowSegment {
        TextHeight: 18 pts;
      };
      Tab;
      segment.Description
    }
  };

  AddRow(segments) = Row {
    AddCell(each segments)
  };

  ShowTable = Block {
    Style.TitleBar {Lang.Diacritics};
    Table(Style.TableBorder, null, [ExtentWidth / ColumnDiv] * ColumnDiv) {
      AddRow(each (DiacriticModifiers / ColumnDiv));
    };
    Style.TableNotes;
  };
}
//======================================================================
// Segments not in other lists
//======================================================================

readonly namespace MatchingOther {
  ColumnDiv = 2;

  AddRow(SegPartClass[] segments) = Row {
    VAlign: VAligns.Center;
    foreach (var segment in segments) {
      var s = segment.Segment;
      Cell {
        HAlign: HAligns.Center;
        Paragraph {
          TextHeight: 18 pts;
          s.ShowSegment;
        };
      };
      s.SegmentName;
    }
  };

  ShowTable(SegPartClass[] segments, SegmentSetClass set) = Block {
    Style.TitleBar {Lang.OtherSegments};
    Table(Style.TableBorder, null, [DocMetrics.CellSize.Width, ExtentWidth * 0.5 - DocMetrics.CellSize.Width] * ColumnDiv) {
      var slice = segments.FindSlice(segment => not set.Contains(segment));
      AddRow(each (slice / ColumnDiv));
    };
    Style.TableNotes;
  };
}
//======================================================================

readonly namespace Utility {
  ShowLanguages(DataSetClass data) = Block {
    var rows      = 2;
    var cols      = (data.Taxa.Length + 1) div rows;
    var taxagroup = data.Taxa / cols;
    var h         = 14 pts;
    var space     = 5 pts;
    var border    = 1 pts;
    var size      = new SizeClass(ExtentWidth / cols - space, ExtentHeight / rows - space*(rows-1) - (border*2*rows));

    VBox {
      HAlign: HAligns.Center;

      foreach (var group in taxagroup) {
        HBox(null, null, PadT(space)) {
          VAlign: VAligns.Top;

          foreach (TaxonClass taxon in group) {
            VBox(size.Width, size.Height) {
              Margin: PadR(space);
              HAlign: HAligns.Center;

              Paragraph {
                TextHeight: h;
                Bold;
                taxon.Language;
              };

              var s = new SizeClass(size.Width, size.Height - h);
              HBox(s.Width, s.Height, new EdgeClass(1, 0, 90%)) {
                VAlign: VAligns.Center;
                BorderRadius: 20 pts;
                BorderClip: true;

                Span {
                  TipAction: taxon.Language;
                  taxon.Language.ShowMap(s);
                }
              };
            }
          }
        }
      }
    }
  };
}
//======================================================================

class SegmentDisplayClass {
  DataSetClass   Data;
  SegPartClass[] SortedSegments,
                 DisplaySegments;

  Constructor(DataSetClass data) {
    Data            = data;
    DisplaySegments = data.UniqueSegments;  // Could be IPA.Segments if you want to see all possible segments in the debug tables
    SortedSegments  = data.UniqueSegments.Sort(true, ref CompareAlpha);
  }

  static CompareSegments(SegPartClass s0, SegPartClass s1, options) = s0.UsedCount - s1.UsedCount;

  static CompareAlpha(SegPartClass s0, SegPartClass s1, options) {
    var i = s0.Ipa.Length.Compare(s1.Ipa.Length);
    if (i == 0)
      i = -s0.Ipa.Compare(s1.Ipa);
    return i;
  }

  FrequencyChart(SizeClass size) = Chart(size.Width, size.Height) {
    TextHeight: 11 pts;
    Style.SansSerif;
    Type: ChartTypes.Column;
    Legend: ChartLegend {Placement: Placements.Bottom};
    ValueLabel: HBox {
      Lang.FrequencyPercent;
      Transform: Rotate(90 degrees);
      TransformFit: true;
    };

    SegPartClass[] sorted = DisplaySegments.Sort(true, ref CompareSegments);
    XAxis: ChartAxis {
      TextHeight: DocMetrics.SegmentTextFactor * size.Width / sorted.Length;
      (each sorted).ShowSegment;
    };
    ValueAxis: ChartAxis;
    ChartSeries {
      TextDigits: 3;
      Label: Lang.Experiment;
      foreach (var s in sorted)
        new DataPointClass(each0, s.UsedFrequency * 100.0) {Reference: s};
    };
  };

  ShowSegmentAssignments = Paragraph {
    var textheight = 18 pts;
    TextHeight: textheight;

    foreach (var segment in DisplaySegments) {
      HBox(textheight * 3.25, null, new EdgeClass(0.25 pts, 1, 85%)) {
        VAlign: VAligns.Center;
        Margin: 5;
        Span {
          HAlignment: HAligns.Center;
          TextColor: Colors.LightGray;
          TextHeight: 75%;
          each0;
        };
        Space*4;
        segment.ShowSegment;
      }
    }
  };

  SegmentCell(SegPartClass segment) = Cell(new EdgeClass(0.25 pts, 2 pts, Colors.LightGray)) {
    segment.Segment.Display(segment.GetVariable?.FullName, 16 pts);
  };

  IPASegmentTable = Block {
    var c = DocMetrics.SegmentColumns;

    Table(null, null, [ExtentWidth / c]) {
      foreach (var s in (SortedSegments / c)) {
        Row {
          SegmentCell(each s);
        }
      }
    };
    Style.TableNotes;
  };

  ShowLanguageDetails = Block {
    foreach (var taxon in Data.Taxa) {
      var language = taxon.Language;
      Style.Header2 {
        language.Name;
      };
      Block {
        Paragraph {
          ParAlignment: ParAlignments.Center;
          language.ShowMap(new(5 inches, 3 inches));
        };
        language.Description;
        language.Details;
      }
    }
  };

  ShowConceptGroups = Block {
    WordGroups[] groups = WordGroups.Values[1..];
    Table(Style.TableBorder, null, [0.25 inches] + [1 inch] * (2+groups.Length)) {
      Row {
        Style.HeaderCell;
        Style.HeaderCell {
          Lang.Concept;
        };
        Style.HeaderCell {
          "Type";
        };
        foreach (var g in groups) {
          Style.HeaderCell {
            g.Name;
          };
        }
      };
      foreach (var concept in Data.UsedConcepts) {
        Style.RowBar(each0) {
          each0;
          concept.Name;
          concept.WordType.Name;
          foreach (var g in groups) {
            Cell {
              HAlign: HAligns.Center;
              if (concept.WordGroup.HasFlag(g))
                Tex.bullet;
            }
          }
        }
      }
    }
  };

  ShowWordsForEachSegment = Block {
    foreach (var segment in SortedSegments) {
      Paragraph(null, [0.5 inches]) {
        KeepWithNext: true;
        TextHeight: 16 pts;
        ParBackground: 90%;
        segment.ShowSegment;
       };

      Paragraph {
        ParAlignment: ParAlignments.Justify;
        Style.IPAFamily;
        SpaceAfter: 10 pts;
        Span {
          Separator: Space*2;
          foreach (var cognate in Data.GetSortedCognates) {
            foreach (var word in cognate.Words) {
              if (word.Segments.FindAny(segment)) {
                Span {
                  TipAction: word;
                  word.ShowPlain;
                }
              }
            }
          }
        };
      };
    }
  };
}

//======================================================================

