using Format, Units, IPA, IPA.FeatureSet;
//======================================================================

with Results {
  FindMeaning(word, data) = word.Meaning == data;

  GetGeneText(meaning, language) {
    var words    = language.Words.FindSlice(FindMeaning, meaning, 1);
    var segments = words.Length == 1 ? words[0].Segments : [IPA.NoSegment];
    return {
      Language: language,
      Meaning: meaning,
      Word: words[0],
      Segments: segments,
      Count: segments.Length
    }
  }

  GetMeaningRecord(meaning) {
    var cells = GetGeneText(meaning, each UsedLanguages);
    return {
       Cells: cells,
       MaxLength: ((each cells).Count).Max
    };
  }

  AddBlank(list, index) {
    list.AddElement(IPA.GapSegment);
  }

  AddWord(list, langindex, meaning) {
    var ma   = WordMeaningArray[EachIndex];
    var cell = ma.Cells[langindex];
    var pad  = ma.MaxLength - cell.Count;
    list.AddElement(IPA.LeftSegment);
    list.AddElement(each cell.Segments);
    if (pad > 0)
      AddBlank(list, each 1..pad);
    list.AddElement(IPA.RightSegment);
  }

  GetSegments(langindex) {
    var list = Type.List(150);
    AddWord(list, langindex, each UsedMeanings);
    return list;
  }

  SegmentToCharacter(segment) {
    if (segment.Punctuation) {
      return {
        Character: segment.Ipa,
        Segment: segment
      };
    }

    var f = UniqueSegments.FindIndex(DisplayCharacters.SameSegment, {Segment: segment});
    if (f.Length == 1) {
      return {
        Character: Nexus.CharacterList[f[0]],
        Segment: segment
      };
    }
    else {
      return {
        Character: '?',
        Segment: IPA.NoSegment
      };
    }
  }

  GetTaxaArray(lang) {
    var segments = GetSegments(EachIndex);
    return {
      TaxonName: lang.Name,
      Segments: segments,
      Characters: SegmentToCharacter(each segments)
    }
  }

  LangHasWords(language) = language.Words != null;
  UsedLanguages          = Languages.FindSlice(LangHasWords);
  UsedMeanings           = CompleteMeanings.Find;
  WordMeaningArray       = GetMeaningRecord(each UsedMeanings);
  UniqueSegments         = DisplayCharacters.FindUniqueSegments(UsedLanguages);
  TaxaArray              = GetTaxaArray(each UsedLanguages);
  LanguageTreeFile       = Nexus.TreeFile(Info.LanguageTree);
  CharacterFile          = Nexus.CharacterFile(TaxaArray);

//  UsedSegments = UniqueSegments;
  UsedSegments = IPA.Segments;

}
//======================================================================
// Consonants
//======================================================================

with MatchingConsonants {
  PulmonicTable = {
    Title: Lang.PConsonants,
    ColWidth: 45 pts,
    Exclude: Affricate Ejective,
    Include: Pulmonic,
    All: NoFeature,
    Manners: [Nasal, Stop, Sibilant Fricative, Fricative, Approximant, TapFlap, Trill, Lateral Fricative, Lateral Approximant, Lateral TapFlap],
    RowMask: Nasal Stop Sibilant Fricative Approximant TapFlap Trill Lateral Velarized,
    Notes: Lang.SymbolPairVoiced
  };

  NonPulmonicTable = {
    Title: Lang.NPConsonants,
    ColWidth: 80 pts,
    Exclude: Vowel Pulmonic Central,
    Include: Ejective Click Implosive,
    All: NoFeature,
    Manners: [Ejective Stop, Ejective Fricative, Ejective Lateral Fricative, Click Tenuis, Click Nasal, Click Tenuis Lateral, Implosive],
    RowMask: Lateral,
    Notes: Lang.SymbolPairVoiced
  };

  PulmonicAffricatesTable = {
    Title: Lang.PulmonicAffricates,
    ColWidth: 50 pts,
    Exclude: Vowel,
    Include: Affricate Sibilant Lateral,
    All: Pulmonic Affricate,
    RowLabels: [Lang.Sibilant, Lang.NonSibilant, Lang.Lateral],
    Manners: [Sibilant, NoFeature, Lateral],
    RowMask: Pulmonic Affricate Sibilant Fricative Lateral,
  };

  EjectiveAffricatesTable = {
    Title: Lang.EjectiveAffricates,
    ColWidth: 50 pts,
    Exclude: Vowel Click Implosive Pulmonic,
    Include: Ejective Affricate Central Lateral,
    All: Ejective Affricate,
    Manners: [Central, Lateral],
    RowMask: Pulmonic Approximant Central Lateral,
  };

  ShowTables {
    var segments = Type.Dictionary(256);
    return Block {
      MatchingOptions.ShowTable(segments, each [PulmonicTable, NonPulmonicTable]),
      PageBreak,
      MatchingVowels.ShowTable(segments),
      MatchingOptions.ShowTable(segments, each [PulmonicAffricatesTable, EjectiveAffricatesTable]),
      MatchingOther.ShowTable(segments),
    }
  }
}
//======================================================================

with DisplayWords {
  WordRow(word) = Row {
    Style.RowBar(EachIndex),
    Cell {
      Style.SansSerif,
      Style.TitleBackground,
      word.Meaning
    },
    Cell {
      ShowSampa(word.Sampa)
    },
    Cell {
      Span {
        ShowSegment(each word.Segments)
      },
    },
    Cell {
      Span {
        Separator: "-",
        SegmentSound(each word.Segments)
      }
    }
  };

  HeaderCell(d) = Cell {
    Style.SansSerif,
    Style.TitleBackground,
    EdgeB: 1 pts,
    Padding: 2 pts,
    d
  };

  ShowTable(language) = Block {
    Table {
      Columns: [0.8 inches, 1 inches, 1 inches, Metrics.Content.Width - 2.5 inches],
      Style.TitleBar(language.Name, 4),
      Row {
        HeaderCell(Lang.Meaning),
        HeaderCell(Lang.Sampa),
        HeaderCell(Lang.IPA),
        HeaderCell(Lang.Sounds),
      },
      WordRow(each language.Words)
    },
    Style.TableNotes
  };
}
//======================================================================

with AllWords {
  AddCell(meaning, language) = Cell {
    ShowIPA(each IPA.FindWordsWithMeaning(language, meaning))
  };

  AddRow(language, meanings) = Row {
    Cell {
      Style.SansSerif,
      TextColor: Colors.DarkGray,
      language.Name
    },
    AddCell(each meanings, language)
  };

  MeaningTable(languages, meanings) = Block {
    Table {
      Edge: 0.5,
      Columns: [70 pts] + [54 pts] * meanings.Length,
      Row {
        Style.TitleBackground,
        Style.SansSerif,
        Empty,
        each meanings,
      },
      AddRow(each languages, meanings)
    },
    Paragraph,
  };

  ShowTable(languages, meanings) = Block {
    TextHeight: 12 pts,
    MeaningTable(languages, each (meanings / 8))
  };
}
//======================================================================

with DisplayCharacters {
  WordMatch(meaning, def) = meaning == def.Meaning;
  CompleteWord(def)       = Results.UsedMeanings.Contains(WordMatch, def);
  GetWordList(language)   = language.Words.FindSlice(CompleteWord);


  CollectWord(set, word) {
    set.AddElement(each word.Segments);
  }

  CollectLanguage(set, language) {
    CollectWord(set, each GetWordList(language));
  }

  FindUniqueSegments(languagelist) {
    var set = Type.Dictionary(256);
    CollectLanguage(set, each languagelist);
    return set.ValueList;
  }

  SameSegment(segment, data) = segment == data.Segment;

  CollectLangWord(set, segment, word) {
    if (word.Segments.Contains(SameSegment, {Segment: segment}))
      set.AddElement(word, word.Sampa);
  }

  CollectLanguageWords(set, segment, language) {
    CollectLangWord(set, segment, each GetWordList(language));
  }

  WordsWithSegment(segment) {
    var set = Type.Dictionary(256);
    CollectLanguageWords(set, segment, each Results.UsedLanguages);
    return set.ValueList;
  }

  CharacterRow(segment) = Row {
    Cell {
      HAlign: HAligns.Center,
      Style.TitleBackground,
      Nexus.CharacterList[EachIndex]
    },
    Cell {
      HAlign: HAligns.Center,
      ShowSegment(segment),
    },
    Cell {
      Style.IPAFamily,
      Span {
        Separator: Lang.Separator,
        ShowIPA(each WordsWithSegment(segment))
      }
    }
  };

  ShowTable = Block {
    Table {
      Style.TableEdge,
      Columns: [0.5 inches, 0.7 inches, 6 inches],
      Row {
        Style.HeaderCell("Char.", HAligns.Center),
        Style.HeaderCell(Lang.Segment, HAligns.Center),
        Style.HeaderCell("Words containing this segment")
      },
      CharacterRow(each Results.UniqueSegments),
    },
    Style.TableNotes
  };
}
//======================================================================
// Consonants
//======================================================================

with MatchingOptions {
  CheckFlags(sflags, rflags, options) = sflags.NotFlag(options.Exclude) and sflags.HasFlag(options.Include) and sflags.HasFlagMask(options.RowMask | rflags, rflags);

  AnyManners(f, data)                 = CheckFlags(data.Features, f | data.Options.All, data.Options);

  SamePlace(segment, data)            = segment.?Place && data.?Place && segment.Place == data.Place;
  MatchRow(segment, data)             = SamePlace(segment, data) and CheckFlags(segment.Features, data.Features, data.Options);

  MatchInclude(segment, data)         = SamePlace(segment, data) and segment.Features.NotFlag(data.Options.Exclude) and
                                        segment.Features.HasFlag(data.Options.Include) and
                                        data.Options.Manners.Contains(AnyManners, {Features: segment.Features, Options: data.Options});

  MatchPlace(place, options)          = AllSegments.Contains(MatchInclude, {Place: place, Options: options});
  GetPlaces(options)                  = Places.FindSlice(MatchPlace, options);


  SegmentText(segments, segment) {
    if (not segment.Impossible)
      segments.AddElement(segment);
    return ShowSegment(segment);
  }

  SegmentBox(segments, segment, color) = Canvas {
    HAlign: HAligns.Center,
    Size: Metrics.BoxSize,
    if (segment.?Ipa) {
      TextHeight: Metrics.BoxSize.Height - 4 pts,
      TextColor: color,
      SegmentText(segments, segment)
    }
    else
      Style.ImpossibleBackground;
  };

  ShowBox(segments, segment, color) = SegmentBox(segments, segment, color) {
    if (segment.Features.HasFlag(Voiced))
      X: Metrics.BoxSize.Width;
  };

  MatchError(matches) = matches.Length > 2 or (matches.Length == 2 and matches[0].Features.HasFlag(Voiced) == matches[1].Features.HasFlag(Voiced));

  SegmentBlock(segments, matches) = Cell {
    Style.SegmentBottom,
    if (matches.Length > 0) {
      if (matches.Length == 1 and matches[0].Impossible)
        Style.ImpossibleBackground;
      else {
        TextHeight: 1 pts,
        Span {
          Canvas {
            Size: Metrics.CellSize,
            ShowBox(segments, each matches, MatchError(matches) ? Colors.Red : Colors.Black)
          }
        }
      }
    }
  };

  AddCell(segments, options, place, f) = SegmentBlock(segments, AllSegments.FindSlice(MatchRow, {Place: place, Features: f, Options: options}));

  AddRow(segments, options, places, f) {
    var allflags = f | options.All;
    return Row {
      Cell {
        VAlign: VAligns.Center,
        EdgeR: 0.5 pts,
        Style.TitleBackground,
        PaddingLR: 2 pts,
        TextHeight: 7 pts,

        if (options.?RowLabels)
          options.RowLabels[EachIndex];
        else
          f;
      },
      AddCell(segments, options, each places, allflags)
    }
  }

  PlaceHeader(place) = Style.HeaderCell(place.Name, HAligns.Center);

  ShowTable(segments, options) {
    var places = GetPlaces(options);

    return Block {
      Table {
        Style.TableEdge,
        Columns: [options.ColWidth {EdgeR: 0.5 pts}] +
                 [Metrics.CellSize.Width {HAlign: HAligns.Center, EdgeR: 0.25 pts}] * places.Length,

        Style.TitleBar(options.Title, places.Length+1),
        Row {
          TextHeight: 6 pts,
          Style.HeaderCell(Bold Lang.Manner),
          PlaceHeader(each places)
        },
        AddRow(segments, options, places, each options.Manners),
      },
      Style.TableNotes {
        Lang.ImpossibleShaded,
        Space,
        options.?Notes
      },
    };
  }
}
//======================================================================
// Vowels
//======================================================================

with MatchingVowels {
  AddBlock(set, matches) = Cell {
    Style.SegmentBottom,
    HAlign: HAligns.Center,
    TextHeight: Metrics.BoxSize.Height,
    if (matches.Length == 2) {
      Span {
        MatchingOptions.SegmentText(set, matches[0]),
        " • " {TextColor: Colors.LightGray},
        MatchingOptions.SegmentText(set, matches[1]),
      }
    }
    else if (matches.Length == 1)
      MatchingOptions.SegmentText(set, matches[0]);
  };

  MatchVowelAny(segment, data)          = segment.Features.HasFlagMask(Vowel LongVowel Nasal, data.Feature | Vowel) and segment.Open == data.Open;
  MatchVowelPair(segment, data)         = segment.?Backness and data?.Backness and segment.Backness == data.Backness and MatchVowelAny(segment, data);
  FindAnyOpen(set, feature, open)       = Results.UsedSegments.Contains(MatchVowelAny, {Open: open, Feature: feature});
  AddCell(set, feature, open, backness) = AddBlock(set, Results.UsedSegments.FindSlice(MatchVowelPair, {Open: open, Feature: feature, Backness: backness}));

  AddRow(set, feature, open) {
    if (FindAnyOpen(set, feature, open)) {
      return Row {
        Cell {
          VAlign: VAligns.Center,
          Style.TitleBackground,
          open.Name
        },
        AddCell(set, feature, open, each Backnesses)
      };
    }
    else
      return null;
  }

  ShowVowelTable(set, feature, title) = Table {
    HAlign: HAligns.Center,
    Style.TableEdge,
    Columns: [(1 inch){EdgeR: 0.5 pts}] + [Metrics.BoxSize.Width*3 {EdgeR: 0.25 pts}] * Backnesses.Length,
    Style.TitleBar(title, Backnesses.Length+1),
    Row {
      TextHeight: 10 pts,
      Style.HeaderCell(Empty),
      Style.HeaderCell(each Backnesses, HAligns.Center)
    },
    AddRow(set, feature, each Opens)
  };

  ShowTable(set) = Block {
    ShowVowelTable(set, NoFeature, Lang.Vowels),
    Style.TableNotes {
      Lang.SymbolPairRounded,
    },
    ShowVowelTable(set, LongVowel, Lang.LongVowels),
    Paragraph,
  };
}
//======================================================================
// Diacritic markers
//======================================================================

with MatchingDiacritics {
  ColumnDiv = 3;

  AddCell(segment) = Cell {
    Paragraph {
      LeftIndent: 0.5 inches,
      FirstIndent: -0.5 inches,
      LocationMark: segment.Key,
      ShowSegment(segment) {
        TextHeight: 18 pts,
        Tab,
      },
      segment.Description
    }
  };

  AddRow(segments) = Row {
    AddCell(each segments)
  };

  ShowTable = Block {
    Table {
      Style.TableEdge,
      Columns: [Metrics.Content.Width / ColumnDiv] * ColumnDiv,
      Style.TitleBar(Lang.Diacritics, ColumnDiv),
      AddRow(each DiacriticModifiers / ColumnDiv),
    },
    Style.TableNotes
  };
}
//======================================================================
// Segments not in other lists
//======================================================================

with MatchingOther {
  MatchOther(segment, set) = not set.Contains(segment);

  ColumnDiv = 2;

  AddCell(segment) = {
    Cell {
      VAlign: VAligns.Center,
      HAlign: HAligns.Center,
      TextHeight: 20 pts,
      LocationMark: segment.Key,
      ShowSegment(segment),
    },
    Cell {
      VAlign: VAligns.Center,
      SegmentName(segment)
    }
  };

  AddRow(segments) = Row {
    AddCell(each segments)
  };

  ShowTable(set) = Block {
    Table {
      Style.TableEdge,
      Columns: [Metrics.BoxSize.Width, Metrics.Content.Width * 0.5 - Metrics.BoxSize.Width] * ColumnDiv,
      Style.TitleBar(Lang.OtherSegments, ColumnDiv*2),
      AddRow(each (Results.UsedSegments.FindSlice(MatchOther, set) / ColumnDiv)),
    },
    Style.TableNotes
  };
}
//======================================================================
// Find the list of meanings for which there is a word in every language
//======================================================================

with CompleteMeanings {
  ContainsMeaning(word, data)    = word.Meaning == data.Meaning;
  WithoutMeaning(language, data) = not language.Words.Contains(ContainsMeaning, data);

  CollectMeanings(set, meaning) {
    if (not Results.UsedLanguages.Contains(WithoutMeaning, {Meaning: meaning}))
      set.AddElement(meaning);
  }

  Find {
    var set = Type.Dictionary(128);
    CollectMeanings(set, each WordMeanings);
    return set.ValueList;
  }

  AddRow(meaning) = Row {
    Cell {
      HAlign: HAligns.Center,
      Style.TitleBackground,
      EachIndex+1
    },
    Cell {
      meaning.Name
    }
  };

  ShowTable = Block {
    Table {
      Style.TableEdge,
      Columns: [0.5 inches, 4 inches],
      Style.TitleBar(Lang.Meanings, 3),
      Row {
        Style.HeaderCell(Empty),
        Style.HeaderCell(Lang.Meaning)
      },
      AddRow(each Results.UsedMeanings),
    },
    Style.TableNotes
  };
}
//======================================================================
// Segment Tree
//======================================================================

with SegmentTree {
  AddNode(name) = Node {
    Bevel: 20%,
    Curvature: 20%,
    Label: name
  };

  AddSegment(set, segment) {
    set.AddElement(segment);
    return ShowSegment(segment)
  }

  AddSegments(set, name, func, data) {
    var segments = Results.UsedSegments.FindSlice(func, data);
    if (segments.Length > 0) {
      return Node {
        Label: Frame {
          Width: 3.5 inches,
          Paragraph {
            LeftIndent: 1 inches,
            FirstIndent: -1 inches,
            Span {
              TextColor: Colors.DarkGray,
              name,
              ":\t",
            },
            Span {
              TextHeight: 12 pts,
              Separator: Space,
              AddSegment(set, each segments),
            }
          }
        }
      };
    }
    else
      return null;
  }

  MatchVowel(segment, data) = segment.Features.HasFlag(Vowel) and segment.Backness == data.Backness;
  AddVowels(set, backness)  = AddSegments(set, backness.Name, MatchVowel, {Backness: backness});

  MatchFlags(segment, data) = not data.Set.Contains(segment) and segment.Features.HasFlagMask(data.All, data.Features) and segment.Features.HasFlagMask(data.Other, data.Other);
  AddFlag(set, all, features, f)   = AddSegments(set, f.Name, MatchFlags, {Set: set, All: all, Features: features, Other: f});

  AddConsonants(set, name, all, features) = AddNode(name) {
    AddFlag(set, all, features, each [Tenuis, Click, Nasal, Ejective, Fricative, Sibilant, Lateral, Stop, Approximant, TapFlap, Trill, NoFeature]),
  };

  MatchAny(segment, data) = true;

  AddVoicedPairs(set, name, all, features) = AddNode(name) {
    AddConsonants(set, Lang.Voiced, all Voiced, features Voiced),
    AddConsonants(set, Lang.Voiceless, all Voiced, features),
  };

  ShowTree {
    var set1 = Type.Dictionary(256);
    var set2 = Type.Dictionary(256);
    var all  = Vowel Pulmonic Affricate;

    return Block {
      Tree {
        Width: 7 inches,
        LabelGap: 3 pts,
        Node {
          AddNode(Lang.Vowels) {
            AddVowels(set1, each Backnesses)
          },
          AddNode(Lang.Affricates) {
            AddVoicedPairs(set1, Lang.NonPulmonic, all, Affricate),
            AddVoicedPairs(set1, Lang.Pulmonic, all, Pulmonic Affricate),
          },
          AddNode(Lang.Consonants) {
            AddVoicedPairs(set1, Lang.Pulmonic, all, Pulmonic),
            AddVoicedPairs(set1, Lang.NonPulmonic, all, NoFeature),
          },
          AddSegments(set2, Lang.OtherSegments, MatchAny, set1)
        }
      }
    }
  }
}
//======================================================================
// SAMPA table
//======================================================================

with SAMPAConversion {
  ShowSampaLine(segment) = Span {
    segment.Sampa
  };

  AddRow(segment) = Row {
    Cell {
      ShowSampa(segment.Sampa)
    },
    Cell {
      ShowSegment(segment)
    },
    Cell {
      segment.Name
    }
  };

  AlphaOrder(x, y) {
    var cl = Math.Compare(x.Sampa.Length, y.Sampa.Length);
    if (cl == 0)
      cl = -Math.Compare(x.Sampa, y.Sampa);
    return cl;
  }

  SortedSampa = IPA.SampaSet.Sort(false, AlphaOrder);

  ShowTable = Block {
    Table {
      Style.TableEdge,
      Columns: [0.75 inches, 0.75 inches, 4 inches],
      Row {
        Style.HeaderCell(Lang.Sampa),
        Style.HeaderCell(Lang.IPA),
        Style.HeaderCell(Lang.Segment)
      },
      AddRow(each SortedSampa),
    },
    Style.TableNotes
  };
}
//======================================================================

