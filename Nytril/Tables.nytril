using Format, Units, IPA, SegmentFeatures, Math;
//======================================================================

class EulerDiagramClass {
  Constructor {
  }

  TitleStyle = {TextColor: 70%};
  ChartSize  = 6 inches;
  EX(x)      = ChartSize * x * 0.01;
  EY(y)      = ChartSize * y * 0.01;

  Enclosure(x, y, w, h, color) = Canvas {
    BorderStroke: 1 pts;
    Corner: 6 pts;
    Background: color;
    X: EX(x);
    Y: EY(y);
    Size: Size(EX(w), EY(h));
  };

  NameBox(name, angle=0) = Paragraph {
    TitleStyle;
    Transform: Rotate(angle);
    TransformFit: true;
    Space;
    name;
    Space;
  };

  VNameFrame(name, x, y, width, height, color) = Enclosure(x, y, width, height, color) {
    VAlign: VAligns.Center;
    NameBox(name, 90 degrees)
  };

  FeatureMask = Vowel Nasal Vocoid LongVowel Semivowel Approximant Vibrant Lateral Affricate Occlusive Strident Sibilant Obstruent Continuant Fricative Rhotic Liquid Trill TapFlap;

  FeatureSegments(DataSetClass data, features) = data.DisplaySegments.FindSlice(segment => segment.Features.HasFlagMask(FeatureMask, features));

  FeatureFrame(DataSetClass data, x, y, width, name, features) = Canvas {
    X: EX(x);
    Y: EY(y);
    Frame {
      Width: EX(width);
      ParAlignment: ParAlignments.Center;
      if (exists name)
        Span {TitleStyle; name};
      Paragraph {
        Separator: Space;
        (each FeatureSegments(data, features)).ShowSegment;
      }
    }
  };

  FeatureChart(DataSetClass data) = Canvas {
    TextHeight: 16 pts;

    VNameFrame(Lang.Occlusive, 10, 0, 90, 34, Color(255, 238, 238)) {
      HAlign: HAligns.Right;
    };
    VNameFrame(Lang.Continuant, 10, 35, 90, 37, Color(229, 255, 255)) {
      HAlign: HAligns.Right;
    };
    VNameFrame(Lang.Obstruent, 0, 11, 94, 40, Color(238, 238, 255, 50%));
    VNameFrame(Lang.Vocoid, 0, 52, 78, 21, Color(238, 255, 238, 50%));
    VNameFrame(Lang.Vibrant, 20, 74, 65, 17, Color(238, 238, 255));

    Enclosure(11, 1, 83, 9, Color(255, 246, 246));   // Nasals
    Enclosure(31, 12, 62, 21, Color(246, 242, 250));  // Affricates
    Enclosure(11, 12, 19, 21, Color(246, 243, 250));  // Plosives
    Enclosure(11, 36, 80, 14, Color(240, 247, 255));  // Fricatives

    Enclosure(25, 75, 59, 7, Color(247, 247, 255)) {
      HAlign: HAligns.Left;
      VAlign: VAligns.Center;
      NameBox(Lang.TapFlap);
    };
    Enclosure(25, 83, 53, 7, Color(247, 247, 255)) {
      HAlign: HAligns.Left;
      VAlign: VAligns.Center;
      NameBox(Lang.Trill);
    };

    Enclosure(53, 13, 39, 36, Color(233, 248, 235, 50%)) {
      HAlign: HAligns.Center;
      NameBox(Lang.Strident);
    };

    Enclosure(62, 18, 25, 24, Color(245, 252, 220, 50%)); // Sibilants
    Enclosure(11, 53, 21, 18, Color(240, 255, 247));      // Vowels
    Enclosure(33, 53, 61, 18, Color(240, 255, 247, 50%)) {
      HAlign: HAligns.Left;
      NameBox(Lang.Approximant);
    };

    Enclosure(35, 59, 21, 11, Color(248, 255, 225)); // Semivowels

    Enclosure(64, 43, 26, 59, Color(255, 238, 238, 50%)) {
      HAlign: HAligns.Center;
      VAlign: VAligns.Bottom;
      NameBox(Lang.Liquid);
    };

    Enclosure(65, 44, 14, 52, Color(255, 247, 221, 50%)) {
      HAlign: HAligns.Center;
      VAlign: VAligns.Bottom;
      NameBox(Lang.Rhotic);
    };

    Enclosure(80, 44, 9, 44, Color(238, 247, 230, 70%)) {
      HAlign: HAligns.Right;
      VAlign: VAligns.Bottom;
      NameBox(Lang.Lateral, 90 degrees);
    };

    FeatureFrame(data, 11, 1, 84, Lang.Nasal, Nasal Occlusive);
    FeatureFrame(data, 12, 14, 17, Lang.Plosive, Stop Occlusive);
    FeatureFrame(data, 32, 14, 20, Lang.Affricate, Affricate Occlusive);
    FeatureFrame(data, 54, 20, 7, null, Affricate Occlusive Strident);
    FeatureFrame(data, 65, 18, 18, Lang.Sibilant, Affricate Occlusive Strident Sibilant);
    FeatureFrame(data, 14, 38, 22, Lang.Fricative, Fricative Obstruent Continuant);
    FeatureFrame(data, 54, 38, 6, null, Fricative Obstruent Continuant Strident);
    FeatureFrame(data, 64, 36, 20, null, Fricative Obstruent Continuant Strident Sibilant);
    FeatureFrame(data, 66, 44, 10, null, Fricative Obstruent Continuant Strident Rhotic Liquid);
    FeatureFrame(data, 80, 44, 10, null, Fricative Obstruent Continuant Strident Lateral Liquid);
    FeatureFrame(data, 12, 53, 19, Lang.Vowel, Vowel Vocoid Continuant);
    FeatureFrame(data, 36, 60, 19, Lang.SemiVowel, Vocoid Semivowel Approximant Continuant);
    FeatureFrame(data, 57, 62, 5, null, Vocoid Approximant);
    FeatureFrame(data, 66, 60, 10, null, Vocoid Approximant Rhotic Liquid);
    FeatureFrame(data, 82, 58, 5, null, Vocoid Approximant Rhotic Liquid Lateral);
    FeatureFrame(data, 54, 76, 10, null, Vibrant TapFlap);
    FeatureFrame(data, 66, 76, 10, null, Vibrant TapFlap Rhotic Liquid);
    FeatureFrame(data, 77, 77, 10, null, Vibrant TapFlap Rhotic Liquid Lateral);
    FeatureFrame(data, 54, 84, 10, null, Vibrant Trill);
    FeatureFrame(data, 66, 84, 10, null, Vibrant Trill Rhotic Liquid);
  };
}
//======================================================================

namespace DisplayWords {
  WordRow(WordClass word, index) = Row {
    Style.RowBar(index);
    Cell {
      word.ShowConcept;
    };
    Cell {
      word.Plain;
    };
    Cell {
      Span {
        (each word.Segments).ShowBlock;
      }
    }
  };

  HeaderCell(d) = Cell {
    Style.SansSerif;
    Style.TitleBackground;
    EdgeB: 1 pts;
    Padding: 2 pts;
    d
  };

  ShowLanguage(DataSetClass data, TaxonClass taxon) = Block {
    Style.TitleBar {taxon.Language};
    Table {
      Edge: 0.5;
      Columns: [2.1 inches, 1 inches, DocMetrics.PageContent.Width - 3.1 inches];
      Row {
        HeaderCell(Lang.Cognate);
        HeaderCell(Lang.IPA);
        HeaderCell(Lang.Segments);
      };

      var i = 0;
      foreach (var cognate in data.SortedCognates) {
        foreach (var word in cognate.Words[taxon.Index]) {
          if (valid word.Segments)
            WordRow(word, i++);
        }
      }
    };
    Paragraph;
  };

  ShowWordsByLanguage(DataSetClass data) {
    return ShowLanguage(data, each data.Taxa);
  }
}
//======================================================================

namespace AllWords {
  AddCell(TaxonClass taxon, CognateClass cognate, textheight) = Cell {
    Background: each0 mod 2 == 0 ? 97% : null;
    cognate.Words[taxon.Index].ShowPaddedBlocks(textheight);
  };

  AddRow(TaxonClass taxon, CognateClass[] cognates, textheight) = Row {
    Cell {
      PaddingL: 1 pt;
      Style.SansSerif;
      TextColor: Colors.DarkGray;
      taxon.Variable;
    };
    AddCell(taxon, each cognates, textheight)
  };

  ConceptTable(DataSetClass data, textheight, wordsperline, CognateClass[] cognates) = HBox {
    var first = 84 pts;
    var w     = (DocMetrics.PageContent.Width - first) / wordsperline;
    Table {
      Style.IPAFamily;
      Edge: 0.5;
      Columns: [first] + [w] * wordsperline;

      Row {
        Style.TitleBackground;
        Style.SansSerif;
        Empty;
        (each cognates).GetTitle;
      };

      AddRow(each data.Taxa, cognates, textheight);
    };
    Paragraph;
  };

  ShowConceptTable(DataSetClass data, CognateClass cognate) = ConceptTable(data, 10 pts, 7, [cognate]);

  ShowTable(textheight, DataSetClass data, max=1000000) = Block {
    TextHeight: textheight;
    var wordsperline = Math.Round(DocMetrics.PageContent.Width / (13 * (textheight intu pixels)));

    foreach (var cognates in (data.SortedCognates / wordsperline)) {
      if (each0 >= max)
        break;
      ConceptTable(data, textheight, wordsperline, cognates);
    }
  };
}

namespace MatchCell {
  SegmentText(HashSetClass set, SegmentClass segment) {
    if (not segment.Impossible) {
      set.Add(segment);
      return segment.ShowSegment;
    }
    return null;
  }

  SegmentBox(HashSetClass set, SegmentClass segment, color) = Canvas {
    HAlign: HAligns.Center;
    Size: DocMetrics.BoxSize;
    if (exists segment.?Ipa) {
      TextHeight: DocMetrics.BoxSize.Height - 6 pts;
      TextColor: color;
      SegmentText(set, segment)
    }
    else
      Style.ImpossibleBackground;
  };

  ShowBox(HashSetClass set, SegmentClass segment, color) = SegmentBox(set, segment, color) {
    if (segment.Features.HasFlag(Voiced))
      X: DocMetrics.BoxSize.Width;
  };

  ErrorMatches(HashSetClass set, matches) = Span {
    Separator: CommaSpace;
    TextColor: Colors.Red;
    MatchCell.SegmentText(set, each matches);
  };
}
//======================================================================

class TabOptionsClass {
   var Title,
       ColWidth,
       Exclude,
       Include,
       All,
       Manners,
       RowMask,
       Notes,
       RowLabels;

  Constructor(title) {
    Title = title;
  }

  CheckFlags(sflags, rflags) {
    return sflags.NotFlag(Exclude) and
           sflags.HasFlag(Include) and
           sflags.HasFlagMask(RowMask | rflags, rflags);
  }

  MatchError(matches) = matches.Length > 2 or (matches.Length == 2 and matches[0].Features.HasFlag(Voiced) == matches[1].Features.HasFlag(Voiced));

  SegmentBlock(SegmentSetClass set, matches) = Cell {
    Style.SegmentBottom;
    if (valid matches) {
      if (matches.Length == 1 and matches[0].Impossible)
        Style.ImpossibleBackground;
      else {
        Span {
          if (MatchError(matches))
            MatchCell.ErrorMatches(set, matches);
          else {
            Canvas {
              Size: DocMetrics.CellSize;
              MatchCell.ShowBox(set, each matches, Colors.Black)
            }
          }
        }
      }
    }
  };

  MatchInclude(SegmentClass segment, place) {
    return segment.?Place == place and
           segment.Features.NotFlag(Exclude) and
           segment.Features.HasFlag(Include) and
           Manners.FindAny(manner => CheckFlags(segment.Features, manner | All));
  }

  MatchPlace(DataSetClass data, place) {
    return data.UniqueSegments.FindAny(segment => MatchInclude(segment, place));
  }

  AddRow(DataSetClass data, SegmentSetClass set, places, f) = Row {
    var features = f | All;
    Cell {
      VAlign: VAligns.Center;
      EdgeR: 0.5 pts;
      Style.TitleBackground;
      PaddingLR: 2 pts;
      TextHeight: 7 pts;

      if (exists RowLabels)
        RowLabels[each0];
      else
        f;
    };

    var all = data.DisplaySegments;// + IPA.ImpossibleSegments;
    foreach (var place in places)
      SegmentBlock(set, all.FindSlice(s => s.?Place == place and CheckFlags(s.Features, features)));
  };

  ShowTable(DataSetClass data, SegmentSetClass set) = Block {
    var places = Places.FindSlice(place => MatchPlace(data, place));
    Style.TitleBar {Title};
    Table {
      Style.TableEdge;
      Columns: [ColWidth {EdgeR: 0.5 pts}] +
               [DocMetrics.CellSize.Width {HAlign: HAligns.Center; EdgeR: 0.25 pts}] * places.Length;

      Row {
        TextHeight: 6 pts;
        Style.HeaderCell {
          Bold;
          Lang.Manner;
        };
        foreach (var place in places) {
          Style.HeaderCell {
            HAligns: HAligns.Center;
            place.Name;
          };
        }
      };
      AddRow(data, set, places, each Manners);
    };

    Style.TableNotes {
      Lang.ImpossibleShaded;
      Space;
      Notes;
    };
  };
}
//======================================================================

namespace MatchingConsonants {
  PulmonicTable = new TabOptionsClass(Lang.PConsonants) {
    ColWidth: 45 pts;
    Exclude: Affricate Ejective;
    Include: Pulmonic;
    All: NoFeature;
    Manners: [Nasal Stop, Nasal, Stop, Sibilant Fricative, Fricative, Approximant, TapFlap, Trill, Lateral Fricative, Lateral Approximant, Lateral TapFlap];
    RowMask: Nasal Stop Sibilant Fricative Approximant TapFlap Trill Lateral Velarized;
    Notes: Lang.SymbolPairVoiced
  };

  NonPulmonicTable = new TabOptionsClass(Lang.NPConsonants) {
    ColWidth: 80 pts;
    Exclude: Vowel Pulmonic Central;
    Include: Ejective Click Implosive Palatalized Implosive Lateral Approximant;
    All: NoFeature;
    Manners: [Stop, Ejective Stop, Ejective Fricative, Ejective Lateral Fricative, Click Tenuis, Click Nasal, Click Tenuis Lateral, Implosive, Lateral Approximant];
    RowMask: Lateral;
    Notes: Lang.SymbolPairVoiced
  };

  PulmonicAffricatesTable = new TabOptionsClass(Lang.PulmonicAffricates) {
    ColWidth: 50 pts;
    Exclude: Vowel;
    Include: Affricate Sibilant Lateral;
    All: Pulmonic Affricate;
    RowLabels: [Lang.Sibilant, Lang.Lateral, "Voiced", Lang.NonSibilant];
    Manners: [Sibilant, Lateral, Voiced, NoFeature];
    RowMask: Pulmonic Affricate Sibilant Fricative Lateral;
  };

  EjectiveAffricatesTable = new TabOptionsClass(Lang.EjectiveAffricates) {
    ColWidth: 50 pts;
    Exclude: Vowel Click Implosive Pulmonic;
    Include: Ejective Affricate Central Lateral;
    All: Ejective Affricate;
    Manners: [Central, Lateral];
    RowMask: Pulmonic Approximant Central Lateral;
  };
}
//======================================================================

namespace MatchingVowels {
  FeatureMask = Vowel LongVowel Nasal Diphthong NonSylabic;

  AddCell(DataSetClass data, SegmentSetClass set, open, backness, features) = Cell {
    Style.SegmentBottom;
    HAlign: HAligns.Center;
    TextHeight: DocMetrics.BoxSize.Height;

    var filter  = segment => segment.Backness == backness and segment.Open == open and segment.Features.HasFlagMask(FeatureMask, features);
    var matches = data.DisplaySegments.FindSlice(filter);
    switch (matches.Length) {
      case 0:
        break;

      case 1:
        MatchCell.SegmentText(set, matches[0]);
        break;

      case 2:
        Span {
          MatchCell.SegmentText(set, matches[0]);
          "•" {TextColor: Colors.LightGray};
          MatchCell.SegmentText(set, matches[1]);
        };
        break;

      default:
        MatchCell.ErrorMatches(set, matches);
        break;
    }
  };

  AddRow(DataSetClass data, SegmentSetClass set, open, features) = Row {
    Height: 16 pts;
    Cell {
      VAlign: VAligns.Center;
      Style.TitleBackground;
      open.Name;
    };
    AddCell(data, set, open, each Backnesses, features)
  };

  ShowVowelTable(DataSetClass data, SegmentSetClass set, features) = Block {
    Style.TitleBar {Separator: "-"; each features};
    Table {
      HAlign: HAligns.Center;
      Style.TableEdge;
      Columns: [(1 inch){EdgeR: 0.5 pts}] + [DocMetrics.BoxSize.Width*4 {EdgeR: 0.25 pts}] * Backnesses.Length;
      Row {
        TextHeight: 10 pts;
        Style.HeaderCell;
        foreach (var b in Backnesses) {
          Style.HeaderCell {
            HAligns: HAligns.Center;
            b;
          };
        }
      };
      AddRow(data, set, each Opens, features);
    };
  };

  ShowTable(DataSetClass data, SegmentSetClass set) = Block {
    var features = [
      Vowel,
      Vowel LongVowel,
      Vowel Nasal,
      Vowel LongVowel Nasal,
      Vowel Diphthong,
      Vowel Nasal Diphthong,
      Vowel NonSylabic,
      Vowel NonSylabic Diphthong,
    ];

    Lang.SymbolPairRounded;
    ShowVowelTable(data, set, each features);
  };
}
//======================================================================
// Diacritic markers
//======================================================================

namespace MatchingDiacritics {
  ColumnDiv = 3;

  AddCell(SegmentClass segment) = Cell {
    Paragraph {
      LeftIndent: 30 pts;
      FirstIndent: -30 pts;
      LocationMark: segment.GlobalVariablePath;
      segment.ShowSegment {
        TextHeight: 18 pts;
      };
      Tab;
      segment.Description
    }
  };

  AddRow(segments) = Row {
    AddCell(each segments)
  };

  ShowTable = Block {
    Style.TitleBar {Lang.Diacritics};
    Table {
      Style.TableEdge;
      Columns: [DocMetrics.PageContent.Width / ColumnDiv] * ColumnDiv;
      AddRow(each (DiacriticModifiers / ColumnDiv));
    };
    Style.TableNotes;
  };
}
//======================================================================
// Segments not in other lists
//======================================================================

namespace MatchingOther {
  ColumnDiv = 2;

  AddCell(SegmentClass segment) = {
    Cell {
      VAlign: VAligns.Center;
      HAlign: HAligns.Center;
      LocationMark: segment.GlobalVariablePath;
      TextHeight: 18 pts;
      segment.ShowSegment;
    };
    Cell {
      VAlign: VAligns.Center;
      segment.SegmentName;
    }
  };

  AddRow(SegmentClass[] segments) = Row {
    AddCell(each segments)
  };

  ShowTable(DataSetClass data, SegmentSetClass set) = Block {
    Style.TitleBar {Lang.OtherSegments};
    Table {
      Style.TableEdge;
      Columns: [DocMetrics.CellSize.Width, DocMetrics.PageContent.Width * 0.5 - DocMetrics.CellSize.Width] * ColumnDiv;
      var segments = data.DisplaySegments.FindSlice(segment => not set.Contains(segment));
      AddRow(each (segments / ColumnDiv));
    };
    Style.TableNotes;
  };
}
//======================================================================
// Segment Tree
//======================================================================

namespace SegmentTree {
  AddNode(name) = new NodeClass(name) {
    Bevel: 20%;
    Curvature: 20%;
  };

  AddSegments(DataSetClass data, DictionaryClass set, name, predicate, width=3 inches) {
    var segments = data.DisplaySegments.FindSlice(predicate);
    if (valid segments) {
      var label = Frame {
        Width: width;
        Paragraph {
          LeftIndent: 0.95 inches;
          FirstIndent: -0.95 inches;
          Span {
            TextBackground: 95%;
            name;
            Tab;
          };
          Span {
            TextHeight: 10 pts;
            Separator: Space;
            foreach (var segment in segments) {
              var good = set.Add(segment);
              segment.ShowSegment;
            }
          }
        }
      };
      return new NodeClass(label);
    }
    else
      return null;
  }

  AddVowels(DataSetClass data, DictionaryClass set, backness) {
    return AddSegments(data, set, backness.Name, s => s.Features.HasFlag(Vowel) and s.Backness == backness);
  }

  AddFlag(DataSetClass data, DictionaryClass set, all, features, other) {
    return AddSegments(data, set, other.Name, s => (not set.Contains(s)) and s.Features.HasFlagMask(all, features) and s.Features.HasFlagMask(other, other));
  }

  AddConsonants(DataSetClass data, DictionaryClass set, name, all, features) = AddNode(name) {
    AddFlag(data, set, all, features, each [Tenuis, Click, Nasal, Ejective, Fricative, Sibilant, Lateral, Stop, Approximant, TapFlap, Trill, NoFeature]);
  };

  AddVoicedPairs(DataSetClass data, DictionaryClass set, name, all, features) = AddNode(name) {
    AddConsonants(data, set, Lang.Voiced, all Voiced, features Voiced);
    AddConsonants(data, set, Lang.Voiceless, all Voiced, features);
  };

  GetNodes(DataSetClass data) = new NodeClass() {
    var set1 = new DictionaryClass(256);
    var set2 = new DictionaryClass(256);
    var all  = Vowel Pulmonic Affricate;

    AddNode(Lang.Vowels) {
      AddVowels(data, set1, each Backnesses)
    };
    AddNode(Lang.Affricates) {
      AddVoicedPairs(data, set1, Lang.NonPulmonic, all, Affricate);
      AddVoicedPairs(data, set1, Lang.Pulmonic, all, Pulmonic Affricate);
    };
    AddNode(Lang.Consonants) {
      AddVoicedPairs(data, set1, Lang.Pulmonic, all, Pulmonic);
      AddVoicedPairs(data, set1, Lang.NonPulmonic, all, NoFeature);
    };
    AddSegments(data, set2, "Other", segment => true, 4 inches)
  };

  ShowTree(DataSetClass data) = Paragraph {
    Tree {
      Width: 7 inches;
      LabelGap: 4 pts;
      Root: GetNodes(data);
    }
  };
}
//======================================================================

namespace SegmentDisplay {
  CompareSegments(SegmentClass s0, SegmentClass s1, options) = s0.UsedCount - s1.UsedCount;

  FrequencyChart(DataSetClass data, SizeClass size, extra = true) = Chart {
    TextHeight: 11 pts;
    Size: size;

    SegmentClass[] sorted = data.UniqueSegments.Sort(true, ref CompareSegments);
    Style.SansSerif;
    Type: ChartTypes.Column;
    Legend: ChartLegend {Placement: Placements.Bottom};
    ValueLabel: "Frequency %" {
      Transform: Rotate(90 degrees);
      TransformFit: true;
    };
    XAxis: ChartAxis {
      TextHeight: 0.6 * size.Width / sorted.Length;
      (each sorted).ShowSegment;
    };
    ValueAxis: ChartAxis;
    if (extra) {
      ChartSeries {
        Label: "All Languages";
        (each sorted).NormalFrequency;
      };
    }
    ChartSeries {
      Label: "Experiment";
      (each sorted).UsedFrequency;
    };
  };

  ShowSegmentAssignments(DataSetClass data) = Paragraph {
    foreach (var segment in data.UniqueSegments) {
      HBox {
        VAlign: VAligns.Center;
        Margin: 2;
        PaddingLR: 1;
        Border: 0.25 pts {Color: 80%};
        Span {
          Style.MonoFamily;
          HAlign: HAligns.Center;
          each1;
        };
        Space*5;
        Span {
          TextHeight: 18 pts;
          segment.ShowSegment;
        };
      }
    }
  };

  SegmentCell(SegmentClass segment) = Cell {
    Edge: 0.25 pts {Color: Colors.LightGray};
    Padding: 2 pts;
    segment.Display(segment.GlobalVariablePath, 16 pts)
  };

  SegmentTable(DataSetClass data) = Block {
    var c = DocMetrics.SegmentColumns;

    Style.TitleBar {Lang.IPAListing};
    Table {
      Columns: [DocMetrics.PageContent.Width / c] * c;
      foreach (var s in (data.SortedSegments / c)) {
        Row {
          SegmentCell(each s);
        }
      }
    };
    Style.TableNotes;
  };

  ShowLanguageDetails(DataSetClass data) = Block {
    foreach (var taxon in data.Taxa) {
      var language = taxon.Language;
      Style.Header2 {
        language.Name;
      };
      Block {
        Paragraph {
          ParAlignment: ParAlignments.Center;
          if (valid language.MapImage)
            language.ShowMap(Size(5 inches, 3 inches));
        };
        language.Description;
        language.Details;
      }
    }
  };

  ShowFilterSegments(RuleClass rule, SegmentClass[] segments, FilterClass filter, align) = Frame {
    Width: 2 inches;
    Paragraph {
      ParAlignment: align;

      TextHeight: 18 pts;
      var matching = rule.GetMatching(segments, filter);
      if (valid matching) {
        Separator: Space;
        (each matching).ShowSegment;
      }
    }
  };

  ShowLanguages(DataSetClass data, SizeClass content) = Block {
    var rows      = 2;
    var cols      = (data.Taxa.Length + 1) div rows;
    var taxagroup = data.Taxa / cols;
    var h         = 14 pts;
    var space     = 5 pts;
    var size      = Size(content.Width / cols - space, content.Height / rows - space*2);

    foreach (var group in taxagroup) {
      HBox {
        PaddingT: space;
        VAlign: VAligns.Top;

        foreach (var taxon in group) {
          VBox {
            MarginR: space;
            Size: size;
            HAlign: HAligns.Center;

            Paragraph {
              TextHeight: h;
              Bold;
              taxon.Language;
            };

            HBox {
              VAlign: VAligns.Center;

              var s = Size(size.Width, size.Height - h);
              Size: s;
              Corner: 20 pts;
              BorderStroke: 1 pts {Color: 90%};
              BorderClip: true;

              Span {
                Hover: new HoverClass(taxon.Language, HoverTypes.Tip);
                taxon.Language.ShowMap(s);
              }
            };
          }
        }
      }
    }
  };

  ShowConceptGroups(DataSetClass data) = Block {
    var groups = WordGroups[1..];
    Table {
      Style.TableEdge;
      Columns: [0.25 inches] + [1 inch] * (2+groups.Length);
      Row {
        Style.HeaderCell;
        Style.HeaderCell {
          HAligns: HAligns.Center;
          Lang.Concept;
        };
        Style.HeaderCell {
          HAligns: HAligns.Center;
          "Type";
        };
        foreach (var g in groups) {
          Style.HeaderCell {
            HAligns: HAligns.Center;
            g.Name;
          };
        }
      };
      foreach (var concept in data.UsedConcepts) {
        Row {
          Style.RowBar(each0);
          each0;
          concept.Name;
          concept.WordType.Name;
          foreach (var g in groups) {
            Cell {
              HAlign: HAligns.Center;
              if (concept.WordGroup.HasFlag(g))
                Tex.bullet;
            }
          }
        }
      }
    }
  };

  ShowWordsForEachSegment(DataSetClass data) = Block {
    foreach (var segment in data.SortedSegments) {
      Paragraph {
        TabStops: [0.5 inches, DocMetrics.PageContent.Width {Type: TabTypes.Right}];
        KeepWithNext: true;
        TextHeight: 16 pts;
        ParBackground: 90%;

        segment.ShowSegment;
        Tab;
        segment.ShowCodePoint
        Tab;
        Span {
          Hover: new HoverClass(segment, HoverTypes.Tip);
          segment.Ipa;
        };
      };

      Paragraph {
        ParAlignment: ParAlignments.Justify;
        Style.IPAFamily;
        SpaceAfter: 10 pts;
        Span {
          Separator: Space*2;
          foreach (var cognate in data.SortedCognates) {
            foreach (var word in cognate.Words) {
              if (word.Segments.FindAny(segment)) {
                Span {
                  Hover: new HoverClass(word, HoverTypes.Tip);
                  word.Plain;
                }
              }
            }
          }
        };
      };
    }
  };
}

//======================================================================

