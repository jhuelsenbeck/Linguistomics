using Format, Units, IPA, FeatureSet;
//======================================================================
// Consonants
//======================================================================

class TabOptionsClass {
   var Title,
       ColWidth,
       Exclude,
       Include,
       All,
       Manners,
       RowMask,
       Notes,
       RowLabels;

   Constructor(title) {
     Title = title;
   }
}

with MatchingConsonants {
  PulmonicTable = new TabOptionsClass(Lang.PConsonants) {
    ColWidth: 45 pts;
    Exclude: Affricate Ejective;
    Include: Pulmonic;
    All: NoFeature;
    Manners: [Nasal, Stop, Sibilant Fricative, Fricative, Approximant, TapFlap, Trill, Lateral Fricative, Lateral Approximant, Lateral TapFlap];
    RowMask: Nasal Stop Sibilant Fricative Approximant TapFlap Trill Lateral Velarized;
    Notes: Lang.SymbolPairVoiced
  };

  NonPulmonicTable = new TabOptionsClass(Lang.NPConsonants) {
    ColWidth: 80 pts;
    Exclude: Vowel Pulmonic Central;
    Include: Ejective Click Implosive;
    All: NoFeature;
    Manners: [Ejective Stop, Ejective Fricative, Ejective Lateral Fricative, Click Tenuis, Click Nasal, Click Tenuis Lateral, Implosive];
    RowMask: Lateral;
    Notes: Lang.SymbolPairVoiced
  };

  PulmonicAffricatesTable = new TabOptionsClass(Lang.PulmonicAffricates) {
    ColWidth: 50 pts;
    Exclude: Vowel;
    Include: Affricate Sibilant Lateral;
    All: Pulmonic Affricate;
    RowLabels: [Lang.Sibilant, Lang.NonSibilant, Lang.Lateral];
    Manners: [Sibilant, NoFeature, Lateral];
    RowMask: Pulmonic Affricate Sibilant Fricative Lateral;
  };

  EjectiveAffricatesTable = new TabOptionsClass(Lang.EjectiveAffricates) {
    ColWidth: 50 pts;
    Exclude: Vowel Click Implosive Pulmonic;
    Include: Ejective Affricate Central Lateral;
    All: Ejective Affricate;
    Manners: [Central, Lateral];
    RowMask: Pulmonic Approximant Central Lateral;
  };

  ShowTables {
    var set = new HashSetClass(256, SegmentClass);
    return Block {
      MatchingOptions.ShowTable(set, each [PulmonicTable, NonPulmonicTable]);
      PageBreak;
      MatchingVowels.ShowTable(set);
      MatchingOptions.ShowTable(set, each [PulmonicAffricatesTable, EjectiveAffricatesTable]);
      MatchingOther.ShowTable(set);
    }
  }
}
//======================================================================

with DisplayWords {
  WordRow(word, index) = Row {
    Style.RowBar(index);
    Cell {
      word.ShowConcept;
    };
    Cell {
      word.Plain;
    };
    Cell {
      Span {
        Separator: "-";
        SegmentSound(each word.Segments)
      }
    }
  };

  HeaderCell(d) = Cell {
    Style.SansSerif;
    Style.TitleBackground;
    EdgeB: 1 pts;
    Padding: 2 pts;
    d
  };

  ShowLanguage(taxon) = Block {
    Style.TitleBar(taxon.Language);
    Table {
      Edge: 0.5;
      Columns: [2.1 inches, 1.5 inches, DocMetrics.PageContent.Width - 3.6 inches];
      Row {
        HeaderCell(Lang.Cognate);
        HeaderCell(Lang.IPA);
        HeaderCell(Lang.Sounds);
      };

      var i = 0;
      foreach (var cognate in Results.UsedCognates) {
        foreach (var word in cognate.Words[taxon.Index]) {
          if (word.Segments.Length > 0)
            WordRow(word, i++);
        }
      }
    };
    Paragraph;
  };

  ShowTable {
    return ShowLanguage(each Results.Taxa);
  }
}
//======================================================================

with AllWords {
  AddCell(TaxonClass taxon, CognateClass cognate, textheight) = Cell {
    Background: EachIndex mod 2 == 0 ? 97% : null;
    cognate.Words[taxon.Index].ShowPaddedBlocks(textheight);
  };

  AddRow(TaxonClass taxon, cognates, textheight) = Row {
    Cell {
      PaddingL: 1 pt;
      Style.SansSerif;
      TextColor: Colors.DarkGray;
      taxon.Variable;
    };
    AddCell(taxon, each cognates, textheight)
  };

  ConceptTable(ResultsClass results, textheight, wordsperline, cognates) = HBox {
    var first = 84 pts;
    var w     = (DocMetrics.PageContent.Width - first) / wordsperline;
    Table {
      Style.IPAFamily;
      Edge: 0.5;
      Columns: [first] + [w] * wordsperline;

      Row {
        Style.TitleBackground;
        Style.SansSerif;
        Empty;
        (each cognates).Title;
      };

      AddRow(each results.Taxa, cognates, textheight);
    };
    Paragraph;
  };

  ShowConceptTable(ResultsClass results, CognateClass cognate) = ConceptTable(results, 10 pts, 7, [cognate]);

  ShowTable(ResultsClass results, max=1000000) = Block {
    var textheight = 10 pts;
    TextHeight: textheight;
    var wordsperline = Math.Round(DocMetrics.PageContent.Width / (13 * (textheight intu pixels)));

    foreach (var cognates in (results.UsedCognates / wordsperline)) {
      if (EachIndex >= max)
        break;
      ConceptTable(results, textheight, wordsperline, cognates);
    }
  };
}
//======================================================================
// Consonants
//======================================================================

with MatchingOptions {
  MatchInclude(SegmentClass segment, place, options) {
    return SamePlace(segment, place) and
           segment.Features.NotFlag(options.Exclude) and
           segment.Features.HasFlag(options.Include) and
           Math.FindAny(options.Manners, manner => AnyManners(manner, segment.Features, options));
  }

  CheckFlags(sflags, rflags, options) {
    return sflags.NotFlag(options.Exclude) and
           sflags.HasFlag(options.Include) and
           sflags.HasFlagMask(options.RowMask | rflags, rflags);
  }

  AnyManners(manner, features, options) = CheckFlags(features, manner | options.All, options);

  SamePlace(SegmentClass segment, place) = segment.?Place and place and segment.Place == place;

  MatchPlace(place, options) = Math.FindAny(AllSegments, segment => MatchInclude(segment, place, options));
  GetPlaces(options) = Math.FindSlice(Places, place => MatchPlace(place, options));


  SegmentText(HashSetClass set, SegmentClass segment) {
    if (not segment.Impossible) {
      set.Add(segment);
      return segment.ShowSegment;
    }
    return null;
  }

  SegmentBox(HashSetClass set, SegmentClass segment, color) = Canvas {
    HAlign: HAligns.Center;
    Size: DocMetrics.BoxSize;
    if (exists segment.?Ipa) {
      TextHeight: DocMetrics.BoxSize.Height - 6 pts;
      TextColor: color;
      SegmentText(set, segment)
    }
    else
      Style.ImpossibleBackground;
  };

  ShowBox(HashSetClass set, SegmentClass segment, color) = SegmentBox(set, segment, color) {
    if (segment.Features.HasFlag(Voiced))
      X: DocMetrics.BoxSize.Width;
  };

  MatchError(matches) = matches.Length > 2 or (matches.Length == 2 and matches[0].Features.HasFlag(Voiced) == matches[1].Features.HasFlag(Voiced));

  SegmentBlock(HashSetClass set, matches) = Cell {
    Style.SegmentBottom;
    if (matches.Length > 0) {
      if (matches.Length == 1 and matches[0].Impossible)
        Style.ImpossibleBackground;
      else {
        TextHeight: 1 pts;
        Span {
          Canvas {
            Size: DocMetrics.CellSize;
            ShowBox(set, each matches, MatchError(matches) ? Colors.Red : Colors.Black)
          }
        }
      }
    }
  };

  AddCell(HashSetClass set, options, place, features) {
    return SegmentBlock(set, Math.FindSlice(AllSegments, s => SamePlace(s, place) and CheckFlags(s.Features, features, options)));
  }

  AddRow(HashSetClass set, TabOptionsClass options, places, f) {
    var allflags = f | options.All;
    return Row {
      Cell {
        VAlign: VAligns.Center;
        EdgeR: 0.5 pts;
        Style.TitleBackground;
        PaddingLR: 2 pts;
        TextHeight: 7 pts;

        if (exists options.RowLabels)
          options.RowLabels[EachIndex];
        else
          f;
      };
      AddCell(set, options, each places, allflags)
    }
  }

  PlaceHeader(place) = Style.HeaderCell(place.Name, HAligns.Center);

  ShowTable(HashSetClass set, TabOptionsClass options) {
    var places = GetPlaces(options);

    return Block {
      Style.TitleBar(options.Title);
      Table {
        Style.TableEdge;
        Columns: [options.ColWidth {EdgeR: 0.5 pts}] +
                 [DocMetrics.CellSize.Width {HAlign: HAligns.Center; EdgeR: 0.25 pts}] * places.Length;

        Row {
          TextHeight: 6 pts;
          Style.HeaderCell(Bold Lang.Manner);
          PlaceHeader(each places)
        };
        AddRow(set, options, places, each options.Manners);
      };
      Style.TableNotes {
        Lang.ImpossibleShaded;
        Space;
        options.?Notes
      };
    };
  }
}
//======================================================================
// Vowels
//======================================================================

with MatchingVowels {
  AddBlock(HashSetClass set, matches) = Cell {
    Style.SegmentBottom;
    HAlign: HAligns.Center;
    TextHeight: DocMetrics.BoxSize.Height;
    if (matches.Length == 2) {
      Span {
        MatchingOptions.SegmentText(set, matches[0]);
        " • " {TextColor: Colors.LightGray};
        MatchingOptions.SegmentText(set, matches[1]);
      }
    }
    else if (matches.Length == 1)
      MatchingOptions.SegmentText(set, matches[0]);
  };

  FindAnyOpen(feature, open) = Math.FindAny(Results.DisplaySegments, segment => segment.MatchVowelAny(feature, open));

  AddCell(HashSetClass set, feature, open, backness) {
    var matches = Math.FindSlice(Results.DisplaySegments, segment => segment.MatchVowelPair(feature, open, backness));
    return AddBlock(set, matches);
  }

  AddRow(HashSetClass set, feature, open) {
    if (FindAnyOpen(feature, open)) {
      return Row {
        Cell {
          VAlign: VAligns.Center;
          Style.TitleBackground;
          open.Name
        };
        AddCell(set, feature, open, each Backnesses)
      };
    }
    else
      return null;
  }

  ShowVowelTable(HashSetClass set, feature, title) = Block {
    Style.TitleBar(title);
    Table {
      HAlign: HAligns.Center;
      Style.TableEdge;
      Columns: [(1 inch){EdgeR: 0.5 pts}] + [DocMetrics.BoxSize.Width*3 {EdgeR: 0.25 pts}] * Backnesses.Length;
      Row {
        TextHeight: 10 pts;
        Style.HeaderCell(Empty);
        Style.HeaderCell(each Backnesses, HAligns.Center)
      };
      AddRow(set, feature, each Opens)
    }
  };

  ShowTable(HashSetClass set) = Block {
    ShowVowelTable(set, NoFeature, Lang.Vowels);
    Style.TableNotes {
      Lang.SymbolPairRounded;
    };
    ShowVowelTable(set, LongVowel, Lang.LongVowels);
    Paragraph;
  };
}
//======================================================================
// Diacritic markers
//======================================================================

with MatchingDiacritics {
  ColumnDiv = 3;

  AddCell(segment) = Cell {
    Paragraph {
      LeftIndent: 0.5 inches;
      FirstIndent: -0.5 inches;
      LocationMark: segment.GlobalVariablePath;
      segment.ShowSegment {
        TextHeight: 18 pts;
        Tab;
      };
      segment.Description
    }
  };

  AddRow(segments) = Row {
    AddCell(each segments)
  };

  ShowTable = Block {
    Style.TitleBar(Lang.Diacritics);
    Table {
      Style.TableEdge;
      Columns: [DocMetrics.PageContent.Width / ColumnDiv] * ColumnDiv;
      AddRow(each DiacriticModifiers / ColumnDiv);
    };
    Style.TableNotes
  };
}
//======================================================================
// Segments not in other lists
//======================================================================

with MatchingOther {
  ColumnDiv = 2;

  AddCell(SegmentClass segment) = {
    Cell {
      VAlign: VAligns.Center;
      HAlign: HAligns.Center;
      TextHeight: 20 pts;
      LocationMark: segment.GlobalVariablePath;
      segment.ShowSegment;
    };
    Cell {
      VAlign: VAligns.Center;
      segment.SegmentName;
    }
  };

  AddRow(segments) = Row {
    AddCell(each segments)
  };

  ShowTable(set) = Block {
    Style.TitleBar(Lang.OtherSegments);
    Table {
      Style.TableEdge;
      Columns: [DocMetrics.CellSize.Width, DocMetrics.PageContent.Width * 0.5 - DocMetrics.CellSize.Width] * ColumnDiv;
      AddRow(each (Math.FindSlice(Results.DisplaySegments, segment => not Math.FindAny(set, segment)) / ColumnDiv));
    };
    Style.TableNotes
  };
}
//======================================================================
// Segment Tree
//======================================================================

with SegmentTree {
  AddNode(name) = new NodeClass(name) {
    Bevel: 20%;
    Curvature: 20%;
  };

  AddSegments(set, name, predicate, width=3 inches) {
    var segments = Math.FindSlice(Results.DisplaySegments, predicate);
    if (segments.Length > 0) {
      var label = Frame {
        Width: width;
        Paragraph {
          LeftIndent: 0.95 inches;
          FirstIndent: -0.95 inches;
          Span {
            TextBackground: 95%;
            name;
            Tab;
          };
          Span {
            TextHeight: 10 pts;
            Separator: Space;
            foreach (var segment in segments) {
              var good = set.Add(segment);
              segment.ShowSegment;
            }
          }
        }
      };
      return new NodeClass(label);
    }
    else
      return null;
  }

  AddVowels(set, backness)           = AddSegments(set, backness.Name, s => s.Features.HasFlag(Vowel) and s.Backness == backness);
  AddFlag(set, all, features, other) = AddSegments(set, other.Name, s => not Math.FindAny(set, s) and s.Features.HasFlagMask(all, features) and s.Features.HasFlagMask(other, other));

  AddConsonants(set, name, all, features) = AddNode(name) {
    AddFlag(set, all, features, each [Tenuis, Click, Nasal, Ejective, Fricative, Sibilant, Lateral, Stop, Approximant, TapFlap, Trill, NoFeature]);
  };

  AddVoicedPairs(set, name, all, features) = AddNode(name) {
    AddConsonants(set, Lang.Voiced, all Voiced, features Voiced);
    AddConsonants(set, Lang.Voiceless, all Voiced, features);
  };

  GetNodes = new NodeClass() {
    var set1 = new DictionaryClass(256);
    var set2 = new DictionaryClass(256);
    var all  = Vowel Pulmonic Affricate;

    AddNode(Lang.Vowels) {
      AddVowels(set1, each Backnesses)
    };
    AddNode(Lang.Affricates) {
      AddVoicedPairs(set1, Lang.NonPulmonic, all, Affricate);
      AddVoicedPairs(set1, Lang.Pulmonic, all, Pulmonic Affricate);
    };
    AddNode(Lang.Consonants) {
      AddVoicedPairs(set1, Lang.Pulmonic, all, Pulmonic);
      AddVoicedPairs(set1, Lang.NonPulmonic, all, NoFeature);
    };
    AddSegments(set2, "Other", segment => true, 4 inches)
  };

  ShowTree = Paragraph {
    Tree {
      Width: 7 inches;
      LabelGap: 2 pts;
      Root: GetNodes;
    }
  };
}
//======================================================================

