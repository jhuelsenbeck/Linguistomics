using Format, Units, IPA, SegmentFeatures, Math;
//======================================================================

class EulerDiagramClass {
  Constructor {
  }

  TitleStyle = {TextColor: 70%};
  ChartSize  = 6 inches;
  EX(x)      = ChartSize * x * 0.01;
  EY(y)      = ChartSize * y * 0.01;

  Enclosure(x, y, w, h, ColorClass color) = Canvas(EX(w), EY(h), 1 pt) {
    BorderRadius: 6 pts;
    Background: color;
    X: EX(x);
    Y: EY(y);
  };

  NameBox(name, angle=0) = HBox {
    Transform: TransformClass.Rotate(angle);
    TransformFit: true;
    Paragraph {
      TitleStyle;
      Space;
      name;
      Space;
    };
  };

  VNameFrame(name, x, y, width, height, ColorClass color) = Enclosure(x, y, width, height, color) {
    VAlign: VAligns.Center;
    NameBox(name, 90 degrees)
  };

  FeatureMask = Vowel Nasal Vocoid Approximant Vibrant Lateral Affricate Occlusive Strident Sibilant Obstruent Continuant Fricative Rhotic Liquid Trill TapFlap;

  FeatureSegments(SegmentClass[] segments, features) = segments.FindSlice(s => s.Features.HasFlagMask(FeatureMask, features));

  FeatureFrame(SegmentClass[] segments, x, y, width, name, features) = Canvas {
    X: EX(x);
    Y: EY(y);
    Frame(EX(width)) {
      ParAlignment: Center;
      if (name is valid)
        Span {TitleStyle; name};
      Paragraph {
        Separator: Space;
        (each FeatureSegments(segments, features)).ShowSegment;
      }
    }
  };

  FeatureChart(SegmentClass[] segments) = Canvas {
    TextHeight: 16 pts;

    VNameFrame(Lang.Occlusive, 10, 0, 90, 34, new(255, 238, 238)) {
      HAlign: HAligns.Right;
    };
    VNameFrame(Lang.Continuant, 10, 35, 90, 37, new(229, 255, 255)) {
      HAlign: HAligns.Right;
    };
    VNameFrame(Lang.Obstruent, 0, 11, 94, 40, new(238, 238, 255, 50%));
    VNameFrame(Lang.Vocoid, 0, 52, 78, 21, new(238, 255, 238, 50%));
    VNameFrame(Lang.Vibrant, 20, 74, 65, 17, new(238, 238, 255));

    Enclosure(11, 1, 83, 9, new(255, 246, 246));   // Nasals
    Enclosure(31, 12, 62, 21, new(246, 242, 250));  // Affricates
    Enclosure(11, 12, 19, 21, new(246, 243, 250));  // Plosives
    Enclosure(11, 36, 80, 14, new(240, 247, 255));  // Fricatives

    Enclosure(25, 75, 59, 7, new(247, 247, 255)) {
      HAlign: HAligns.Left;
      VAlign: VAligns.Center;
      NameBox(Lang.TapFlap);
    };

    Enclosure(25, 83, 53, 7, new(247, 247, 255)) {
      HAlign: HAligns.Left;
      VAlign: VAligns.Center;
      NameBox(Lang.Trill);
    };

    Enclosure(53, 13, 39, 36, new(233, 248, 235, 50%)) {
      HAlign: HAligns.Center;
      NameBox(Lang.Strident);
    };

    Enclosure(62, 18, 25, 24, new(245, 252, 220, 50%)); // Sibilants
    Enclosure(11, 53, 21, 18, new(240, 255, 247));      // Vowels
    Enclosure(33, 53, 61, 18, new(240, 255, 247, 50%)) {
      HAlign: HAligns.Left;
      NameBox(Lang.Approximant);
    };

    Enclosure(35, 59, 21, 11, new(248, 255, 225)); // Semivowels

    Enclosure(64, 43, 26, 59, new(255, 238, 238, 50%)) {
      HAlign: HAligns.Center;
      VAlign: VAligns.Bottom;
      NameBox(Lang.Liquid);
    };

    Enclosure(65, 44, 14, 52, new(255, 247, 221, 50%)) {
      HAlign: HAligns.Center;
      VAlign:VAligns. Bottom;
      NameBox(Lang.Rhotic);
    };

    Enclosure(80, 44, 9, 44, new(238, 247, 230, 70%)) {
      HAlign: HAligns.Right;
      VAlign: VAligns.Bottom;
      NameBox(Lang.Lateral, 90 degrees);
    };

    FeatureFrame(segments, 11, 1, 84, Lang.Nasal, Nasal Occlusive);
    FeatureFrame(segments, 12, 14, 17, Lang.Plosive, Stop Occlusive);
    FeatureFrame(segments, 32, 14, 20, Lang.Affricate, Affricate Occlusive);
    FeatureFrame(segments, 54, 20, 7, null, Affricate Occlusive Strident);
    FeatureFrame(segments, 65, 18, 18, Lang.Sibilant, Affricate Occlusive Strident Sibilant);
    FeatureFrame(segments, 14, 38, 22, Lang.Fricative, Fricative Obstruent Continuant);
    FeatureFrame(segments, 54, 38, 6, null, Fricative Obstruent Continuant Strident);
    FeatureFrame(segments, 64, 36, 20, null, Fricative Obstruent Continuant Strident Sibilant);
    FeatureFrame(segments, 66, 44, 10, null, Fricative Obstruent Continuant Strident Rhotic Liquid);
    FeatureFrame(segments, 80, 44, 10, null, Fricative Obstruent Continuant Strident Lateral Liquid);
    FeatureFrame(segments, 12, 53, 19, Lang.Vowel, Vowel Vocoid Continuant);
    FeatureFrame(segments, 36, 60, 19, Lang.SemiVowel, Vocoid Semivowel Approximant Continuant);
    FeatureFrame(segments, 57, 62, 5, null, Vocoid Approximant);
    FeatureFrame(segments, 66, 60, 10, null, Vocoid Approximant Rhotic Liquid);
    FeatureFrame(segments, 82, 58, 5, null, Vocoid Approximant Rhotic Liquid Lateral);
    FeatureFrame(segments, 54, 76, 10, null, Vibrant TapFlap);
    FeatureFrame(segments, 66, 76, 10, null, Vibrant TapFlap Rhotic Liquid);
    FeatureFrame(segments, 77, 77, 10, null, Vibrant TapFlap Rhotic Liquid Lateral);
    FeatureFrame(segments, 54, 84, 10, null, Vibrant Trill);
    FeatureFrame(segments, 66, 84, 10, null, Vibrant Trill Rhotic Liquid);
  };
}
//======================================================================

readonly namespace DisplayWords {
  HeaderCell(d) = Cell(new(new(0, 2 pts), new(0, 2 pts), new(0, 2 pts), new(1, 2 pts))) {
    PaperStyle.TitleBackground;
    d
  };

  ShowLanguage(ContentStyleClass style, DataSetClass data, TaxonClass taxon) = Block {
    PaperStyle.TitleBar {taxon.Language};
    Table(0.5, null, [new(ColumnClass.Fit(2.1 inches), null, PadLR(10)), new(ColumnClass.Fit(1.5 inches), null, PadR(10)), ColumnClass.Expand]) {
      style.SansSerif;
      Row {
        HeaderCell(Lang.Cognate);
        HeaderCell(Lang.IPA);
        HeaderCell(Lang.Segments);
      };

      var i = 0;
      foreach (var cognate in data.GetSortedCognates) {
        foreach (var word in cognate.Words[taxon.Index]) {
          if (word.Segments is valid) {
            PaperStyle.RowBar(i++) {
              word.Cognate.GetTitle;
              word.ShowPlain;
              Span {
                (each word.Segments).ShowBlock;
              }
            };
          }
        }
      }
    };
    Paragraph;
  };

  ShowWordsByLanguage(ContentStyleClass style, DataSetClass data) = Block {
    ShowLanguage(style, data, each data.Taxa);
  };
}
//======================================================================

readonly namespace AllWords {
  AddCell(TaxonClass taxon, CognateClass cognate, textheight) = Cell {
    Background: each0 mod 2 == 0 ? 97% : null;
    cognate.Words[taxon.Index].ShowPaddedBlocks(textheight);
  };

  AddRow(ContentStyleClass style, TaxonClass taxon, CognateClass[] cognates, textheight) = Row {
    Cell(PadL(1 pt)) {
      style.SansSerif;
      TextColor: Colors.DarkGray;
      taxon.Language;
    };
    AddCell(taxon, each cognates, textheight)
  };

  ConceptTable(ContentStyleClass style, DataSetClass data, textheight, wordsperline, CognateClass[] cognates) = HBox {
    var first = 84 pts;
    var w     = (ExtentWidth - first) / wordsperline;
    Table(0.5, null, [first] + [w] * wordsperline) {
      PaperStyle.IPAFamily;
      Row {
        PaperStyle.TitleBackground;
        style.SansSerif;
        Empty;
        (each cognates).GetTitle;
      };

      AddRow(style, each data.Taxa, cognates, textheight);
    };
    Paragraph;
  };

  ShowConceptTable(ContentStyleClass style, DataSetClass data, CognateClass cognate) = ConceptTable(style, data, 10 pts, 7, [cognate]);

  ShowTable(ContentStyleClass style, DataSetClass data, textheight, int max=1000000) = Block {
    TextHeight: textheight;
    var wordsperline = (ExtentWidth / (14 * (textheight intu pixels))) as int;

    foreach (var cognates in (data.GetSortedCognates / wordsperline)) {
      if (each0 >= max)
        break;
      ConceptTable(style, data, textheight, wordsperline, cognates);
    }
  };
}

readonly namespace MatchCell {
  SegmentText(SegmentSetClass set, SegPartClass segment) {
    if (not segment.Segment.Impossible) {
      set.Add(segment);
      return segment.ShowSegment;
    }
    return null;
  }

  SegmentBox(SegmentSetClass set, SegPartClass segment, color) = Canvas(PaperStyle.BoxSize.Width, PaperStyle.BoxSize.Height) {
    HAlign: Center;
    if (segment.?Ipa is valid) {
      TextHeight: PaperStyle.BoxSize.Height - 6 pts;
      TextColor: color;
      SegmentText(set, segment)
    }
    else
      PaperStyle.ImpossibleBackground;
  };

  ShowBox(SegmentSetClass set, SegPartClass segment, color) = SegmentBox(set, segment, color) {
    if (segment.Features.HasFlag(Voiced))
      X: PaperStyle.BoxSize.Width;
  };

  ErrorMatches(SegmentSetClass set, SegPartClass[] matches) = Span {
    Separator: CommaSpace;
    TextColor: Colors.Red;
    MatchCell.SegmentText(set, each matches);
  };
}
//======================================================================

class TabOptionsClass {
   var Title,
       Exclude,
       Include,
       All,
       Manners,
       RowMask,
       Notes,
       RowLabels;

  Constructor(title) {
    Title = title;
  }

  CheckFlags(sflags, rflags) {
    return sflags.NotFlag(Exclude) and
           sflags.HasFlag(Include) and
           sflags.HasFlagMask(RowMask | rflags, rflags);
  }

  MatchError(matches) = matches.Length > 2 or (matches.Length == 2 and matches[0].Features.HasFlag(Voiced) == matches[1].Features.HasFlag(Voiced));

  SegmentBlock(SegmentSetClass set, SegPartClass[] matches) = Cell {
    if (matches is valid) {
      if (matches.Length == 1 and matches[0].Segment.Impossible)
        PaperStyle.ImpossibleBackground;
      else {
        Span {
          if (MatchError(matches))
            MatchCell.ErrorMatches(set, matches);
          else {
            Canvas(PaperStyle.CellSize.Width, PaperStyle.CellSize.Height) {
              MatchCell.ShowBox(set, each matches, Colors.Black)
            }
          }
        }
      }
    }
  };

  AddRow(DataSetClass data, SegmentSetClass set, Places[] places, manner) = Row(PaperStyle.SegmentBottom) {
    Cell {
      VAlign: Center;
      PaperStyle.TitleBackground;
      TextHeight: 7 pts;

      if (RowLabels is valid)
        RowLabels[each0];
      else
        manner;
    };

    var features = manner | All;
    var all      = data.UniqueSegments + new SegPartClass(each ImpossibleSegments);
    foreach (var place in places)
      SegmentBlock(set, all.FindSlice(s => s.Segment.?Place == place and CheckFlags(s.Features, features)));
  };

  bool MatchInclude(SegPartClass segment, Places place) {
    return segment.Segment.?Place == place and
           segment.Features.NotFlag(Exclude) and
           segment.Features.HasFlag(Include) and
           Manners.FindFirstIndex(manner => CheckFlags(segment.Features, manner | All)) >= 0;
  }

  MatchPlace(DataSetClass data, place) {
    return data.UniqueSegments.FindFirstIndex(segment => MatchInclude(segment, place));
  }

  ShowTable(ContentStyleClass style, DataSetClass data, SegmentSetClass set) = Block {
    PaperStyle.TitleBar {
      Title
    };

    var places = Places.ValueArray.FindSlice(place => MatchPlace(data, place));
    if (places.Length == 0)
      Lang.None;
    else {
      var first  = 75 pts;
      var cw     = Math.Min((ExtentWidth - first) / places.Length, 75 pts);

      Table(PaperStyle.TableBorder, null, [new ColumnClass(first, BorderR(0.5 pts))] + [new ColumnClass(cw, null, null, HAligns.Center)]) {
        Row {
          TextHeight: 6 pts;
          PaperStyle.HeaderCell(style) {
            Bold;
            Lang.Manner;
          };

          foreach (var place in places) {
            PaperStyle.HeaderCell(style) {
              place;
            };
          }
        };
        AddRow(data, set, places, each Manners);
      };

      PaperStyle.TableNotes {
        Lang.ImpossibleShaded;
        Space;
        Notes;
      };
    }
  };
}
//======================================================================

readonly namespace MatchingConsonants {
  PulmonicTable = new TabOptionsClass(Lang.PConsonants) {
    Exclude: Affricate Ejective;
    Include: Pulmonic;
    All: NoFeature;
    Manners: [Nasal Stop, Nasal, Stop, Sibilant Fricative, Fricative, Approximant, TapFlap, Trill, Lateral Fricative, Lateral Approximant, Lateral TapFlap];
    RowMask: Nasal Stop Sibilant Fricative Approximant TapFlap Trill Lateral Velarized;
    Notes: Lang.SymbolPairVoiced
  };

  NonPulmonicTable = new TabOptionsClass(Lang.NPConsonants) {
    Exclude: Vowel Pulmonic Central;
    Include: Ejective Click Implosive Palatalized Implosive Lateral Approximant;
    All: NoFeature;
    Manners: [Stop, Ejective Stop, Ejective Fricative, Ejective Lateral Fricative, Click Tenuis, Click Nasal, Click Tenuis Lateral, Implosive, Lateral Approximant];
    RowMask: Lateral;
    Notes: Lang.SymbolPairVoiced
  };

  PulmonicAffricatesTable = new TabOptionsClass(Lang.PulmonicAffricates) {
    Exclude: Vowel;
    Include: Affricate Sibilant Lateral;
    All: Pulmonic Affricate;
    RowLabels: [Lang.Sibilant, Lang.Lateral, "Voiced", Lang.NonSibilant];
    Manners: [Sibilant, Lateral, Voiced, NoFeature];
    RowMask: Pulmonic Affricate Sibilant Fricative Lateral;
  };

  EjectiveAffricatesTable = new TabOptionsClass(Lang.EjectiveAffricates) {
    Exclude: Vowel Click Implosive Pulmonic;
    Include: Ejective Affricate Central Lateral;
    All: Ejective Affricate;
    Manners: [Central, Lateral];
    RowMask: Pulmonic Approximant Central Lateral;
  };
}
//======================================================================

readonly namespace MatchingVowels {
  FeatureMask = Vowel LongVowel Nasal Diphthong NonSylabic;

  AddCell(SegPartClass[] segments, SegmentSetClass set, open, backness, features) = Cell(PaperStyle.SegmentBottom) {
    HAlign: Center;
    TextHeight: PaperStyle.BoxSize.Height;

    var filter  = s => s.Segment.Backness == backness and s.Segment.Open == open and s.Features.HasFlagMask(FeatureMask, features);
    var matches = segments.FindSlice(filter);
    switch (matches.Length) {
      case 0:
        break;

      case 1:
        MatchCell.SegmentText(set, matches[0]);
        break;

      case 2:
        Span {
          MatchCell.SegmentText(set, matches[0]);
          "â€¢" {TextColor: Colors.LightGray};
          MatchCell.SegmentText(set, matches[1]);
        };
        break;

      default:
        MatchCell.ErrorMatches(set, matches);
        break;
    }
  };

  AddRow(SegPartClass[] segments, SegmentSetClass set, open, features) = Row {
    Cell {
      VAlign: Center;
      PaperStyle.TitleBackground;
      open.Name;
    };
    AddCell(segments, set, open, each Backnesses.ValueArray, features)
  };

  ShowVowelTable(ContentStyleClass style, SegPartClass[] segments, SegmentSetClass set, SegmentFeatures features) = Block {
    PaperStyle.TitleBar {
      Separator: "-";
      each features;
    };

    var border = BorderR(0.5 pts);
    Table(PaperStyle.TableBorder, null, [new ColumnClass(1 inch, border)] + [new ColumnClass(PaperStyle.BoxSize.Width*4, border)]) {
      HAlign: Center;
      Row {
        TextHeight: 10 pts;
        PaperStyle.HeaderCell(style);
        foreach (var b in Backnesses.ValueArray) {
          PaperStyle.HeaderCell(style) {
            b;
          };
        }
      };
      AddRow(segments, set, each Opens.ValueArray, features);
    };
  };

  ShowTable(ContentStyleClass style, SegPartClass[] segments, SegmentSetClass set) = Block {
    Lang.SymbolPairRounded;
    ShowVowelTable(style, segments, set, Vowel);
    ShowVowelTable(style, segments, set, Vowel LongVowel);
    ShowVowelTable(style, segments, set, Vowel Nasal);
    ShowVowelTable(style, segments, set, Vowel LongVowel Nasal);
    ShowVowelTable(style, segments, set, Vowel Diphthong);
    ShowVowelTable(style, segments, set, Vowel Nasal Diphthong);
    ShowVowelTable(style, segments, set, Vowel NonSylabic);
    ShowVowelTable(style, segments, set, Vowel NonSylabic Diphthong);
  };
}
//======================================================================
// Diacritic markers
//======================================================================

readonly namespace MatchingDiacritics {
  ColumnDiv = 3;

  AddCell(SegmentClass segment) = Cell {
    Paragraph {
      LeftIndent: 30 pts;
      FirstIndent: -30 pts;
      DocFields.Anchor(segment.FactId);
      segment.ShowSegment {
        TextHeight: 18 pts;
      };
      Tab;
      segment.Description
    }
  };

  AddRow(segments) = Row {
    AddCell(each segments)
  };

  ShowTable = Block {
    PaperStyle.TitleBar {Lang.Diacritics};
    Table(PaperStyle.TableBorder, null, [ExtentWidth / ColumnDiv] * ColumnDiv) {
      AddRow(each (DiacriticModifiers.ToArray / ColumnDiv));
    };
    PaperStyle.TableNotes;
  };
}
//======================================================================
// Segments not in other lists
//======================================================================

readonly namespace MatchingOther {
  ColumnDiv = 2;

  AddRow(SegPartClass[] segments) = Row {
    VAlign: Center;
    foreach (var segment in segments) {
      var s = segment.Segment;
      Cell {
        HAlign: Center;
        Paragraph {
          TextHeight: 18 pts;
          s.ShowSegment;
        };
      };
      s.SegmentName;
    }
  };

  ShowTable(SegPartClass[] segments, SegmentSetClass set) = Block {
    PaperStyle.TitleBar {Lang.OtherSegments};
    Table(PaperStyle.TableBorder, null, [PaperStyle.CellSize.Width, ExtentWidth * 0.5 - PaperStyle.CellSize.Width] * ColumnDiv) {
      var slice = segments.FindSlice(segment => not set.Contains(segment));
      AddRow(each (slice / ColumnDiv));
    };
    PaperStyle.TableNotes;
  };
}

//======================================================================

class SegmentDisplayClass {
  var DataSetClass   Data;
  var SegPartClass[] SortedSegments,
                     DisplaySegments;

  Constructor(DataSetClass data) {
    Data            = data;
    DisplaySegments = data.UniqueSegments;  // Could be IPA.Segments if you want to see all possible segments in the debug tables
    SortedSegments  = data.UniqueSegments.ToSortedArray(true, @CompareAlpha);
  }

  static int CompareSegments(SegPartClass s0, SegPartClass s1) = s0.UsedCount - s1.UsedCount;

  static int CompareAlpha(SegPartClass s0, SegPartClass s1) {
    var i = s0.Ipa.Length.Compare(s1.Ipa.Length);
    if (i == 0)
      i = -s0.Ipa.Compare(s1.Ipa);
    return i;
  }

  FrequencyChart(ContentStyleClass style, SizeClass size) = Chart(size.Width, size.Height) {
    TextHeight: 11 pts;
    style.SansSerif;
    ChartType: ChartTypes.Column;
    Legend: ChartLegend {Placement: Placements.Bottom};
    ValueLabel: PaperStyle.ValueLabel {
      Lang.FrequencyPercent;
    };

    SegPartClass[] sorted = DisplaySegments.ToSortedArray(true, @CompareSegments);
    XAxis: ChartAxis {
      TextHeight: PaperStyle.SegmentTextFactor * size.Width / sorted.Length;
      (each sorted).ShowSegment;
    };
    ValueAxis: ChartAxis;
    ChartSeries {
      TextDigits: 3;
      Label: Lang.Experiment;
      foreach (var s in sorted)
        new DataPointClass(each0, s.UsedFrequency * 100.0) {Reference: s};
    };
  };

  SegmentCell(SegPartClass segment) = Cell(new EdgeClass(0.25 pts, 2 pts, Colors.LightGray)) {
    segment.Segment.Display(segment.FactId, 16 pts);
  };

  IPASegmentTable = Block {
    var c = PaperStyle.SegmentColumns;

    Table(null, null, [ExtentWidth / c]) {
      foreach (var s in (SortedSegments / c)) {
        Row {
          SegmentCell(each s);
        }
      }
    };
    PaperStyle.TableNotes;
  };

  ShowLanguageDetails(ContentStyleClass style) = Block {
    foreach (var taxon in Data.Taxa) {
      var language = taxon.Language;
      Paragraph {
        SpaceAfter: 10 pts;
        HBox(100%, null, BorderT(1 pt) + PadT(16 pts)) {
          VAlign: Center;
          Frame(40%) {
            style.Heading2 {
              language.Name;
            };
            Block {
              ParAlignment: Justify;
              language.Description;
            }
          };
          HBox(60%) {
            HAlign: Center;
            language.ShowMap(3.5 inches, 2 inches);
          }
        };
      }
    }
  };

  ShowWordsForEachSegment = Block {
    foreach (var segment in SortedSegments) {
      Paragraph(null, [0.5 inches]) {
        KeepWithNext: true;
        TextHeight: 16 pts;
        ParBackground: 90%;
        segment.ShowSegment;
       };

      Paragraph {
        ParAlignment: Justify;
        PaperStyle.IPAFamily;
        SpaceAfter: 10 pts;
        Span {
          Separator: Space*2;
          foreach (var cognate in Data.GetSortedCognates) {
            foreach (var word in cognate.Words) {
              if (word.Segments.FindElementIndex(segment) >= 0) {
                Span {
                  TipAction: word;
                  word.ShowPlain;
                }
              }
            }
          }
        };
      };
    }
  };
}

//======================================================================

abstract class DataContentClass: ContentClass {
  var DataSetClass Data;

  Constructor(DataSetClass data, title) {
    super.Constructor(title);
    Data = data;
  }
}

//======================================================================

class SegmentAssignmentsClass: DataContentClass {
  Constructor(DataSetClass data) {
    super.Constructor(data, "Segment Assignments");
  }

  override GetBody(ContentStyleClass style, title) = Block {
    Paragraph {
      var textheight = 18 pts;
      TextHeight: textheight;

      foreach (var segment in Data.UniqueSegments) {
        HBox(textheight * 3.25, null, new EdgeClass(0.25 pts, 1, 85%)) {
          VAlign: Center;
          Margin: 5;
          Span {
            HAlignment: HAligns.Center;
            TextColor: Colors.LightGray;
            TextHeight: 75%;
            each0;
          };
          Space*4;
          segment.ShowSegment;
        }
      }
    };
  };
}

//======================================================================

