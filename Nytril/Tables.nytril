using Format, Units, IPA, FeatureSet, Math;
//======================================================================

class EulerDiagramClass {
  Constructor {
  }

  TitleStyle = {TextColor: 70%};
  ChartSize  = 6 inches;
  EX(x)      = ChartSize * x * 0.01;
  EY(y)      = ChartSize * y * 0.01;

  Enclosure(x, y, w, h, color) = Canvas {
    BorderStroke: 1 pts;
    Corner: 6 pts;
    Background: color;
    X: EX(x);
    Y: EY(y);
    Size: Size(EX(w), EY(h));
  };

  NameBox(name, angle=0) = Paragraph {
    TitleStyle;
    Transform: Rotate(angle);
    TransformFit: true;
    Space;
    name;
    Space;
  };

  VNameFrame(name, x, y, width, height, color) = Enclosure(x, y, width, height, color) {
    VAlign: VAligns.Center;
    NameBox(name, 90 degrees)
  };

  FeatureMask = Vowel Nasal Vocoid LongVowel Semivowel Approximant Vibrant Lateral Affricate Occlusive Strident Sibilant Obstruent Continuant Fricative Rhotic Liquid Trill TapFlap;

  FeatureSegments(features) = Results.DisplaySegments.FindSlice(segment => segment.Features.HasFlagMask(FeatureMask, features));

  FeatureFrame(x, y, width, name, features) = Canvas {
    X: EX(x);
    Y: EY(y);
    Frame {
      Width: EX(width);
      ParAlignment: ParAlignments.Center;
      if (exists name)
        Span {TitleStyle; name};
      Paragraph {
        Separator: Space;
        (each FeatureSegments(features)).ShowSegment;
      }
    }
  };

  FeatureChart = Canvas {
    TextHeight: 16 pts;

    VNameFrame(Lang.Occlusive, 10, 0, 90, 34, Color(255, 238, 238)) {
      HAlign: HAligns.Right;
    };
    VNameFrame(Lang.Continuant, 10, 35, 90, 37, Color(229, 255, 255)) {
      HAlign: HAligns.Right;
    };
    VNameFrame(Lang.Obstruent, 0, 11, 94, 40, Color(238, 238, 255, 50%));
    VNameFrame(Lang.Vocoid, 0, 52, 78, 21, Color(238, 255, 238, 50%));
    VNameFrame(Lang.Vibrant, 20, 74, 65, 17, Color(238, 238, 255));

    Enclosure(11, 1, 83, 9, Color(255, 246, 246));   // Nasals
    Enclosure(31, 12, 62, 21, Color(246, 242, 250));  // Affricates
    Enclosure(11, 12, 19, 21, Color(246, 243, 250));  // Plosives
    Enclosure(11, 36, 80, 14, Color(240, 247, 255));  // Fricatives

    Enclosure(25, 75, 59, 7, Color(247, 247, 255)) {
      HAlign: HAligns.Left;
      VAlign: VAligns.Center;
      NameBox(Lang.TapFlap);
    };
    Enclosure(25, 83, 53, 7, Color(247, 247, 255)) {
      HAlign: HAligns.Left;
      VAlign: VAligns.Center;
      NameBox(Lang.Trill);
    };

    Enclosure(53, 13, 39, 36, Color(233, 248, 235, 50%)) {
      HAlign: HAligns.Center;
      NameBox(Lang.Strident);
    };

    Enclosure(62, 18, 25, 24, Color(245, 252, 220, 50%)); // Sibilants
    Enclosure(11, 53, 21, 18, Color(240, 255, 247));      // Vowels
    Enclosure(33, 53, 61, 18, Color(240, 255, 247, 50%)) {
      HAlign: HAligns.Left;
      NameBox(Lang.Approximant);
    };

    Enclosure(35, 59, 21, 11, Color(248, 255, 225)); // Semivowels

    Enclosure(64, 43, 26, 59, Color(255, 238, 238, 50%)) {
      HAlign: HAligns.Center;
      VAlign: VAligns.Bottom;
      NameBox(Lang.Liquid);
    };

    Enclosure(65, 44, 14, 52, Color(255, 247, 221, 50%)) {
      HAlign: HAligns.Center;
      VAlign: VAligns.Bottom;
      NameBox(Lang.Rhotic);
    };

    Enclosure(80, 44, 9, 44, Color(238, 247, 230, 70%)) {
      HAlign: HAligns.Right;
      VAlign: VAligns.Bottom;
      NameBox(Lang.Lateral, 90 degrees);
    };

    FeatureFrame(11, 1, 84, Lang.Nasal, Nasal Occlusive);
    FeatureFrame(12, 14, 17, Lang.Plosive, Stop Occlusive);
    FeatureFrame(32, 14, 20, Lang.Affricate, Affricate Occlusive);
    FeatureFrame(54, 20, 7, null, Affricate Occlusive Strident);
    FeatureFrame(65, 18, 18, Lang.Sibilant, Affricate Occlusive Strident Sibilant);
    FeatureFrame(14, 38, 22, Lang.Fricative, Fricative Obstruent Continuant);
    FeatureFrame(54, 38, 6, null, Fricative Obstruent Continuant Strident);
    FeatureFrame(64, 36, 20, null, Fricative Obstruent Continuant Strident Sibilant);
    FeatureFrame(66, 44, 10, null, Fricative Obstruent Continuant Strident Rhotic Liquid);
    FeatureFrame(80, 44, 10, null, Fricative Obstruent Continuant Strident Lateral Liquid);
    FeatureFrame(12, 53, 19, Lang.Vowel, Vowel Vocoid Continuant);
    FeatureFrame(36, 60, 19, Lang.SemiVowel, Vocoid Semivowel Approximant Continuant);
    FeatureFrame(57, 62, 5, null, Vocoid Approximant);
    FeatureFrame(66, 60, 10, null, Vocoid Approximant Rhotic Liquid);
    FeatureFrame(82, 58, 5, null, Vocoid Approximant Rhotic Liquid Lateral);
    FeatureFrame(54, 76, 10, null, Vibrant TapFlap);
    FeatureFrame(66, 76, 10, null, Vibrant TapFlap Rhotic Liquid);
    FeatureFrame(77, 77, 10, null, Vibrant TapFlap Rhotic Liquid Lateral);
    FeatureFrame(54, 84, 10, null, Vibrant Trill);
    FeatureFrame(66, 84, 10, null, Vibrant Trill Rhotic Liquid);
  };
}
//======================================================================

namespace DisplayWords {
  SegmentSound(segment) {
//    if (segment == SpaceSegment)
//      return Space;
    return segment.GlobalVariableName
  }

  WordRow(word, index) = Row {
    Style.RowBar(index);
    Cell {
      word.ShowConcept;
    };
    Cell {
      word.Plain;
    };
    Cell {
      Span {
        Separator: "-";
        SegmentSound(each word.Segments)
      }
    }
  };

  HeaderCell(d) = Cell {
    Style.SansSerif;
    Style.TitleBackground;
    EdgeB: 1 pts;
    Padding: 2 pts;
    d
  };

  ShowLanguage(taxon) = Block {
    Style.TitleBar {taxon.Language};
    Table {
      Edge: 0.5;
      Columns: [2.1 inches, 1 inches, DocMetrics.PageContent.Width - 3.1 inches];
      Row {
        HeaderCell(Lang.Cognate);
        HeaderCell(Lang.IPA);
        HeaderCell(Lang.Sounds);
      };

      var i = 0;
      foreach (var cognate in Results.UsedCognates) {
        foreach (var word in cognate.Words[taxon.Index]) {
          if (valid word.Segments)
            WordRow(word, i++);
        }
      }
    };
    Paragraph;
  };

  ShowTable {
    return ShowLanguage(each Results.Taxa);
  }
}
//======================================================================

namespace AllWords {
  AddCell(TaxonClass taxon, CognateClass cognate, textheight) = Cell {
    Background: EachIndex mod 2 == 0 ? 97% : null;
    cognate.Words[taxon.Index].ShowPaddedBlocks(textheight);
  };

  AddRow(TaxonClass taxon, cognates, textheight) = Row {
    Cell {
      PaddingL: 1 pt;
      Style.SansSerif;
      TextColor: Colors.DarkGray;
      taxon.Variable;
    };
    AddCell(taxon, each cognates, textheight)
  };

  ConceptTable(textheight, wordsperline, cognates) = HBox {
    var first = 84 pts;
    var w     = (DocMetrics.PageContent.Width - first) / wordsperline;
    Table {
      Style.IPAFamily;
      Edge: 0.5;
      Columns: [first] + [w] * wordsperline;

      Row {
        Style.TitleBackground;
        Style.SansSerif;
        Empty;
        (each cognates).Title;
      };

      AddRow(each Results.Taxa, cognates, textheight);
    };
    Paragraph;
  };

  ShowConceptTable(CognateClass cognate) = ConceptTable(10 pts, 7, [cognate]);

  ShowTable(max=1000000) = Block {
    var textheight = 10 pts;
    TextHeight: textheight;
    var wordsperline = Math.Round(DocMetrics.PageContent.Width / (13 * (textheight intu pixels)));

    foreach (var cognates in (Results.UsedCognates / wordsperline)) {
      if (EachIndex >= max)
        break;
      ConceptTable(textheight, wordsperline, cognates);
    }
  };
}

namespace MatchCell {
  SegmentText(HashSetClass set, SegmentClass segment) {
    if (not segment.Impossible) {
      set.Add(segment);
      return segment.ShowSegment;
    }
    return null;
  }

  SegmentBox(HashSetClass set, SegmentClass segment, color) = Canvas {
    HAlign: HAligns.Center;
    Size: DocMetrics.BoxSize;
    if (exists segment.?Ipa) {
      TextHeight: DocMetrics.BoxSize.Height - 6 pts;
      TextColor: color;
      SegmentText(set, segment)
    }
    else
      Style.ImpossibleBackground;
  };

  ShowBox(HashSetClass set, SegmentClass segment, color) = SegmentBox(set, segment, color) {
    if (segment.Features.HasFlag(Voiced))
      X: DocMetrics.BoxSize.Width;
  };

  ErrorMatches(HashSetClass set, matches) = Span {
    Separator: CommaSpace;
    TextColor: Colors.Red;
    MatchCell.SegmentText(set, each matches);
  };
}
//======================================================================

class TabOptionsClass {
   var Title,
       ColWidth,
       Exclude,
       Include,
       All,
       Manners,
       RowMask,
       Notes,
       RowLabels;

  Constructor(title) {
    Title = title;
  }

  CheckFlags(sflags, rflags) {
    return sflags.NotFlag(Exclude) and
           sflags.HasFlag(Include) and
           sflags.HasFlagMask(RowMask | rflags, rflags);
  }

  MatchError(matches) = matches.Length > 2 or (matches.Length == 2 and matches[0].Features.HasFlag(Voiced) == matches[1].Features.HasFlag(Voiced));

  SegmentBlock(HashSetClass set, matches) = Cell {
    Style.SegmentBottom;
    if (valid matches) {
      if (matches.Length == 1 and matches[0].Impossible)
        Style.ImpossibleBackground;
      else {
        Span {
          if (MatchError(matches))
            MatchCell.ErrorMatches(set, matches);
          else {
            Canvas {
              Size: DocMetrics.CellSize;
              MatchCell.ShowBox(set, each matches, Colors.Black)
            }
          }
        }
      }
    }
  };

  MatchInclude(SegmentClass segment, place) {
    return segment.?Place == place and
           segment.Features.NotFlag(Exclude) and
           segment.Features.HasFlag(Include) and
           Manners.FindAny(manner => CheckFlags(segment.Features, manner | All));
  }

  MatchPlace(place) {
    return Results.UniqueSegments.FindAny(segment => MatchInclude(segment, place));
  }

  AddRow(HashSetClass set, places, f) = Row {
    var features = f | All;
    Cell {
      VAlign: VAligns.Center;
      EdgeR: 0.5 pts;
      Style.TitleBackground;
      PaddingLR: 2 pts;
      TextHeight: 7 pts;

      if (exists RowLabels)
        RowLabels[EachIndex];
      else
        f;
    };

    var all = Results.DisplaySegments;// + IPA.ImpossibleSegments;
    foreach (var place in places)
      SegmentBlock(set, all.FindSlice(s => s.?Place == place and CheckFlags(s.Features, features)));
  };

  ShowTable(HashSetClass set) = Block {
    var places = Places.FindSlice(place => MatchPlace(place));
    Style.TitleBar {Title};
    Table {
      Style.TableEdge;
      Columns: [ColWidth {EdgeR: 0.5 pts}] +
               [DocMetrics.CellSize.Width {HAlign: HAligns.Center; EdgeR: 0.25 pts}] * places.Length;

      Row {
        TextHeight: 6 pts;
        Style.HeaderCell(Bold Lang.Manner);
        foreach (var place in places)
          Style.HeaderCell(place.Name, HAligns.Center);
      };
      AddRow(set, places, each Manners);
    };

    Style.TableNotes {
      Lang.ImpossibleShaded;
      Space;
      Notes;
    };
  };
}
//======================================================================

namespace MatchingConsonants {
  PulmonicTable = new TabOptionsClass(Lang.PConsonants) {
    ColWidth: 45 pts;
    Exclude: Affricate Ejective;
    Include: Pulmonic;
    All: NoFeature;
    Manners: [Nasal Stop, Nasal, Stop, Sibilant Fricative, Fricative, Approximant, TapFlap, Trill, Lateral Fricative, Lateral Approximant, Lateral TapFlap];
    RowMask: Nasal Stop Sibilant Fricative Approximant TapFlap Trill Lateral Velarized;
    Notes: Lang.SymbolPairVoiced
  };

  NonPulmonicTable = new TabOptionsClass(Lang.NPConsonants) {
    ColWidth: 80 pts;
    Exclude: Vowel Pulmonic Central;
    Include: Ejective Click Implosive Palatalized Implosive Lateral Approximant;
    All: NoFeature;
    Manners: [Stop, Ejective Stop, Ejective Fricative, Ejective Lateral Fricative, Click Tenuis, Click Nasal, Click Tenuis Lateral, Implosive, Lateral Approximant];
    RowMask: Lateral;
    Notes: Lang.SymbolPairVoiced
  };

  PulmonicAffricatesTable = new TabOptionsClass(Lang.PulmonicAffricates) {
    ColWidth: 50 pts;
    Exclude: Vowel;
    Include: Affricate Sibilant Lateral;
    All: Pulmonic Affricate;
    RowLabels: [Lang.Sibilant, Lang.Lateral, "Voiced", Lang.NonSibilant];
    Manners: [Sibilant, Lateral, Voiced, NoFeature];
    RowMask: Pulmonic Affricate Sibilant Fricative Lateral;
  };

  EjectiveAffricatesTable = new TabOptionsClass(Lang.EjectiveAffricates) {
    ColWidth: 50 pts;
    Exclude: Vowel Click Implosive Pulmonic;
    Include: Ejective Affricate Central Lateral;
    All: Ejective Affricate;
    Manners: [Central, Lateral];
    RowMask: Pulmonic Approximant Central Lateral;
  };
}
//======================================================================

namespace MatchingVowels {
  FeatureMask = Vowel LongVowel Nasal Diphthong NonSylabic;

  AddCell(HashSetClass set, open, backness, features) = Cell {
    Style.SegmentBottom;
    HAlign: HAligns.Center;
    TextHeight: DocMetrics.BoxSize.Height;

    var filter  = segment => segment.Backness == backness and segment.Open == open and segment.Features.HasFlagMask(FeatureMask, features);
    var matches = Results.DisplaySegments.FindSlice(filter);
    switch (matches.Length) {
      case 0:
        break;

      case 1:
        MatchCell.SegmentText(set, matches[0]);
        break;

      case 2:
        Span {
          MatchCell.SegmentText(set, matches[0]);
          "•" {TextColor: Colors.LightGray};
          MatchCell.SegmentText(set, matches[1]);
        };
        break;

      default:
        MatchCell.ErrorMatches(set, matches);
        break;
    }
  };

  AddRow(HashSetClass set, open, features) = Row {
    Height: 16 pts;
    Cell {
      VAlign: VAligns.Center;
      Style.TitleBackground;
      open.Name;
    };
    AddCell(set, open, each Backnesses, features)
  };

  ShowVowelTable(HashSetClass set, features) = Block {
    Style.TitleBar {Separator: "-"; each features};
    Table {
      HAlign: HAligns.Center;
      Style.TableEdge;
      Columns: [(1 inch){EdgeR: 0.5 pts}] + [DocMetrics.BoxSize.Width*4 {EdgeR: 0.25 pts}] * Backnesses.Length;
      Row {
        TextHeight: 10 pts;
        Style.HeaderCell(Empty);
        Style.HeaderCell(each Backnesses, HAligns.Center)
      };
      AddRow(set, each Opens, features);
    };
  };

  ShowTable(HashSetClass set) = Block {
    var features = [
      Vowel,
      Vowel LongVowel,
      Vowel Nasal,
      Vowel LongVowel Nasal,
      Vowel Diphthong,
      Vowel Nasal Diphthong,
      Vowel NonSylabic,
      Vowel NonSylabic Diphthong,
    ];

    Lang.SymbolPairRounded;
    ShowVowelTable(set, each features);
  };
}
//======================================================================
// Diacritic markers
//======================================================================

namespace MatchingDiacritics {
  ColumnDiv = 3;

  AddCell(SegmentClass segment) = Cell {
    Paragraph {
      LeftIndent: 30 pts;
      FirstIndent: -30 pts;
      LocationMark: segment.GlobalVariablePath;
      segment.ShowSegment {
        TextHeight: 18 pts;
      };
      Tab;
      segment.Description
    }
  };

  AddRow(segments) = Row {
    AddCell(each segments)
  };

  ShowTable = Block {
    Style.TitleBar {Lang.Diacritics};
    Table {
      Style.TableEdge;
      Columns: [DocMetrics.PageContent.Width / ColumnDiv] * ColumnDiv;
      AddRow(each (DiacriticModifiers / ColumnDiv));
    };
    Style.TableNotes;
  };
}
//======================================================================
// Segments not in other lists
//======================================================================

namespace MatchingOther {
  ColumnDiv = 2;

  AddCell(SegmentClass segment) = {
    Cell {
      VAlign: VAligns.Center;
      HAlign: HAligns.Center;
      LocationMark: segment.GlobalVariablePath;
      TextHeight: 18 pts;
      segment.ShowSegment;
    };
    Cell {
      VAlign: VAligns.Center;
      segment.SegmentName;
    }
  };

  AddRow(SegmentClass[] segments) = Row {
    AddCell(each segments)
  };

  ShowTable(HashSetClass set) = Block {
    Style.TitleBar {Lang.OtherSegments};
    Table {
      Style.TableEdge;
      Columns: [DocMetrics.CellSize.Width, DocMetrics.PageContent.Width * 0.5 - DocMetrics.CellSize.Width] * ColumnDiv;
      var segments = Results.DisplaySegments.FindSlice(segment => not set.Contains(segment));
      AddRow(each (segments / ColumnDiv));
    };
    Style.TableNotes;
  };
}
//======================================================================
// Segment Tree
//======================================================================

namespace SegmentTree {
  AddNode(name) = new NodeClass(name) {
    Bevel: 20%;
    Curvature: 20%;
  };

  AddSegments(DictionaryClass set, name, predicate, width=3 inches) {
    var segments = Results.DisplaySegments.FindSlice(predicate);
    if (valid segments) {
      var label = Frame {
        Width: width;
        Paragraph {
          LeftIndent: 0.95 inches;
          FirstIndent: -0.95 inches;
          Span {
            TextBackground: 95%;
            name;
            Tab;
          };
          Span {
            TextHeight: 10 pts;
            Separator: Space;
            foreach (var segment in segments) {
              var good = set.Add(segment);
              segment.ShowSegment;
            }
          }
        }
      };
      return new NodeClass(label);
    }
    else
      return null;
  }

  AddVowels(DictionaryClass set, backness) {
    return AddSegments(set, backness.Name, s => s.Features.HasFlag(Vowel) and s.Backness == backness);
  }

  AddFlag(DictionaryClass set, all, features, other) {
    return AddSegments(set, other.Name, s => (not set.Contains(s)) and s.Features.HasFlagMask(all, features) and s.Features.HasFlagMask(other, other));
  }

  AddConsonants(DictionaryClass set, name, all, features) = AddNode(name) {
    AddFlag(set, all, features, each [Tenuis, Click, Nasal, Ejective, Fricative, Sibilant, Lateral, Stop, Approximant, TapFlap, Trill, NoFeature]);
  };

  AddVoicedPairs(DictionaryClass set, name, all, features) = AddNode(name) {
    AddConsonants(set, Lang.Voiced, all Voiced, features Voiced);
    AddConsonants(set, Lang.Voiceless, all Voiced, features);
  };

  GetNodes = new NodeClass() {
    var set1 = new DictionaryClass(256);
    var set2 = new DictionaryClass(256);
    var all  = Vowel Pulmonic Affricate;

    AddNode(Lang.Vowels) {
      AddVowels(set1, each Backnesses)
    };
    AddNode(Lang.Affricates) {
      AddVoicedPairs(set1, Lang.NonPulmonic, all, Affricate);
      AddVoicedPairs(set1, Lang.Pulmonic, all, Pulmonic Affricate);
    };
    AddNode(Lang.Consonants) {
      AddVoicedPairs(set1, Lang.Pulmonic, all, Pulmonic);
      AddVoicedPairs(set1, Lang.NonPulmonic, all, NoFeature);
    };
    AddSegments(set2, "Other", segment => true, 4 inches)
  };

  ShowTree = Paragraph {
    Tree {
      Width: 7 inches;
      LabelGap: 4 pts;
      Root: GetNodes;
    }
  };
}
//======================================================================

