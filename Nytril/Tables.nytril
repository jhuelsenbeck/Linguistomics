using Format, Units, IPA, FeatureSet;
//======================================================================

with Metrics {
  SegmentColumns = 4;
  SegmentSize    = 40 pts;
}
//======================================================================

class WordClass {
  var Language,
      Concept,
      Text,
      Segments;

  Constructor(language, concept, text) {
    Language = language;
    Concept  = ConceptsList.GetField(concept);
    Text     = text;
    if (text.Length > 0) {
      Segments = IPA.SegmentDictionary.FindTokens(text, IPA.NoSegment);
      // Test that the word's text is the same as the segments converted back into text
      System.Assert(text == String(Span {(each Segments).Ipa}), "Round-trip error with text " text);
    }
    else
      Segments = [];
  }

  ShowConcept = Span {
    Style.SansSerif;
    Popup: Delegate(ref PopupConcept);
    Concept;
  };

  PopupConcept = Frame {
    AllWords.ShowConceptTable(Concept);
  };
}
//======================================================================

class LanguageClass {
  var Name,
      Cases,
      Words;

  Constructor(name, cases=0, words=null) {
    Name  = name;
    Cases = cases;
    if (exists words)
      Words = AddWord(each words);
  }

  AddWord(word) = new WordClass(this, word.GlobalVariableName, word);
}
//======================================================================

class ConceptRecord {
  var Cells,
      MaxLength;

  Constructor(concept) {
    Cells     = new ListClass(128);
    MaxLength = 0;

    foreach (var language in Results.UsedLanguages) {
      var found = false;
      foreach (var word in language.Words) {
        if (word.Concept == concept) {
          Cells.Add(word);
          var l = word.Segments.Length;
          if (l > MaxLength)
            MaxLength = l;
          found = true;
          break;
        }
      }
      if (!found)
        Cells.Add(new WordClass(language, concept, Empty));
    }
  }

  GetGeneText(concept, language) = language.Words.FindSlice(word => word.Concept == concept);
}
//======================================================================

with Results {
  AddConceptRecord(concept) = new ConceptRecord(concept);

  GetTaxaArray(lang) = new TaxonClass(lang, EachIndex);

  UsedLanguages    = Math.FindSlice(Languages, lang => lang.Words != null);
  WordConceptArray = AddConceptRecord(each ConceptsList);
  UniqueSegments   = DisplayCharacters.FindUniqueSegments;
  Compute          = new ComputeClass();
  TaxaArray        = GetTaxaArray(each UsedLanguages);
  UsedSegments     = UniqueSegments;//IPA.Segments;
}
//======================================================================
// Consonants
//======================================================================

with MatchingConsonants {
  PulmonicTable = {
    Title: Lang.PConsonants;
    ColWidth: 45 pts;
    Exclude: Affricate Ejective;
    Include: Pulmonic;
    All: NoFeature;
    Manners: [Nasal, Stop, Sibilant Fricative, Fricative, Approximant, TapFlap, Trill, Lateral Fricative, Lateral Approximant, Lateral TapFlap];
    RowMask: Nasal Stop Sibilant Fricative Approximant TapFlap Trill Lateral Velarized;
    Notes: Lang.SymbolPairVoiced
  };

  NonPulmonicTable = {
    Title: Lang.NPConsonants;
    ColWidth: 80 pts;
    Exclude: Vowel Pulmonic Central;
    Include: Ejective Click Implosive;
    All: NoFeature;
    Manners: [Ejective Stop, Ejective Fricative, Ejective Lateral Fricative, Click Tenuis, Click Nasal, Click Tenuis Lateral, Implosive];
    RowMask: Lateral;
    Notes: Lang.SymbolPairVoiced
  };

  PulmonicAffricatesTable = {
    Title: Lang.PulmonicAffricates;
    ColWidth: 50 pts;
    Exclude: Vowel;
    Include: Affricate Sibilant Lateral;
    All: Pulmonic Affricate;
    RowLabels: [Lang.Sibilant, Lang.NonSibilant, Lang.Lateral];
    Manners: [Sibilant, NoFeature, Lateral];
    RowMask: Pulmonic Affricate Sibilant Fricative Lateral;
  };

  EjectiveAffricatesTable = {
    Title: Lang.EjectiveAffricates;
    ColWidth: 50 pts;
    Exclude: Vowel Click Implosive Pulmonic;
    Include: Ejective Affricate Central Lateral;
    All: Ejective Affricate;
    Manners: [Central, Lateral];
    RowMask: Pulmonic Approximant Central Lateral;
  };

  ShowTables {
    var segments = new DictionaryClass(256);
    return Block {
      MatchingOptions.ShowTable(segments, each [PulmonicTable, NonPulmonicTable]);
      PageBreak;
      MatchingVowels.ShowTable(segments);
      MatchingOptions.ShowTable(segments, each [PulmonicAffricatesTable, EjectiveAffricatesTable]);
      MatchingOther.ShowTable(segments);
    }
  }
}
//======================================================================

with DisplayWords {
  WordRow(word, index) = Row {
    Style.RowBar(index);
    Cell {
      word.ShowConcept;
    };
    Cell {
      word.Text;
    };
    Cell {
      Span {
        Separator: "-";
        SegmentSound(each word.Segments)
      }
    }
  };

  HeaderCell(d) = Cell {
    Style.SansSerif;
    Style.TitleBackground;
    EdgeB: 1 pts;
    Padding: 2 pts;
    d
  };

  ShowTable {
    ShowLanguage(each Results.UsedLanguages);
  }

  ShowLanguage(language) = Block {
    Table {
      Columns: [0.8 inches, 1.5 inches, Metrics.Content.Width - 2.3 inches];
      Style.TitleBar(language.GlobalVariableName, 3);
      Row {
        HeaderCell(Lang.Concept);
        HeaderCell(Lang.IPA);
        HeaderCell(Lang.Sounds);
      };

      var i = 0;
      foreach (var word in language.Words) {
        if (exists word.Concept)
          WordRow(word, i++);
      }
    };
    Paragraph;
  };
}
//======================================================================

with AllWords {
  AddCell(concept, language) = Cell {
    (each IPA.FindWordsWithConcept(language, concept)).Text
  };

  AddRow(language, concepts) = Row {
    Cell {
      Style.SansSerif;
      TextColor: Colors.DarkGray;
      language.GlobalVariableName
    };
    AddCell(each concepts, language)
  };

  ConceptTable(languages, concepts) = Block {
    Table {
      Edge: 0.5;
      Columns: [70 pts] + [54 pts] * concepts.Length;
      Row {
        Style.TitleBackground;
        Style.SansSerif;
        Empty;
        each concepts;
      };
      AddRow(each languages, concepts)
    };
    Paragraph;
  };

  ShowConceptTable(concepts) = ConceptTable(Results.UsedLanguages, [concepts]);

  ShowTable = ShowLangConcept(Results.UsedLanguages, ConceptsList);

  ShowLangConcept(languages, concepts) = Block {
    TextHeight: 12 pts;
    ConceptTable(languages, each (concepts / 8))
  };
}
//======================================================================

with DisplayCharacters {
  CompleteWord(def)     = Math.FindAny(ConceptsList, concept => concept == def.Concept);
  GetWordList(language) = Math.FindSlice(language.Words, def => CompleteWord(def));

  FindUniqueSegments {
    var set = new DictionaryClass(256);
    foreach (var language in each Results.UsedLanguages) {
      foreach (var word in GetWordList(language))
        set.Add(each word.Segments);
    }
    return set.Values;
  }

  WordsWithSegment(segment) {
    var set = new DictionaryClass(256);
    foreach (var language in Results.UsedLanguages) {
      foreach (var word in GetWordList(language)) {
        if (Math.FindAny(word.Segments, s => s == segment))
          set.Add(word, word.Text);
      }
    }
    return set.Values;
  }

  CharacterRow(segment) = Row {
    Cell {
      HAlign: HAligns.Center;
      Style.TitleBackground;
      Nexus.CharacterList[EachIndex]
    };
    Cell {
      HAlign: HAligns.Center;
      segment.ShowSegment;
    };
    Cell {
      var words = WordsWithSegment(segment);

      Style.IPAFamily;
      Span {
        Separator: ", ";
        (each words).Text
      }
    }
  };

  ShowTable = Block {
    Table {
      Style.TableEdge;
      Columns: [0.5 inches, 0.7 inches, 6 inches];
      Row {
        Style.HeaderCell("Char.", HAligns.Center);
        Style.HeaderCell(Lang.Segment, HAligns.Center);
        Style.HeaderCell("Words containing this segment")
      };
      CharacterRow(each Results.UniqueSegments);
    };
    Style.TableNotes
  };
}
//======================================================================
// Consonants
//======================================================================

with MatchingOptions {
  CheckFlags(sflags, rflags, options)   = sflags.NotFlag(options.Exclude)
                                          and sflags.HasFlag(options.Include)
                                          and sflags.HasFlagMask(options.RowMask | rflags, rflags);

  AnyManners(manner, features, options) = CheckFlags(features, manner | options.All, options);

  SamePlace(segment, place)             = segment.?Place and place and
                                          segment.Place == place;

  MatchInclude(segment, place, options) = SamePlace(segment, place) and
                                        segment.Features.NotFlag(options.Exclude) and
                                        segment.Features.HasFlag(options.Include) and
                                        Math.FindAny(options.Manners, manner => AnyManners(manner, segment.Features, options));

  MatchPlace(place, options)          = Math.FindAny(AllSegments, segment => MatchInclude(segment, place, options));
  GetPlaces(options)                  = Math.FindSlice(Places, place => MatchPlace(place, options));


  SegmentText(segments, segment) {
    if (not segment.Impossible) {
      segments.Add(segment);
      return segment.ShowSegment;
    }
    return null;
  }

  SegmentBox(segments, segment, color) = Canvas {
    HAlign: HAligns.Center;
    Size: Metrics.BoxSize;
    if (exists segment.?Ipa) {
      TextHeight: Metrics.BoxSize.Height - 4 pts;
      TextColor: color;
      SegmentText(segments, segment)
    }
    else
      Style.ImpossibleBackground;
  };

  ShowBox(segments, segment, color) = SegmentBox(segments, segment, color) {
    if (segment.Features.HasFlag(Voiced))
      X: Metrics.BoxSize.Width;
  };

  MatchError(matches) = matches.Length > 2 or (matches.Length == 2 and matches[0].Features.HasFlag(Voiced) == matches[1].Features.HasFlag(Voiced));

  SegmentBlock(segments, matches) = Cell {
    Style.SegmentBottom;
    if (matches.Length > 0) {
      if (matches.Length == 1 and matches[0].Impossible)
        Style.ImpossibleBackground;
      else {
        TextHeight: 1 pts;
        Span {
          Canvas {
            Size: Metrics.CellSize;
            ShowBox(segments, each matches, MatchError(matches) ? Colors.Red : Colors.Black)
          }
        }
      }
    }
  };

  AddCell(segments, options, place, features) {
    return SegmentBlock(segments, Math.FindSlice(AllSegments, s => SamePlace(s, place) and CheckFlags(s.Features, features, options)));
  }

  AddRow(segments, options, places, f) {
    var allflags = f | options.All;
    return Row {
      Cell {
        VAlign: VAligns.Center;
        EdgeR: 0.5 pts;
        Style.TitleBackground;
        PaddingLR: 2 pts;
        TextHeight: 7 pts;

        if (exists options.?RowLabels)
          options.RowLabels[EachIndex];
        else
          f;
      };
      AddCell(segments, options, each places, allflags)
    }
  }

  PlaceHeader(place) = Style.HeaderCell(place.Name, HAligns.Center);

  ShowTable(segments, options) {
    var places = GetPlaces(options);

    return Block {
      Table {
        Style.TableEdge;
        Columns: [options.ColWidth {EdgeR: 0.5 pts}] +
                 [Metrics.CellSize.Width {HAlign: HAligns.Center; EdgeR: 0.25 pts}] * places.Length;

        Style.TitleBar(options.Title, places.Length+1);
        Row {
          TextHeight: 6 pts;
          Style.HeaderCell(Bold Lang.Manner);
          PlaceHeader(each places)
        };
        AddRow(segments, options, places, each options.Manners);
      };
      Style.TableNotes {
        Lang.ImpossibleShaded;
        Space;
        options.?Notes
      };
    };
  }
}
//======================================================================
// Vowels
//======================================================================

with MatchingVowels {
  AddBlock(set, matches) = Cell {
    Style.SegmentBottom;
    HAlign: HAligns.Center;
    TextHeight: Metrics.BoxSize.Height;
    if (matches.Length == 2) {
      Span {
        MatchingOptions.SegmentText(set, matches[0]);
        " • " {TextColor: Colors.LightGray};
        MatchingOptions.SegmentText(set, matches[1]);
      }
    }
    else if (matches.Length == 1)
      MatchingOptions.SegmentText(set, matches[0]);
  };

  MatchVowelAny(segment, data)          = segment.Features.HasFlagMask(Vowel LongVowel Nasal, data.Feature | Vowel) and segment.Open == data.Open;
  MatchVowelPair(segment, data)         = segment.?Backness and data?.Backness and segment.Backness == data.Backness and MatchVowelAny(segment, data);
  FindAnyOpen(set, feature, open)       = Math.FindAny(Results.UsedSegments, segment => MatchVowelAny(segment, {Open: open; Feature: feature}));
  AddCell(set, feature, open, backness) = AddBlock(set, Math.FindSlice(Results.UsedSegments, segment => MatchVowelPair(segment, {Open: open; Feature: feature; Backness: backness})));

  AddRow(set, feature, open) {
    if (FindAnyOpen(set, feature, open)) {
      return Row {
        Cell {
          VAlign: VAligns.Center;
          Style.TitleBackground;
          open.Name
        };
        AddCell(set, feature, open, each Backnesses)
      };
    }
    else
      return null;
  }

  ShowVowelTable(set, feature, title) = Table {
    HAlign: HAligns.Center;
    Style.TableEdge;
    Columns: [(1 inch){EdgeR: 0.5 pts}] + [Metrics.BoxSize.Width*3 {EdgeR: 0.25 pts}] * Backnesses.Length;
    Style.TitleBar(title, Backnesses.Length+1);
    Row {
      TextHeight: 10 pts;
      Style.HeaderCell(Empty);
      Style.HeaderCell(each Backnesses, HAligns.Center)
    };
    AddRow(set, feature, each Opens)
  };

  ShowTable(set) = Block {
    ShowVowelTable(set, NoFeature, Lang.Vowels);
    Style.TableNotes {
      Lang.SymbolPairRounded;
    };
    ShowVowelTable(set, LongVowel, Lang.LongVowels);
    Paragraph;
  };
}
//======================================================================
// Diacritic markers
//======================================================================

with MatchingDiacritics {
  ColumnDiv = 3;

  AddCell(segment) = Cell {
    Paragraph {
      LeftIndent: 0.5 inches;
      FirstIndent: -0.5 inches;
      LocationMark: segment.GlobalVariablePath;
      segment.ShowSegment {
        TextHeight: 18 pts;
        Tab;
      };
      segment.Description
    }
  };

  AddRow(segments) = Row {
    AddCell(each segments)
  };

  ShowTable = Block {
    Table {
      Style.TableEdge;
      Columns: [Metrics.Content.Width / ColumnDiv] * ColumnDiv;
      Style.TitleBar(Lang.Diacritics, ColumnDiv);
      AddRow(each DiacriticModifiers / ColumnDiv);
    };
    Style.TableNotes
  };
}
//======================================================================
// Segments not in other lists
//======================================================================

with MatchingOther {
  ColumnDiv = 2;

  AddCell(segment) = {
    Cell {
      VAlign: VAligns.Center;
      HAlign: HAligns.Center;
      TextHeight: 20 pts;
      LocationMark: segment.GlobalVariablePath;
      segment.ShowSegment;
    };
    Cell {
      VAlign: VAligns.Center;
      segment.SegmentName;
    }
  };

  AddRow(segments) = Row {
    AddCell(each segments)
  };

  ShowTable(set) = Block {
    Table {
      Style.TableEdge;
      Columns: [Metrics.BoxSize.Width, Metrics.Content.Width * 0.5 - Metrics.BoxSize.Width] * ColumnDiv;
      Style.TitleBar(Lang.OtherSegments, ColumnDiv*2);
      AddRow(each (Math.FindSlice(Results.UsedSegments, segment => not Math.FindAny(set, segment)) / ColumnDiv));
    };
    Style.TableNotes
  };
}
//======================================================================
// Segment Tree
//======================================================================

with SegmentTree {
  AddNode(name) = new TreeNodeClass(name) {
    Bevel: 20%;
    Curvature: 20%;
  };

  AddSegments(set, name, predicate, width=3 inches) {
    var segments = Math.FindSlice(Results.UsedSegments, predicate);
    if (segments.Length > 0) {
      var label = Frame {
        Width: width;
        Paragraph {
          LeftIndent: 0.95 inches;
          FirstIndent: -0.95 inches;
          Span {
            TextBackground: 95%;
            name;
            Tab;
          };
          Span {
            TextHeight: 10 pts;
            Separator: Space;
            foreach (var segment in segments) {
              var good = set.Add(segment);
              segment.ShowSegment;
            }
          }
        }
      };
      return new TreeNodeClass(label);
    }
    else
      return null;
  }

  AddVowels(set, backness)           = AddSegments(set, backness.Name, s => s.Features.HasFlag(Vowel) and s.Backness == backness);
  AddFlag(set, all, features, other) = AddSegments(set, other.Name, s => not Math.FindAny(set, s) and s.Features.HasFlagMask(all, features) and s.Features.HasFlagMask(other, other));

  AddConsonants(set, name, all, features) = AddNode(name) {
    AddFlag(set, all, features, each [Tenuis, Click, Nasal, Ejective, Fricative, Sibilant, Lateral, Stop, Approximant, TapFlap, Trill, NoFeature]);
  };

  AddVoicedPairs(set, name, all, features) = AddNode(name) {
    AddConsonants(set, Lang.Voiced, all Voiced, features Voiced);
    AddConsonants(set, Lang.Voiceless, all Voiced, features);
  };

  GetNodes = new TreeNodeClass() {
    var set1 = new DictionaryClass(256);
    var set2 = new DictionaryClass(256);
    var all  = Vowel Pulmonic Affricate;

    AddNode(Lang.Vowels) {
      AddVowels(set1, each Backnesses)
    };
    AddNode(Lang.Affricates) {
      AddVoicedPairs(set1, Lang.NonPulmonic, all, Affricate);
      AddVoicedPairs(set1, Lang.Pulmonic, all, Pulmonic Affricate);
    };
    AddNode(Lang.Consonants) {
      AddVoicedPairs(set1, Lang.Pulmonic, all, Pulmonic);
      AddVoicedPairs(set1, Lang.NonPulmonic, all, NoFeature);
    };
    AddSegments(set2, "Other", segment => true, 4 inches)
  };

  ShowTree = Paragraph {
    Tree {
      Width: 7 inches;
      LabelGap: 2 pts;
      Root: GetNodes;
    }
  };
}
//======================================================================

