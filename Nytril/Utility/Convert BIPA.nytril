using Format, Units, IO, DB;

//================================================================

class MyDocClass: DocumentClass {
  Constructor {
    super.Constructor(#2f91b3da-1566-4591-bcc7-1ec7b798a87f#, "Convert BIPA");
  }

  override GetDocument = Document {
    Schema.ShowDoc;
  };
}

Schema = new LogSchemaClass;


Main.Documents.MainDocument = new MyDocClass;

//================================================================

class FileActionClass: ActionClass {
  Constructor {
    super.Constructor(Actions.Execute, null);
  }

  override EventResponseClass Execute {
    if (IO.Write(Schema.ShowDoc, Folders.Source Folders.Up FileName("BIPA.nytril")))
      return EventResponses.MessageTip("Files created");
    else
      return EventResponses.MessageBox("Error", "Error creating Files", Icons.error);
  }
}

//================================================================

class FeatureClass {
  var Name,
      Index,
      Flag;

  Constructor(name, index) {
    Name  = name;
    Index = index;
    Flag  = 1 << index;
  }
}

enum MouthPlacements {
  None,
  Low,
  MidLow,
  Mid,
  MidHigh,
  High,
}

class SegmentClass {
  var string Description;
  var        Text,
             Code,
             Props,
             From,
             Via,
             To;

  Constructor(string description, string text, code) {
    Description = description.Replace("-", "_");
    Text        = text.Normalize(NormalizationForms.FormC);
    Code        = code;
    Props       = 0;
    From        = MouthPlacements.None;
    Via         = MouthPlacements.None;
    To          = MouthPlacements.None;
  }
}

//================================================================

class LogSchemaClass: DbSchemaClass {
  var DB.DbFieldClass                     Description,
                                          Text,
                                          Code;
  var SegmentClass[]                      Segments;
  var StringDictionaryClass<FeatureClass> Features;
  var                                     From,
                                          Via,
                                          To;

  Constructor {
    super.Constructor("log");
    Description = new("description", ValueTypes.String);
    Text        = new("text", ValueTypes.String);
    Code        = new("code", ValueTypes.Int32);
    AddField(Description);
    AddField(Text);
    AddField(Code);

    var list = new ListClass<SegmentClass>(2048);
    var view = ReadTextFile(res "BIPA.txt", true);
    foreach (var row in view)
      list.Add(new SegmentClass(row.FindValue(Description), row.FindValue(Text), row.FindValue(Code)));
    Segments  = list.ToArray;

    Features = new(128);
    foreach (var s in Segments) {
      From = MouthPlacements.None;
      Via  = MouthPlacements.None;
      To   = MouthPlacements.None;

      string[] props = s.Description.Split(Space);
      foreach (var p in props) {
        var i = p.IndexOf("_and_");
        if (i > 0) {
          AddFeature(p[0..<i], s);
          AddFeature(p[(i+5)..], s);
        }
        else
          AddFeature(p, s);
      }
      s.From = From;
      s.Via  = Via;
      s.To   = To;
    }
  }

  void AddFeature(string name, SegmentClass s) {
    name = name[0].ToUpper + name[1..];

    switch (name) {
      case "From_high":
        From = MouthPlacements.High;
        return;

      case "From_low":
        From = MouthPlacements.Low;
        return;

      case "From_mid":
        From = MouthPlacements.Mid;
        return;

      case "From_mid_high":
        From = MouthPlacements.MidHigh;
        return;

      case "From_mid_low":
        From = MouthPlacements.Mid;
        return;

      case "To_high":
        To = MouthPlacements.High;
        return;

      case "To_low":
        To = MouthPlacements.Low;
        return;

      case "To_mid":
        To = MouthPlacements.Mid;
        return;

      case "To_mid_high":
        To = MouthPlacements.MidHigh;
        return;

      case "To_mid_low":
        To = MouthPlacements.Mid;
        return;

      case "Via_high":
        Via = MouthPlacements.High;
        return;

      case "Via_low":
        Via = MouthPlacements.Low;
        return;

      case "Via_mid":
        Via = MouthPlacements.Mid;
        return;

      case "Via_mid_high":
        Via = MouthPlacements.MidHigh;
        return;

      case "Via_mid_low":
        Via = MouthPlacements.Mid;
        return;

      case "Alveolo_palatal":
        AddFeature("Alveolo", s);
        AddFeature("Palatal", s);
        return;

      case "Palatal_velar":
        AddFeature("Palatal", s);
        AddFeature("Velar", s);
        return;

      case "Labio_dental":
        AddFeature("Labial", s);
        AddFeature("Dental", s);
        return;

      case "Labio_palatal":
        AddFeature("Labial", s);
        AddFeature("Palatal", s);
        return;

      case "Labio_velar":
        AddFeature("Labial", s);
        AddFeature("Velar", s);
        return;

      case "Close_mid":
        AddFeature("Close", s);
        AddFeature("Mid", s);
        return;

      case "Open_mid":
        AddFeature("Open", s);
        AddFeature("Mid", s);
        return;

      case "Mid_long":
        AddFeature("Long", s);
        AddFeature("Mid", s);
        return;

      case "Nasal_click":
        AddFeature("Nasal", s);
        AddFeature("Click", s);
        return;

      case "Non_syllabic":
      case "Unrounded":
      case "Consonant":
      case "Voiceless":
        return;
    }

    var fp = Features.GetValue(name);
    if (fp is null) {
      fp = new FeatureClass(name, Features.Length);
      Features.Add(fp, name);
    }
    s.Props |= fp.Flag;
  }

  AddProps(props) = Span {
    Separator: Space;
    foreach (var f in Features) {
      if ((props & f.Value.Flag) != 0)
        f.Value.Name;
    }
  };

  ShowDoc = TextBlock {
    "using Format, WordGroups;";
    Empty;
    "namespace Segments;";
    "//==================================================";
    Empty;
    "flags Features {";
    "  None,";
    foreach (var f in Features.ToArray.ToSortedArray(false)) {
      Span {
        "  ";
        f.Name;
        ",";
      }
    }
    "}";
    Empty;

    var vowel = Features.GetValue("Vowel").Flag;

    foreach (var segment in Segments) {
      Span {
        "S";
        segment.Code;
        Space * (5 - (segment.Code as string).Length);
        "= new ";

        if ((segment.Props & vowel) != 0)
          "Vowel";
        else
          "Consonent";

        "Class(";

        AddProps(segment.Props);

        ", \"";
        Span {
          TextColor: Colors.DarkRed;
          TextFamily: TextFamilies.LinuxLibertineO;
          segment.Text;
        }
        "\");";
      }
    }
  };
}

//================================================================
