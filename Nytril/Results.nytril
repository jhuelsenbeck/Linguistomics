using Format, Units;

readonly ResultsClass MainResults = new;

//======================================================================

typedef StatMatrix MatrixClass<StatClass>;
typedef StatVector VectorClass<StatClass>;
typedef StatArray  StatClass[];
typedef StatMat    StatClass[][];

//======================================================================

class ResultsClass {
  const double CutoffProbability = 0.95;
  const        CutoffPercent     = (CutoffProbability * 100.0) %;

  var DataSetClass      Data;
  var RunResultsClass   Poisson,
                        NaturalClass,
                        MainRun;
  var RunResultsClass[] ModelRuns;

  Constructor {
    Data = new(null, "Europe3", "Europe3");

    var set  = Data.TreeSets[0];

    Poisson      = new(set.Models[1].Run[1]); // For some reason, this run succeeded but not Run[0]
    NaturalClass = new(set.Models[0].Run[0]);
    ModelRuns    = [Poisson, NaturalClass];
    MainRun      = NaturalClass;

    var paths = IO.ReadScripts((each ModelRuns).AlignmentFile);
    foreach (var a in paths)
      ModelRuns[each0].ReadAlignments(Data, a.Root);
  }
}

//======================================================================

class CognateIdClass {
  var Concept,
      Cognate,
      Count;

  Constructor(concept, cognate, count) {
    Concept = concept;
    Cognate = cognate ?? DefaultCognate;
    Count   = count;
  }

  AlignIndexClass FindAlignment(RunResultsClass run) {
    foreach (var a in run.Alignments) {
      if (a.ConceptName == Concept and a.CognateName == Cognate)
        return a;
    }
    return null;
  }
}

//======================================================================

class StatClass {
  var Lower,
      Mean,
      Upper;

  Constructor(lower, mean, upper) {
    Lower = lower;
    Mean  = mean;
    Upper = upper;
  }

  ShowRight(number) = HBox {
    Space*2;
    TextHeight: 80%;
    TextColor: Colors.Gray;
    number;
  };

  ShowBox = VBox {
    HAlign: HAligns.Center;
    TextDigits: 3;
    TextSignificant: true;
    ShowRight(Upper);
    Mean;
    ShowRight(Lower);
  };

  override GetLayoutTip = ShowBox;
}

//======================================================================

class RunResultsClass {
  var RunExperimentClass Run;
  var StatMat            NCQRates,
                         TransitionStats;
  var StatArray          NCQFreqs;
  var AlignedCountClass  QRates,
                         AverageRates;
  var AlignIndexClass[]  Alignments;
  var double             InsertionRate,
                         InsertionRateLow,
                         InsertionRateHigh,
                         DeletionRate,
                         DeletionRateLow,
                         DeletionRateHigh;
  var bool               Complete;
  var                    GapSpectrum,
                         EquilibriumFrequencies,
                         AlignmentFile;

  Constructor(RunExperimentClass run) {
    Run           = run;
    AlignmentFile = Info.ExperimentRoot run.RootFolder Info.AlignmentFile;
  }

  static int CompareAlignment(AlignIndexClass a0, AlignIndexClass a1) {
    var c = a0.Alignments.Length.Compare(a1.Alignments.Length);
    if (c == 0)
      return a0.ConceptName.Compare(a1.ConceptName);
    return c;
  }

  void ReadAlignments(DataSetClass data, align) {
    var treefile = Info.ExperimentRoot Run.RootFolder Info.TreeFile;
    Complete = IO.FileExists(treefile);
    if (Complete)
      Run.ResultTree = IO.ReadTree(treefile, attribute LangNodeClass);


    QRates                 = new(data, align.QRates, false);
    AverageRates           = new(data, align.AverageRates, true);

    NCQFreqs               = align.?NCQFreqs as StatArray;
    TransitionStats        = align.?TransitionStats as StatMat;
    NCQRates               = align.?NCQRates as StatMat;
    EquilibriumFrequencies = align.?EquilibriumFrequencies;
    InsertionRate          = align.?InsertionRateMean;
    InsertionRateLow       = align.?InsertionRateLow;
    InsertionRateHigh      = align.?InsertionRateHigh;
    DeletionRate           = align.?DeletionRateMean;
    DeletionRateLow        = align.?DeletionRateLow;
    DeletionRateHigh       = align.?DeletionRateHigh;
    GapSpectrum            = align.?GapSpectrum;

    var alignments = new ListClass<AlignIndexClass>(1024);
    foreach (var a in align.Alignments) {
      foreach (var c in data.UsedCognates) {
        if (c.Concept.Name == a.ConceptName and c.Name == a.CognateName) {
          a.Cognate = c;
          alignments.Add(a);
          break;
        }
      }
    }
    Alignments = alignments.ToSortedArray(false, @CompareAlignment);
  }
}

//======================================================================

class AlignmentChartClass {
  var DataSetClass    Data;
  var RunResultsClass Run;

 Constructor(DataSetClass data, RunResultsClass run) {
    Data = data;
    Run  = run;
  }

  ShowChart(SizeClass size) = VBox(size.Width, size.Height, 0.5) {
    PaperStyle.SansSerif;
    // Try to make proportional squares
    var xitems = size.Width / 130 as int;
    var yitems = Math.Floor((Run.Alignments.Length + xitems - 1) / xitems);
    var bsize  = new SizeClass(size.Width / xitems, size.Height / yitems);
    AlignIndexClass[][] rows = Run.Alignments / xitems;

    TextHeight: Math.Min(8 pts, bsize.Height - 3.2 pt);

    foreach (var row in rows) {
      HBox(null, bsize.Height, BorderB(new EdgeClass(0.25 pts, 1, 90%))) {
        VAlign: VAligns.Center;
        foreach (var a in row) {
          VBox(bsize.Width, null) {
            HAlign: HAligns.Center;

            var ap = new AlignPairClass(Data, a);
            Paragraph {
              Span {
                ap.Name;
                TipAction: ap;
              };
            };
            Paragraph {
              TextHeight: 10 pts;
              TextColor: Colors.LightGray;
              a.TotalCount;
            };
          }
        }
      }
    }
  };

  ShowAll = Block {
    foreach (var a in Run.Alignments) {
      new AlignPairClass(Data, a).ShowDetails(5, false, 10 pts);
      Paragraph(BorderT(1));
    }
  };

  ShowSet(CognateIdClass[] examples, bool label) = Table(null, null, label ? [0.75 inches, ColumnClass.Expand] : [ColumnClass.Expand]) {
    foreach (var e in examples) {
      var found = e.FindAlignment(Run);
      if (found is valid) {
        var ap = new AlignPairClass(Data, found);
        Row {
          if (label) {
            Cell(PadR(10 pts)) {
              VAlign: VAligns.Center;
              e.Concept;
              e.Cognate Italic;
            };
          }
          ap.ShowFigureDetails(Data, e.Count);
        };
      }
      else
        System.Assert(false, "Concept {0} not found"(e.Concept));
    }
  };
}

//======================================================================

class TransitionClass {
  var             MaxRate,
                  MaxFrequency;
  var MatrixClass Rates;
  var RuleClass   Rule;

  Constructor(RunResultsClass run, RuleClass rule) {
    Rule = rule;
    var stats = run.TransitionStats;
    var count = stats.Length;
    Rates = new(count, count, null);

    var max = 0.0;
    for (int i = 0; i < count; ++i) {
      for (int j = 0; j < count; ++j) {
        var c = stats[i, j];
        var f = c?.Upper ?? 0.0;
        if (f > max)
          max = f;
        Rates.SetValue(i, j, c);
      }
    }
    MaxRate      = max;
    MaxFrequency = 1.0;
  }
}

//======================================================================

class RateClass: ActionClass {
  var AlignedCountClass Count;
  var DataSetClass      Data;
  var SegPartClass      S0,
                        S1;
  var SegmentFeatures   F0,
                        F1;
  var                   Original,
                        Rate,
                        Reverse,
                        Direction;
  var bool              Diagonal,
                        Symmetric;

  Constructor(DataSetClass data, AlignedCountClass count, SegPartClass s0, SegPartClass s1, rate, reverse, bool symmetric, bool diagonal) {
    super.Constructor(Actions.ToDocument, null, guid.FromHash("Rate"+s0.Ipa + s1.Ipa));

    Data      = data;
    Count     = count;
    S0        = s0;
    S1        = s1;
    F0        = s0.Features;
    F1        = s1.Features;
    Original  = rate;
    Rate      = GetLogRate(rate);
    Reverse   = GetLogRate(reverse);
    Direction = Rate - Reverse;
    Symmetric = symmetric;
    Diagonal  = diagonal;
  }

  static int CompareRate(RateClass a0, RateClass a1) = a0.Rate.Compare(a1.Rate);

  static int CompareDirection(RateClass a0, RateClass a1) = a0.Direction.Compare(a1.Direction);

  static bool SortDescending = true;

  static GetLogRate(r) {
    if (r < 0)
      return Math.Min(0, -11 - Math.Log(-r, 10));
    else if (r > 0)
      return Math.Max(0, 11 + Math.Log(r, 10));
    return 0;
  }

  bool IsPair(ipa0, ipa1) {
    return S0.Segment.Ipa == ipa0 and S1.Segment.Ipa == ipa1;
  }

  ColorClass RateColor {
    return PaperStyle.HeatMap.InterpolateColor(Rate * (Diagonal ? Count.DiagFactor : Count.RateFactor));
  }

  ColorClass DirectionColor {
    return PaperStyle.HeatMap.InterpolateColor(1.0 - 0.5 * Direction * Count.DirFactor);
  }

  ShowPartition(SegPartClass s, textheight) = Canvas(textheight * 2.5) {
    BorderRadius: PaperStyle.BorderSize;
    HAlign: HAligns.Center;
    Background: s.Partition.Color;
    TextColor: s.Partition.TextColor;
    s.ShowSegment;
  };

  ShowBox(textheight) = HBox {
    TextHeight: textheight;
    Separation: textheight * 0.25;
    VAlign: VAligns.Center;
    Tip: this;

    ShowPartition(S0, textheight);
    Span {
      TipAction: this;
      Symmetric ? Tex.leftrightarrow : Tex.rightarrow;
    };
    ShowPartition(S1, textheight);
  };

  override GetLayoutSpan = ShowBox(11 pts);

  private ShowNumber(name, number) = Paragraph {
    name;
    ": ";
    Span {
      TextDigits: 5;
      number;
    };
  };

  GetExamples(int max) = Block {
    TextHeight: 14 pts;
    GetLayoutSpan;
    Paragraph {
      "Value: ";
      TextScientific: true;
      TextDigits: 2;
      Original;
    };

    ShowNumber(RateDescriptor(Lang.RateFactor), Rate);
    if (!Symmetric) {
      ShowNumber(RateDescriptor("Reverse Factor"), Reverse);
      Span {
        var c = DirectionColor;
        TextBackground: c;
        TextColor: c.TextCompliment;
        ShowNumber(RateDescriptor("Direction"), Direction);
      }
    }

    var sorted = GetList(MainResults.MainRun);
    max = Math.Min(sorted.Length, max);
    if (sorted is valid) {
      Paragraph {
        SpaceBefore: 6 pts;
        "Examples:";
      };

      Paragraph {
        Separator: Space;
        for (var i = 0; i < max; ++i) {
          var s = sorted[i];
          new AlignPairClass(Data, s.Congate).ShowFigureData(s.Congate, s.Data);
        }
      };
    }
  };

  override GetLayoutTip = GetExamples(10);

  override GetDocument = GetExamples(100);

  static int CompareProb(AlignSortClass s1, AlignSortClass s2) = s1.Data.Prob.Compare(s2.Data.Prob);

  ListClass<AlignSortClass> GetList(RunResultsClass run) {
    // Find cognate sets that have the first segment in one language and the second in another language

    var i0   = S0.Index;
    var i1   = S1.Index;
    var list = new ListClass<AlignSortClass>(1024);

    foreach (var cognate in run.Alignments) {
      AlignDataClass found = null;

      foreach (var alignment in cognate.Alignments) {
        foreach (var w1 in alignment.WordSet) {
          foreach (var seg in w1) {
            if (seg == i0) {
              var ni = each0;
              foreach (var w2 in alignment.WordSet) {
                if (w2[ni] == i1) {
                  found = alignment;
                  break;
                }
              }
            }
            if (found is valid)
              break;
          }
          if (found is valid)
            break;
        }
        if (found is valid)
          break;
      }

      if (found is valid)
        list.Add(new(found, cognate));
    }
    list.Sort(true, @CompareProb);
    return list;
  }
}

//======================================================================

class SegDataClass {
  var RateClass Rate;
  var double    Value;

  Constructor(RateClass rate) {
    Rate  = rate;
    Value = -rate.Original;
  }

  override GetLayoutTip = VBox(PaperStyle.SegmentWidth) {
    HAlign: HAligns.Center;

    Span {
      TextBackground: Rate.S0.Partition.Color;
      Rate.S0.Partition.Name;
    };
    Span {
      "Value"; ColonSpace;
      Value;
    };
    if (not Rate.Diagonal) {
      Span {
        Lang.RateFactor; ColonSpace;
        TextDigits: 2;
        Rate.Rate;
      };
    }

    Rate.S0.GetLayoutTip;
  };
}

//======================================================================

class AlignedCountClass: CountBaseClass {
  delegate bool FindRateDelegate(RateClass r);

  var ListClass<RateClass>   RateList;
  var MatrixClass<RateClass> Matrix;
  var RuleClass              Rule;
  var PartitionClass[]       Partitions;
  var RateClass[]            SortedRates,
                             SortByDirection;
  var double                 DiagFactor,
                             RateFactor,
                             DirFactor;
  var bool                   Symmetric;

  Constructor(DataSetClass data, rates, bool symmetric) {
    super.Constructor(data);
    Symmetric  = symmetric;
    Rule       = data.Rule;
    Partitions = Rule.Partitions;

    var matrix  = MatrixClass.Convert(rates);
    var ordered = data.UniqueSegments;
    var length  = LegendSegments.Length;

    System.Assert(length == matrix.Rows);
    System.Assert(length == matrix.Cols);
    System.Assert(length == ordered.Length);

    Matrix   = new(length, length, null);
    RateList = new(length * length);

    double min  = 100.0;
    double max  = -100.0;
    double dmin = 100.0;
    double dmax = -100.0;

    for (var i = 0; i < length; ++i) {
//      var jmax = symmetric ? i : length;
      for (var j = 0; j < length; ++j) {
        var r = new RateClass(data, this, ordered[i], ordered[j], matrix[i, j], matrix[j, i], symmetric, i == j);
        Matrix.SetValue(i, j, r);
        if (i == j) {
          dmax = Math.Max(dmax, r.Rate);
          dmin = Math.Min(dmin, r.Rate);
        }
        else {
          RateList.Add(r);
          max = Math.Max(max, r.Rate);
          min = Math.Min(min, r.Rate);
        }
      }
    }

    DiagFactor      = 1.0 / Math.Abs(Math.Max(dmin, dmax));
    RateFactor      = 1.0 / Math.Abs(Math.Max(min, max));
    DirFactor       = max == min ? 1.0 : 1.0 / Math.Abs(max - min);
    var rl = RateList.ToArray;
    SortedRates     = rl.ToSortedArray(RateClass.SortDescending, @RateClass.CompareRate);
    SortByDirection = rl.ToSortedArray(RateClass.SortDescending, @RateClass.CompareDirection);
  }

  override AddEntry(SegPartClass si, SegPartClass sj, x, y, SizeClass size) {
    if (si.Index == sj.Index)
      return null;

    var rate = Matrix[si.Index, sj.Index];
    if (rate is not null) {
      return Canvas(size.Width, size.Height) {
        X: x;
        Y: y;
        HAlign: HAligns.Center;
        VAlign: VAligns.Center;
        TipNoPublish: true;
        TipAction: rate;
        var c = rate.RateColor;
        Span {
          TextDigits: 0;
          TextHeight: 5 pts;
          TextColor: c.TextCompliment;
          rate.Rate;
        };
        Background: c;
      };
    }
    return null;
  }

  ShowLegend(RateClass[] rates) {
    // Show only partitions that are present in the chart
    var pmax = Partitions.Length;
    var set  = new HashSetClass<PartitionClass>(pmax);
    foreach (var s in rates) {
      set.Add(s.S0.Partition);
      set.Add(s.S1.Partition);
    }

    return Canvas(ExtentWidth) {
      HAlign: HAligns.Center;
      Rule.ShowBlockLegend(set.ToArray, 11 pts);
    }
  }

  ShowChart(RateClass[] rates) = Chart(100%, 4 inches) {
    Type: ChartTypes.Column;
    TextHeight: 12 pts;
    ValueLabel: PaperStyle.ValueLabel {
      Lang.RateFactor;
    };

    var fs = Math.Min(160.0 / rates.Length, 10 pts);
    XAxis: ChartAxis {
      Rotation: 30 degrees;
      (each rates).ShowBox(fs);
    };

    ChartSeries(Colors.Green) {
      Label: Tex.rightarrow;
      foreach (var a in rates)
        new DataPointClass(each0, a.Rate) {Reference: a};
    };
  };

  Extrema(number, top) = VBox {
    var actions = SortedRates.Slice(top ? 0..<number : (SortedRates.Length - number)..<SortedRates.Length);
    ShowChart(actions);
    Separation: 20 pts;
    ShowLegend(actions);
  };

  ShowAllRates = VBox {
    Chart(100%, ExtentHeight - 48 pts) {
      Type: ChartTypes.Scatter;
      TextHeight: 12 pts;
      TipNoPublish: true;

      ValueLabel: PaperStyle.ValueLabel {
        RateDescriptor(Lang.RateFactor);
      };

      XAxis: ChartAxis {
        Rotation: 90 degrees;
        TextHeight: 7 pts;
        foreach (var sa in LegendSegments) {
          var p = Partitions[sa.PartitionIndex];
          HBox(15 pts) {
            HAlign: HAligns.Center;
            Background: p.Color;
            TextColor: p.TextColor;
            sa.Segment.Ipa;
          }
        }
      };

      ChartSeries {
        Marker: Markers.Dot;

        foreach (var si in LegendSegments) {
          var i = each0;

          foreach (var sj in LegendSegments) {
            if (si.Index != sj.Index) {
              var a = Matrix[si.Index, sj.Index];
              if (a is not null) {
                new DataPointClass(i, a.Rate) {
                  Reference: a;
                  Fill: a.S1.Partition.Color;
                };
              }
            }
          }
        }
      };
    };

    Separation: 20 pts;
    Canvas(ExtentWidth) {
      HAlign: HAligns.Center;
      Rule.ShowBlockLegend(Partitions, 10 pts);
    }
  };

  ShowRateDirected = VBox {
    Chart(100%, ExtentHeight - 48 pts) {
      TipNoPublish: true;
      Type: ChartTypes.Scatter;
      TextHeight: 12 pts;

      XLabel: RateDescriptor(Lang.RateFactor);

      ValueLabel: PaperStyle.ValueLabel {
        RateDescriptor("Direction");
      };

      ChartSeries {
        TextHeight: 6 pts;
        Marker: Markers.Dot;
        foreach (var si in LegendSegments) {
          foreach (var sj in LegendSegments) {
            if (si.Index < sj.Index) {
              var a = Matrix[si.Index, sj.Index];
              new DataPointClass(a.Rate, a.Direction) {
                Reference: a;
                Marker: Canvas(4 pts, 4 pts) {
                  HAlign: HAligns.Center;
                  VAlign: VAligns.Center;
                  Background: a.S0.Partition.Color;
                  BorderRadius: 2 pts;
                  a.S1.Partition.Marker;
                };
              };
            }
          }
        }
      };
    };

    Separation: 20 pts;
    Canvas(ExtentWidth) {
      HAlign: HAligns.Center;
      Rule.ShowBlockLegend(Partitions, 10 pts);
    }
  };

  ShowDirection = VBox {
    Chart(100%, ExtentHeight - 48 pts) {
      TipNoPublish: true;
      Type: ChartTypes.Scatter;
      TextHeight: 12 pts;

      XLabel: "Transitions";

      ValueLabel: PaperStyle.ValueLabel {
        RateDescriptor("Direction");
      };

      var group   = Markers.TriangleUp(Colors.Green) {TextHeight: 8 pts};
      var special = Markers.Square(Colors.Red) {TextHeight: 10 pts};
      ChartSeries {
        TextHeight: 6 pts;
        Marker: Markers.Dot;
        foreach (var a in SortByDirection) {
          new DataPointClass(each0, a.Direction) {
            Reference: a;
            if (a.S0.Segment.Ipa == "p")
              Marker: a.S1.Segment.Ipa == "b" or a.S1.Segment.Ipa == "f" ? special : group;
            else
              Marker: a.S0.Partition.Marker;
          }
        }
      };
    };

    Separation: 20 pts;
    Canvas(ExtentWidth) {
      HAlign: HAligns.Center;
      Rule.ShowBlockLegend(Partitions, 10 pts);
    }
  };

  ShowChartPairs(top, RateClass[] rates) = VBox {
    var subset = top < 0 ? rates : rates.Slice(0..<top);

    ShowChart(subset) {
      Type: ChartTypes.StackedColumn;

      Legend: ChartLegend {
        Direction: Directions.Vertical;
        Placement: Placements.Right;
      };
      ChartSeries(Colors.Red) {
        Label: Tex.leftarrow;
        foreach (var a in subset)
          new DataPointClass(each0, a.Reverse);
      };
    };
    Separation: 20 pts;
    ShowLegend(subset);
  };

  Pairs(top, FindRateDelegate predicate) = ShowChartPairs(top, SortedRates.FindSlice(predicate));
}

//======================================================================

class CalcRatesClass {
  var DataSetClass    Data;
  var TransitionClass Transition;
  var RuleClass       Rule;
  var RunResultsClass Run;
  var                 MaxLine,
                      ArrowGap,
                      GapAngle,
                      LoopRadius,
                      LoopDistance,
                      MaxExtent,
                      MaxRadius,
                      RateScale;

  Constructor(DataSetClass data, RunResultsClass run) {
    Run        = run;
    Data       = data;
    Rule       = Data.Rule;
    ArrowGap   = 8 pts;
    GapAngle   = 80.0 degrees;
    Transition = new TransitionClass(run, Rule);
  }

  void Calibrate(SizeClass size) {
    var middle = new PointClass(size.Width * 0.5, size.Height * 0.5);

    MaxExtent    = Math.Min(middle.X, middle.Y);
    MaxRadius    = MaxExtent * 0.2;
    MaxLine      = MaxRadius * 0.3;
    LoopRadius   = MaxRadius * 0.25;
    LoopDistance = LoopRadius * 0.5;


    var fmax = MaxRadius / Math.Sqrt(Transition.MaxFrequency); // Proportional to area, so use SQRT of frequency

    RateScale = MaxLine / Transition.MaxRate;

    var mult = Math.PI2 / Rule.Partitions.Length;
    var eq   = Run.EquilibriumFrequencies;

    foreach (var partition in Rule.Partitions) {
      partition.Angle  = mult * each0 - Graphics.Ninety;
      partition.Radius = Math.Sqrt(eq[each0]) * fmax;
    }

    var maxradius = 0.0;
    foreach (var partition in Rule.Partitions)
      maxradius = Math.Max(maxradius, partition.Radius + Transition.Rates[each0, each0].Upper * RateScale);
    maxradius = MaxExtent - maxradius - LoopRadius - LoopDistance - ArrowGap;

    foreach (var partition in Rule.Partitions)
      partition.Center = Graphics.ExtendPoint(middle, maxradius, partition.Angle);
  }

  private MainDiagram(min) = Canvas(min, min) {
    TransformFit: true;
    PaperStyle.SansSerif;

    Calibrate(new(min));

    foreach (var p1 in Rule.Partitions) {
      var i = each0;

      foreach (var p2 in Rule.Partitions) {
        var rate = Transition.Rates[each0, i];
        if (rate is valid) {
          var  hover = new PartitionActionClass(Rule, rate, p1, p2);

          if (p1 == p2) {
            var line2 = new LineStyleClass(rate.Mean * RateScale, 0.25, 1);
            var c     = Graphics.ExtendPoint(p1.Center, p1.Radius + LoopDistance - line2.LineSize*0.5, p1.Angle);
            Graphics.CircleLine(line2, c, LoopRadius + line2.LineSize, p1.Angle + Graphics.OneEighty, GapAngle) {
              TipAction: hover;
            };
          }
          else if (each0 < i) {
            var angle = Graphics.GetAngle(p1.Center, p2.Center);
            var c1    = Graphics.Adjust(p1.Center, p1.Radius + ArrowGap, angle + Graphics.OneEighty);
            var c2    = Graphics.Adjust(p2.Center, p2.Radius + ArrowGap, angle);

            Graphics.Line(new(rate.Mean * RateScale, 0.25, 1), c1, c2) {
              TipAction: hover;
            }
          }
        }
      }
    }

    foreach (var p1 in Rule.Partitions) {
      var pos        = p1.Center - p1.Radius;
      var fsize      = p1.Radius*2;
      var textheight = Math.Min(14 pts, fsize * 0.5);

      Shape(p1.Color, 0.5 pt) {
        EllipsePath(new(pos, new(fsize)));
        TipAction: p1;
      };

      Canvas(fsize, fsize) {
        X: pos.X;
        Y: pos.Y;
        HAlign: HAligns.Center;
        VAlign: VAligns.Center;
        Span {
          TextHeight: textheight;
          TextColor: p1.Color.TextCompliment;
          p1.Index+1;
        };
      };
    }
  };


  PartitionDiagram(ContentStyleClass style) = HBox {
    VAlign: VAligns.Center;

    var legend = 1.5 inches;
    Rule.ShowLegend(style, 10 pts, legend, 0);
    MainDiagram(Math.Min(ExtentWidth - legend, ExtentHeight));
  };

  TranLink(i0, i1) = "Tran{0}:{1}"(i0, i1);
}

//======================================================================

class DiagonalClass {
  var ListClass<SegDataClass> Diagonal;
  var RuleClass               Rule;

  Constructor(RuleClass rule, AlignedCountClass rates) {
    Rule = rule;
    var m      = rates.Matrix;
    var length = m.Cols;

    Diagonal = new(length);
    for (int i = 0; i < length; ++i) {
      var r = m[i, i];
      if (r is not null)
        Diagonal.Add(new(r));
    }
    Diagonal.Sort(true, @CompareData);
  }

  static int CompareData(SegDataClass d0, SegDataClass d1) = d0.Value.Compare(d1.Value);

  PartitionClass[] OrderPartitions {
    var partitions = new HashSetClass<PartitionClass>(Rule.Partitions.Length);
    foreach (var d in Diagonal)
      partitions.Add(d.Rate.S0.Partition);
    return partitions.ToArray;
  }

  Display(ContentStyleClass style) = VBox {
    HAlign: HAligns.Center;
    style.SansSerif;

    Chart(100%, 2 inches) {
      TextHeight: 11 pts;
      Type: ChartTypes.Column;

      ValueLabel: PaperStyle.ValueLabel {
        Span {Lang.Rate};
      };

      XAxis: ChartAxis {
        TextHeight: PaperStyle.SegmentTextFactor * ExtentWidth / Diagonal.Length ;
        foreach (var d in Diagonal)
          d.Rate.S0.ShowSegment;
      };

      ValueAxis: ChartAxis;
      ChartSeries {
        foreach (var d in Diagonal) {
          new DataPointClass(each0, d.Value) {
            Reference: d;
            Fill: d.Rate.S0.Partition.Color;
          };
        }
      };
    };

    Rule.ShowBlockLegend(OrderPartitions, 7 pts);
  };
}

//======================================================================

class PartitionActionClass: ActionClass {
  var StatClass      Rate;
  var PartitionClass P1,
                     P2;

  Constructor(RuleClass rule, StatClass rate, PartitionClass p1, PartitionClass p2) {
    super.Constructor(Actions.ToSource, rule);
    Rate = rate;
    P1   = p1;
    P2   = p2;
  }

  AddGroup(PartitionClass p) = VBox {
    HAlign: HAligns.Center;
    HBox {
      TextBackground: 90%;
      Span {
        p.Name;
      };
    };
    HBox {
      p.ShowFilterSegments(ParAlignments.Center);
    };
  };

  override GetLayoutTip = HBox {
    VAlign: VAligns.Top;
    AddGroup(P1);
    var t = PadLR(5);
    HBox(null, null, t) {
      Margin: t;
      VBox {
        HAlign: HAligns.Center;
        Span {Lang.Rate; "%"};
        Rate.ShowBox;
      };
    };
    AddGroup(P2);
  };
}

//======================================================================

class AlignSortClass {
  var AlignDataClass  Data;
  var AlignIndexClass Congate;

  Constructor(AlignDataClass data, AlignIndexClass cognate) {
    Data    = data;
    Congate = cognate;
  }
}

//======================================================================
