using Format, Units, Math, IO, DB;
//======================================================================

class RevProgramClass {
  var CommentChar,
      CommentSpace;

  Constructor {
    CommentChar  = "#";
    CommentSpace = "  ";
  }

  CommentBlock = TextBlock {
    Empty;
    TextColor: Style.CommentColor;
  };

  BlockComment(text) = CommentBlock {
    var bar = CommentChar * (text.Length + (1 + CommentSpace.Length)*2);
    bar;
    Span {
      CommentChar CommentSpace;
      text;
      CommentSpace CommentChar;
    };
    bar;
  };

  LineComment(text) = CommentBlock {
    CommentChar Space text;
  };

  ShowString(text) = Span {
    TextColor: Style.StringColor;
    "\"";
    text;
    "\"";
  };

  PathPlus(name) = Span {
    "path+";
    ShowString(name);
  };
}
//======================================================================

class RevProcessClass: ProcessClass {
  Constructor(exe, args) {
    super.Constructor(exe, args);
  }

  override void OutputLine(line) {
    System.WriteLine(line);
    var l = FindSlice(line[..5], c => c >= '0' and c <= '9');
    if (l.Length > 1) {
      var i = Integer(l);
      if (not i.IsError())
        System.ProgressPercent(i, Info.Generations);
    }
    else if (line.IndexOf("Error:") >= 0)
      System.ProgressCancel(line);
  }
}
//======================================================================

class ComputeClass: RevProgramClass {
  var OutFolder,
      EXEName,
      RevSourceName,
      GammaTrees,
      GammaLog,
      GammaMAP,
      GammaMCC,
      GammaConsensus,
      OptionsName,
      CharacterName;

  Constructor(outname) {
    super.Constructor;

    OutFolder       = Folders.Repository Folder("Run") Folder(outname);
    EXEName         = Folders.Repository Folder("RevBayes") FileName("rb") Extensions.EXE;
    RevSourceName   = FileName("Program") Extensions.RevBayes;
    CharacterName   = FileName("Characters") Extensions.Nexus;
    OptionsName     = FileName("Options") Extensions.Nytril;
    GammaTrees      = FileName("Gamma.trees");
    GammaLog        = FileName("Gamma.log");
    GammaMAP        = FileName("Gamma_MAP") Extensions.Tree;
    GammaMCC        = FileName("Gamma_MCC") Extensions.Tree;
    GammaConsensus  = FileName("Gamma_Consensus") Extensions.Tree;
  }

  void Calculate {
    var inputfolder = OutFolder Folder("Input");

    CreateFolder(OutFolder);
    CreateFolder(inputfolder);
    IO.Write(GetOptionsSource, OutFolder OptionsName);
    IO.Write(Nexus.CharacterFile(1), OutFolder CharacterName);

    IO.Write(TransitionRuleFile, OutFolder FileName("Parameters.txt"));
    foreach (var cognate in Results.UsedCognates)
      IO.Write(Nexus.TKFFile(cognate, 0), inputfolder FileName(cognate.Name) Extension("in"), FileFormats.Text);

    IO.Write(RevBayesSource, OutFolder RevSourceName);


    var p = new RevProcessClass(EXEName, OutFolder RevSourceName) {
/*      CacheName: "RevBayes";
      CacheInput: [
        OutFolder CharacterName,
        OutFolder RevSourceName,
      ];
      CacheOutput: [
        OutFolder GammaTrees,
        OutFolder GammaConsensus,
        OutFolder GammaMAP,
        OutFolder GammaMCC,
        OutFolder GammaLog,
      ];
*/
      Directory: OutFolder;
    };

    var results = p.Run;
    if (results.ExitCode != 0)
      System.Assert(false, results.StandardOutput, p);
  }

  ShowLanguageTrees = Block {
    Style.ShowTree("Priors", Lang.Years, Info.PriorTree);
    Style.ReadTree("Consensus", OutFolder GammaConsensus);
    Style.ReadTree("MAP", OutFolder GammaMAP);
    Style.ReadTree(Lang.MCC, OutFolder GammaMCC);

    var schema = new LogSchemaClass();
    var view   = schema.ReadTextFile(OutFolder GammaLog, true, ValueTypes.Double);
    schema.GetHistogram(view, "alpha");

    schema.LineChart(view, "Prior");
    schema.LineChart(view, "Likelihood");
    schema.LineChart(view, "Posterior");
    schema.LineChart(view, "Tree Length", "TL");

//    schema.LineChart(view, null, each "bl[{0}]"(each 1..Concepts*2));
//    schema.LineChart(view, null, each "site_rates[{0}]"(each 1..Concepts));
  };

  AddVariable(name, value) = Span {
    name;
    " = ";
    value;
    ";";
  };

  GetOptionsSource = TextBlock {
    Style.MonoFamily;
    Span {
      TextColor: Style.CommentColor;
      "// Run options";
    };
    Empty;

    AddVariable("Generations", Info.Generations);
    AddVariable("Languages", Results.TaxaArray.Length);
    AddVariable("Concepts", Results.UsedCognates.Length);
    AddVariable("Segments", Results.UniqueSegments.Length);
  };

  TransitionRuleFile = TextBlock {
    Style.MonoFamily;
    "Num_Symbols:{0}"(Results.DisplaySegments.Length);
    (each Rules).ShowFile;
  };

  ShowTransitionRules = Block {
    (each Rules).ShowDescription;
  };

  RevBayesSource = TextBlock {
//    System.Assert(Results.UniqueSegments.Length <= Nexus.CharacterList.Length, "Too many segments");

    Style.MonoFamily;
    BlockComment("RevBayes Source File for Linguistomics Project");

    "clear()";
//    "setwd({0})"(ShowString(folder));
    "path = " ShowString(OutFolder Folder("/"));
    "gammapath = {0}"(PathPlus(GammaTrees));


    LineComment("Read in discrete character data");
    "data = readDiscreteCharacterData({0})"(PathPlus(CharacterName));

    LineComment("Get some useful variables from the data. We need these later on");
    "num_taxa <- data.ntaxa()";

    LineComment("Number of branches in an rooted tree");
    "num_branches <- 2 * num_taxa - 2";

    "taxa <- data.taxa()";

    LineComment("Create helper variables");
    "moves    = VectorMoves()";
    "monitors = VectorMonitors()";

    BlockComment("Substitution Model");
    LineComment("Create a rate matrix using {0} unique segments"(Results.DisplaySegments.Length));
    "Q <- fnJC({0})"(Results.UniqueSegments.Length);

    BlockComment("Tree Model");

    LineComment("Outgroup is a clade consisting of one language");
    "out_group = clade({0})"(ShowString(Languages.Latin));

    LineComment("Prior distribution on the tree topology");
    "topology ~ dnUniformTopology(taxa, outgroup=out_group, rooted=TRUE)";

    LineComment("These are moves that change the tree topology");

    "moves.append(mvNNI(topology, weight=num_taxa/2.0))";
    "moves.append(mvSPR(topology, weight=num_taxa/10.0))";

    LineComment("Branch length prior");

    "for (i in 1:num_branches) {";
    "  bl[i] ~ dnExponential(10.0)";
    "  moves.append(mvScale(bl[i]))";
    "}";

    "TL  := sum(bl)";
    "psi := treeAssembly(topology, bl)";

    BlockComment("Gamma model for among-site variation");

    "alpha ~ dnUniform(0, 10.0)";
    "moves.append(mvScale(alpha, weight=1))";

    "site_rates := fnDiscretizeGamma(alpha, alpha, 4)";

    BlockComment("PhyloCTMC Model");
    "seq ~ dnPhyloCTMC(tree=psi, Q=Q, type={0}, siteRates=site_rates)"(ShowString("Standard"));
    "seq.clamp(data)";

    BlockComment("Analysis");

    LineComment("You can use any node as the argument of model()");
    "mymodel = model(psi)";
    "n_gen   = {0}"(Math.Min([10, Info.Generations div 1000]));

    LineComment("This prints monitors to the screen");
    "monitors.append(mnScreen(TL, printgen=50) )";

    LineComment("This monitors the trees and puts them in a file");
    "monitors.append(mnFile(psi, filename=gammapath, printgen=n_gen))";

    LineComment("Model monitor");
    "monitors.append( mnModel(filename={0}, printgen=n_gen))"(PathPlus(GammaLog));

    "mymcmc = mcmc(mymodel, moves, monitors, nruns=1, combine={0})"(ShowString("mixed"));


//   "mymcmc.burnin(generations={0}, tuningInterval=200)"(Info.Generations);
    "mymcmc.run(generations={0})"(Info.Generations);

    LineComment("Summarizes the MCMC runs");
    "mymcmc.operatorSummary()";

    BlockComment("Post processing");
    "treetrace      = readTreeTrace(gammapath, outgroup=out_group)";
    "map_tree       = mapTree(treetrace, {0})"(PathPlus(GammaMAP));
    "mcc_tree       = mccTree(treetrace, {0})"(PathPlus(GammaMCC));
    "consensus_tree = consensusTree(treetrace, {0})"(PathPlus(GammaConsensus));

    LineComment("Exit the program");
    "q()";
  };
}
//======================================================================

class BinClass {
  var Variable,
      Value,
      Name;

  Constructor(variable, value, name) {
    Variable = variable;
    Value    = value;
    Name     = name;
  }
}
//======================================================================


class LogSchemaClass: SchemaClass {
  Constructor {
    super.Constructor("log");
  }

  GetFieldList(view, field) {
    var list = new ListClass(view.Length);
    foreach (var row in view)
      list.Add(row.FindValue(field));
    return list.ToArray();
  }

  ReadHistogramData(view, field) {
    var list = GetFieldList(view, field);
    var min  = Floor(Min(list));
    var max  = Ceiling(Max(list));
    var d    = 0.125;
    var bins = Round((max - min) / d);

    var data = new ListClass(bins);
    var x    = min;
    foreach (var i in 0..<bins) {
      var xd = x + d;
      data.Add(new BinClass(xd, FindCount(list, v => v >= x and v < xd), Span {x; TextDigits: 1}));
      x = xd;
    }
    return data.ToArray();
  }

  TitleBox(name) = Paragraph {
    HAlignment: HAligns.Center;
    TextHeight: 14 pts;
    name;
  };

  GetHistogram(view, field) = VBox {
    TitleBox(field " Histogram");
    Chart {
      Size: Size(DocMetrics.TreeWidth, 3.5 inches);
      Type: ChartTypes.Column;

      var data = ReadHistogramData(view, field);

      XAxis: ChartAxis {
//        Rotation: -60 degrees;
        (each data).Name;
      };
      ChartSeries {
        foreach (var d in data)
          new DataPointClass(EachIndex, d.Value) {Reference: d.Variable};
      };
    };
  };

  LineChart(view, name, field=null) = Paragraph {
    SpaceBefore: 20 pts;
    VBox {
      TitleBox(name ?? field);
      Chart {
        Size: Size(DocMetrics.TreeWidth, 2.5 inches);
        Type: ChartTypes.Line;

        var list = GetFieldList(view, field ?? name);

        XAxis: ChartAxis {
          each 0..<list.Length;
        };
        ChartSeries {
//          Marker: Tex.bullet {TextHeight: 3 pts; TextColor: Colors.Red};
          Stroke: 0.5 pts {MiterLimit: 2 pts};
          foreach (var l in list) {
            if (exists l)
              new DataPointClass(null, l);
          }
        };
      };
    };
  };
}
//======================================================================

