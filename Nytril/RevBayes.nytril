using Format, Units, Math, IO, DB;
//======================================================================

class RevSourceClass {
  var CommentChar,
      CommentSpace,
      CommaSpace,
      Quote;

  Constructor {
    CommentChar  = "#";
    CommentSpace = "  ";
    CommaSpace   = ", ";
    Quote        = "\"";
  }

  CommentBlock = TextBlock {
    Empty;
    TextColor: Style.CommentColor;
  };

  BlockComment(text) = CommentBlock {
    var bar = CommentChar * (text.Length + (1 + CommentSpace.Length)*2);
    bar;
    Span {
      CommentChar CommentSpace;
      text;
      CommentSpace CommentChar;
    };
    bar;
  };

  LineComment(text) = CommentBlock {
    CommentChar Space text;
  };

  ShowString(text) = Span {
    TextColor: Style.StringColor;
    Quote;
    text;
    Quote;
  };

  PathPlus(name) = Span {
    "path+";
    ShowString(name);
  };


  Variable(v) = Span {
    TextColor: Style.VariableColor;
    Quote; v; Quote; ": ";
  };
}
//======================================================================

class RevProcessClass: ProcessClass {
  Constructor(exe, args) {
    super.Constructor(exe, args);
  }

  override void OutputLine(line) {
    System.WriteLine(line);
    var l = FindSlice(line[..5], c => c >= '0' and c <= '9');
    if (l.Length > 1) {
      var i = Integer(l);
      if (not i.IsError())
        System.ProgressPercent(i, Info.Generations);
    }
    else if (line.IndexOf("Error:") >= 0)
      System.ProgressCancel(line);
  }
}
//======================================================================

enum Models {
  JC,
  MK,
}

class RevProgramClass: RevSourceClass {
  var OutFolder,
      EXEName,
      RevSourceName,
      GammaTrees,
      GammaLog,
      GammaMAP,
      GammaMCC,
      GammaConsensus,
      CharacterName,
      AddComma,
      Model;

  Constructor(model, folder) {
    super.Constructor;

    Model          = model;
    OutFolder      = Folders.Repository Folder("Run") Folder(folder);
    EXEName        = Folders.Repository Folder("RevBayes") FileName("rb") Extensions.EXE;
    RevSourceName  = FileName("Program") Extensions.RevBayes;
    CharacterName  = FileName("Characters") Extensions.Nexus;
    GammaTrees     = FileName("Gamma.trees");
    GammaLog       = FileName("Gamma.log");
    GammaMAP       = FileName("Gamma_MAP") Extensions.Tree;
    GammaMCC       = FileName("Gamma_MCC") Extensions.Tree;
    GammaConsensus = FileName("Gamma_Consensus") Extensions.Tree;
  }

  void Calculate {
    CreateFolder(OutFolder);
    IO.Write(Nexus.CharacterFile(1), OutFolder CharacterName);
    IO.Write(RevBayesSource, OutFolder RevSourceName);
    IO.Write(RunBatchFile, OutFolder FileName("Run") Extension("bat"), FileFormats.ANSI);
    IO.Write(ConfigFile, OutFolder FileName("config") Extensions.JSON, FileFormats.Text);


    var p = new RevProcessClass(EXEName, OutFolder RevSourceName) {
/*      CacheName: "RevBayes";
      CacheInput: [
        OutFolder CharacterName,
        OutFolder RevSourceName,
      ];
      CacheOutput: [
        OutFolder GammaTrees,
        OutFolder GammaConsensus,
        OutFolder GammaMAP,
        OutFolder GammaMCC,
        OutFolder GammaLog,
      ];
*/
      Directory: OutFolder;
    };

//    var results = p.Run;
//    if (results.ExitCode != 0)
//      System.Assert(false, results.StandardOutput, p);
  }

  ShowLanguageTrees = Block {
    Style.ShowTree("Priors", Lang.Years, Info.PriorTree);
    Style.ReadTree("Consensus", OutFolder GammaConsensus);
    Style.ReadTree("MAP", OutFolder GammaMAP);
    Style.ReadTree(Lang.MCC, OutFolder GammaMCC);
  };

  ShowStats = Block {
    var schema = new LogSchemaClass();
    var view   = schema.ReadTextFile(OutFolder GammaLog, true, ValueTypes.Double);
    schema.GetHistogram(view, "alpha");

    schema.LineChart(view, "Prior");
    schema.LineChart(view, "Likelihood");
    schema.LineChart(view, "Posterior");
    schema.LineChart(view, "Tree Length", "TL");

//    schema.LineChart(view, null, each "bl[{0}]"(each 1..Concepts*2));
//    schema.LineChart(view, null, each "site_rates[{0}]"(each 1..Concepts));
  };

  RunBatchFile = TextBlock {
    Span {
      "\"../../revbayes/rb.exe\" \"";
      OutFolder RevSourceName;
      "\"";
    }
  };

  AddTree = TextBlock {
    Span {
      Variable("Tree");
      Quote;
      Nexus.Newick(GetTreeNodes(LanguageBranches.Experiment));
      Quote; ",";
    };
  };

  ShowCharacter(c) = Span {
    Popup: c;
    c.Character;
  };

  AddScope = TextBlock {
    IndentSpace: 2;
    Begin: "{";
    End: "}";
  };

  AddWord(word) = Span {
    "  {";
    Variable("Taxon");
    ShowString(word.Language);
    CommaSpace;
    Variable("Segments");
    "[";
    Span {
      Separator: CommaSpace;
      ShowCharacter(each word.Aligned);
    };
    "]}";
  };

  AddCognate(cognate) = AddScope {
    Span {
      Variable("Name"); ShowString(cognate.Name); CommaSpace;
    };
    Span {
      Variable("Data"); "[";
    };

    TextBlock {
      Separator: ",";
      foreach (var word in each cognate.Words) {
        if (valid word.Aligned)
          AddWord(word);
      }
    };
    "]";
  };

  AddPartition = Span {
    Separator: ",";
    var total = Results.UniqueCharacters * (Results.UniqueCharacters-1) div 2;
    foreach (var i in 1..total)
      1;
  };

  ConfigFile = AddScope {
    Style.MonoFamily;
    TextHeight: 8 pts;

    AddTree;
    Span {
      Variable("NumberOfStates");
      Results.UniqueCharacters;
      CommaSpace;
    };

    Span {
      Variable("Partition"); "[";
      Span {
        AddPartition;
      };
      "],";
    };

    Span {
      Variable("Words"); "[";
    };
    TextBlock {
      Separator: ",";
      AddCognate(each Results.UsedCognates);
    };
    "]";
  };

  RevBayesSource = TextBlock {
    Style.MonoFamily;
    BlockComment("RevBayes Source File for Linguistomics Project");

    "clear()";
//    "setwd({0})"(ShowString(folder));
    "path = " ShowString(OutFolder Folder("/"));
    "gammapath = {0}"(PathPlus(GammaTrees));


    LineComment("Read in discrete character data");
    "data = readDiscreteCharacterData({0})"(PathPlus(CharacterName));

    LineComment("Get some useful variables from the data. We need these later on");
    "num_taxa <- data.ntaxa()";

    LineComment("Number of branches in an rooted tree");
    "num_branches <- 2 * num_taxa - 2";

    "taxa <- data.taxa()";

    LineComment("Create helper variables");
    "moves    = VectorMoves()";
    "monitors = VectorMonitors()";

    BlockComment("Tree Model");
    LineComment("Outgroup is a clade consisting of one language");
    "out_group = clade({0})"(ShowString(Languages.Latin));

    LineComment("Prior distribution on the tree topology");
    "topology ~ dnUniformTopology(taxa, outgroup=out_group, rooted=TRUE)";

    LineComment("These are moves that change the tree topology");
    "moves.append(mvNNI(topology, weight=num_taxa/2.0))";
    "moves.append(mvSPR(topology, weight=num_taxa/10.0))";

    LineComment("Branch length prior");

    "for (i in 1:num_branches) {";
    "  bl[i] ~ dnExponential(10.0)";
    "  moves.append(mvScale(bl[i]))";
    "}";
    Empty;
    "TL  := sum(bl)";
    Empty;
    "psi := treeAssembly(topology, bl)";
    Empty;

    BlockComment("Substitution Model");
    LineComment("This is the number of unique characters from the segment filters");
    "unique_chars = {0}"(Results.UniqueCharacters);

    switch (Model) {
      case Models.JC:
        LineComment("Jukes-Cantor model");
        "Q <- fnJC(unique_chars)";
        break;

      case Models.MK:
        LineComment("Mk model");
        LineComment("I'm guessing completely with this number");
        "rate_pr <- 10.0";
        Empty;
        "rate_parameter ~ dnExponential(rate_pr)";
        Empty;
        Empty;
        "moves.append(mvScale(rate_parameter, weight=2))";
        Empty;
        "for (i in 1:unique_chars) {";
        "  for (j in 1:unique_chars) {";
        "    m[i][j] := rate_parameter";
        "  }";
        "}";
        Empty;
        "Q := fnFreeK(m, rescale=TRUE)";
        break;
    }

    BlockComment("Gamma model for among-site variation");

    "alpha ~ dnUniform(0, 10.0)";
    "moves.append(mvScale(alpha, weight=1))";

    "site_rates := fnDiscretizeGamma(alpha, alpha, 4)";

    BlockComment("PhyloCTMC Model");
    "seq ~ dnPhyloCTMC(tree=psi, Q=Q, type={0}, siteRates=site_rates)"(ShowString("Standard"));
    "seq.clamp(data)";

    BlockComment("Analysis");

    LineComment("You can use any node as the argument of model()");
    "mymodel = model(psi)";
    "n_gen   = {0}"(Math.Min([100, Math.Max([10, Info.Generations div 1000])]));

    LineComment("This prints monitors to the screen");
    Span {
      "monitors.append(mnScreen(TL, ";
      if (Model == Models.MK)
        "rate_parameter, ";
      "printgen=n_gen))";
    };

    LineComment("This monitors the trees and puts them in a file");
    "monitors.append(mnFile(psi, filename=gammapath, printgen=n_gen))";

    LineComment("Model monitor");
    "monitors.append(mnModel(filename={0}, printgen=n_gen))"(PathPlus(GammaLog));

    "mymcmc = mcmc(mymodel, moves, monitors, nruns=1, combine={0})"(ShowString("mixed"));


//   "mymcmc.burnin(generations={0}, tuningInterval=200)"(Info.Generations);
    "mymcmc.run(generations={0})"(Info.Generations);

    LineComment("Summarizes the MCMC runs");
    "mymcmc.operatorSummary()";

    BlockComment("Post processing");
    "treetrace      = readTreeTrace(gammapath, outgroup=out_group)";
    "map_tree       = mapTree(treetrace, {0})"(PathPlus(GammaMAP));
    "mcc_tree       = mccTree(treetrace, {0})"(PathPlus(GammaMCC));
    "consensus_tree = consensusTree(treetrace, {0})"(PathPlus(GammaConsensus));

    LineComment("Exit the program");
    "q()";
  };
}
//======================================================================

class BinClass {
  var Variable,
      Value,
      Name;

  Constructor(variable, value, name) {
    Variable = variable;
    Value    = value;
    Name     = name;
  }
}
//======================================================================


class LogSchemaClass: SchemaClass {
  Constructor {
    super.Constructor("log");
  }

  GetFieldList(view, field) {
    var list = new ListClass(view.Length);
    foreach (var row in view)
      list.Add(row.FindValue(field));
    return list.ToArray();
  }

  ReadHistogramData(view, field) {
    var list = GetFieldList(view, field);
    var min  = Floor(Min(list));
    var max  = Ceiling(Max(list));
    var d    = 0.125;
    var bins = Round((max - min) / d);

    var data = new ListClass(bins);
    var x    = min;
    foreach (var i in 0..<bins) {
      var xd = x + d;
      data.Add(new BinClass(xd, FindCount(list, v => v >= x and v < xd), Span {x; TextDigits: 1}));
      x = xd;
    }
    return data.ToArray();
  }

  TitleBox(name) = Paragraph {
    HAlignment: HAligns.Center;
    TextHeight: 14 pts;
    name;
  };

  GetHistogram(view, field) = VBox {
    TitleBox(field " Histogram");
    Chart {
      Size: Size(DocMetrics.TreeWidth, 3.5 inches);
      Type: ChartTypes.Column;

      var data = ReadHistogramData(view, field);

      XAxis: ChartAxis {
//        Rotation: -60 degrees;
        (each data).Name;
      };
      ChartSeries {
        foreach (var d in data)
          new DataPointClass(EachIndex, d.Value) {Reference: d.Variable};
      };
    };
  };

  LineChart(view, name, field=null) = Paragraph {
    SpaceBefore: 20 pts;
    VBox {
      TitleBox(name ?? field);
      Chart {
        Size: Size(DocMetrics.TreeWidth, 2.5 inches);
        Type: ChartTypes.Line;

        var list = GetFieldList(view, field ?? name);

        XAxis: ChartAxis {
          each 0..<list.Length;
        };
        ChartSeries {
//          Marker: Tex.bullet {TextHeight: 3 pts; TextColor: Colors.Red};
          Stroke: 0.5 pts {MiterLimit: 2 pts};
          foreach (var l in list) {
            if (exists l)
              new DataPointClass(null, l);
          }
        };
      };
    };
  };
}
//======================================================================

