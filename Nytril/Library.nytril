using Format, Units, Math, IO, LinkTypes;

//======================================================================

class AlignDataClass {
  var Prob,
      WordSet;

  Constructor(prob, wordset) {
    Prob    = prob;
    WordSet = wordset;
  }
}

//======================================================================

class AlignIndexClass {
  var              ConceptName,
                   CognateName;
  CognateClass     Cognate;
  AlignDataClass[] Alignments;

  Constructor(concept, cognate, AlignDataClass[] alignments) {
    ConceptName = concept;
    CognateName = cognate;
    Alignments  = alignments;
  }
}

//======================================================================

class StatClass {
  var Lower,
      Mean,
      Upper;

  Constructor(lower, mean, upper) {
    Lower = lower;
    Mean  = mean;
    Upper = upper;
  }

  ShowRight(number) = HBox {
    Space*2;
    TextHeight: 80%;
    TextColor: Colors.Gray;
    number;
  };

  ShowBox = VBox {
    Brackets: Brackets.Curly;
    TextDigits: 3;
    ShowRight(Upper * 100.0);
    Mean * 100.0;
    ShowRight(Lower * 100.0);
  };

  override GetLayoutTip = ShowBox;
}

//======================================================================

class AlignPairClass {
  DataSetClass    Data;
  AlignIndexClass Cognate;
  SizeClass       BoxSize;
  var             Name;

  Constructor(DataSetClass data, AlignIndexClass cognate) {
    Data    = data;
    Cognate = cognate;
    BoxSize = new SizeClass(14 pts, 14 pts);
    Name    = cognate.ConceptName;
    if (cognate.CognateName != DefaultCognate)
      Name += "-" + cognate.CognateName;
  }

  Languages(data, height) = VBox {
    HAlign: HAligns.Right;
    HBox(null, height);

    foreach (var taxon in data.Taxa) {
      HBox(null, height) {
        VAlign: VAligns.Center;
        taxon.Language;
      };
    }
  };

  Show(prob, cumulative, wordset, boxheight) = VBox {
    Margin: PadB(10 pts);
    Border: 0.125 {Color: 50%};
    HAlign: HAligns.Center;

    HBox(null, boxheight) {
      TextDigits: 1;
      prob * 100.0;
      "%";
    };

    VBox {
      foreach (var taxon in Data.Taxa) {
        HBox(null, boxheight) {
          var word = wordset[each0];
          if (valid word) {
            foreach (var c in word) {
              Canvas(BoxSize.Width, BoxSize.Height) {
                HAlign: HAligns.Center;
                SegmentClass segment;
                if (c == -1)
                  segment = IPASegments.GapSegment;
                else if (c >= 0 and c < Data.UniqueSegments.Length) {
                  segment = Data.UniqueSegments[c];
                  Background: segment.Partition.Color;
                  TextColor: segment.Partition.TextColor;
                }
                else
                  segment = IPASegments.MissingSegment;
                segment.ShowSegment;
              };
            }
          }
        };
      }
    };
  };

  override GetLayoutTip = ShowDetails(9, true, 10 pts);

  GetChart(SizeClass size, max) = Chart(size.Width, size.Height) {
    Type: ChartTypes.Column;
    TextHeight: 6 pts;
    ValueLabel: "%";
    ChartSeries {
      foreach (var a in Cognate.Alignments) {
        a.Prob * 100.0;
        if (each1 >= max)
          break;
      }
    };
  };

  ShowDetails(max, tip, textheight) = Block {
    TextHeight: textheight;

    Paragraph {
      KeepWithNext: true;
      TextHeight: textheight + 4 pts;
      SpaceAfter: 10 pts;

      TabStops: [3 inches];
      Name;
    };

    if (Cognate.Alignments.Length > 1)
      GetChart(new(3 inch, 0.75 inch), max);

    var langbox = Languages(Data, BoxSize.Height);
    var indent  = GetLayoutSize(langbox).Width;
    Paragraph {
      if (tip) {
        langbox;
        Space;
      }
      else {
        LeftIndent: indent;
        FirstIndent: -indent;
        Tab;
        langbox;
      }

      ShowBlocks(max, BoxSize.Height);
    }
  };

  ShowBlocks(max, boxheight) = Span {
    var cumulative = 0.0;
    foreach (var a in Cognate.Alignments) {
      var prob = a.Prob;
      cumulative += prob;
      var wordset = a.WordSet;
      if (wordset.Length > 0) {
        Show(prob, cumulative, wordset, boxheight);
        Space;
        if (each1 >= max)
          break;
      }
    }
  };

  ShowFigureDetails(max) = Block {
    var h = 8 pts;
    BoxSize = new(BoxSize.Width, h);
    TextHeight: 7 pts;
    Span {
      Languages(Data, h);
      ShowBlocks(max, h);
    }
  };

  ShowFigureData(AlignIndexClass index, AlignDataClass align) = Frame {
    var h = 8 pts;
    BoxSize = new(BoxSize.Width, h);
    Paragraph {
      SpaceBefore: 6 pts;
      TextHeight: 12 pts;
      index.Cognate.GetTitle;
    };

    Paragraph {
      TextHeight: 7 pts;
      Span {
        Languages(Data, h);
        Show(align.Prob, align.Prob, align.WordSet, h);
      }
    };
  };
}

//======================================================================

class CognateIdClass {
  var Concept,
      Cognate,
      Count;

  Constructor(concept, cognate, count) {
    Concept = concept;
    Cognate = cognate ?? DefaultCognate;
    Count   = count;
  }
}

//======================================================================

class AlignmentChartClass {
  ResultsClass Results;

 Constructor(ResultsClass results) {
    Results = results;
  }

  ShowChart(SizeClass size) = VBox(size.Width, size.Height) {
    Style.SansSerif;
    Border: 0.5;

    // Try to make proportional squares
    var xitems = Integer(size.Width / 130);
    var yitems = (Results.Alignments.Length + xitems - 1) div xitems;
    var bsize  = new SizeClass(size.Width / xitems, size.Height / yitems);
    var x      = bsize.Width * 0.5;
    AlignIndexClass[][] rows = Results.Alignments / xitems;

    TextHeight: Math.Min(9 pts, bsize.Height - 3.2 pt);

    foreach (var row in rows) {
      HBox {
        foreach (var a in row) {
          Canvas(bsize.Width, bsize.Height) {
            VAlign: VAligns.Center;
            Border: 0.25 pts {Color: 90%};

            var ap = new AlignPairClass(Results.Data, a);
            Block {
              Paragraph {
                TextColor: Colors.LightGray;
                a.Alignments.Length;
              };
              Paragraph {
                Span {
                  ap.Name;
                  TipAction: new ActionClass(Actions.TipDocument, ap);
                };
              };
            };
          }
        }
      }
    }
  };

  ShowAll = Block {
    foreach (var a in Results.Alignments) {
      new AlignPairClass(Results.Data, a).ShowDetails(5, false, 10 pts);
      Paragraph {
        Border: BorderT(1);
      };
    }
  };

  ShowSet(DataSetClass data, CognateIdClass[] examples) = MatrixBlock {
    var alignments = Results.Alignments;
    var chartwidth = 1 inch;

    foreach (var e in examples) {
      var found = null;
      foreach (var a in alignments) {
        if (a.ConceptName == e.Concept && a.CognateName == e.Cognate) {
          found = a;
          break;
        }
      }

      if (valid found) {
        var ap = new AlignPairClass(data, found);
        Row {
          VAlign: VAligns.Top;
          Frame(0.75 inch, null, PadR(10 pts)) {
            e.Concept;
            e.Cognate Italic;
          };
          ap.GetChart(new(chartwidth, data.Taxa.Length * (9 pts)), e.Count);
          Frame(5 inches) {
            ap.ShowFigureDetails(e.Count);
          }
        }
      }
    }
  };
}

//======================================================================

class LanguageClass: FactClass {
  field      Name,
             Cases;
  var        MapAttribution;
  ImageClass MapImage;

  Constructor(id, name, cases=0) {
    super.Constructor(id);
    Name  = name;
    Cases = cases;
  }

  override IconClass GetIcon = Icons.language;

  virtual Description = null;
  virtual Details = null;

  override GetLayoutSpan = Span {
    TipAction: this;
    Name;
  };

  override GetLayoutTip = Block {
    Paragraph {
      Bold;
      TextHeight: 14 pts;
      Name;
    };
    Description;

    if (valid MapImage)
      ShowMap(new(4 inches, 2 inches));
  };

  static ImageClass LoadImage(name) = new ImageClass(Info.ImageFolder FileName(name));

  ShowMap(SizeClass size) = HBox {
    HAlign: HAligns.Center;

    VBox {
      var h = 6 pts;
      MapImage.FitSize(new(size.Width, size.Height - h*2));

      if (valid MapAttribution) {
        Frame(size.Width) {
          TextHeight: h;
          TextColor: 80%;
          Lang.Credit;
          MapAttribution;
        }
      }
    }
  };
}

//======================================================================

typedef SegmentDictionary DictionaryClass<SegmentClass>;

class WordClass: FactClass {
  field          Plain,
                 Text;
  LanguageClass  Language;
  TaxonClass     Taxon;
  CognateClass   Cognate;
  SegmentClass[] Segments,
                 Aligned,
                 Padded;

  Constructor(SegmentDictionary dictionary, TaxonClass taxon, CognateClass cognate, text) {
    super.Constructor(valid cognate ? text+cognate.Concept.Name+cognate.Name+taxon.Variable : #71f32657-a37c-4f1d-abba-87b928e9d80b#);

    // IPA text and word text must be in the same unicode normaization form so comparisons are accurate
    Text     = text.GetString(NormalizationForms.FormC);
    Plain    = Text.FindSlice(c => c != IPASegments.GapSegment.Ipa and c != IPASegments.PrimaryStress.Ipa);
    Taxon    = taxon;
    Language = taxon.Language;
    Cognate  = cognate;

    if (valid Text) {
      var segments = dictionary.FindTokens(Text, IPA.NullSegment);
      Aligned  = segments.FindSlice(s => s.Gap or (not s.Punctuation));
      Segments = segments.FindSlice(s => not s.Punctuation);

      // Test that the word's text is the same as the segments converted back into text
      var view = Span {(each segments).Ipa};
      System.Assert(Text == view.GetString(), "Round-trip error with text {0}-{1}"(Text, view), Text);

      Link.Connect(this, Segments);
      Link.Connect(this, cognate);
      Link.Connect(this, Language);
      Link.Connect(Language, cognate);
    }
    else {
      Segments = [];
      Aligned  = [];
    }
  }

  override IconClass GetIcon = Icons.text_snippet;

  ShowConcept = Span {
    Style.SansSerif;
    TipAction: this;
    Cognate.GetTitle;
  };

  override GetLayoutSpan = Span {
    foreach (var s in Segments) {
      if (!s.Punctuation)
        s.Ipa;
    }
  };

  ShowPaddedBlocks(textheight, index=-1) = HBox {
    TextHeight: textheight;

    foreach (var segment in Padded) {
      HBox(textheight*1.125) {
        Border: BorderL(new(0.125 pts, 80%));
        HAlign: HAligns.Center;
        if (index == each0)
          Background: Colors.LightYellow;
        segment.ShowSegment;
      };
    }
  };

  FieldPar(name) = Paragraph {
    TabStops: [0.5 inches];
    Bold name;
    Tab;
  };

  override GetLayoutTip = Block {
    FieldPar(Lang.Language) {
      Language;
    };
    FieldPar(Lang.Cognate) {
      Cognate.GetTitle;
    };
    FieldPar(Lang.Segments) {
      Frame {
        Border: 0.5;
        ShowPaddedBlocks(16 pts);
      }
    }
  };

  override GetLayoutFact = Block {
    Paragraph {
      TabStops: [1 inch, 2, inch, 3 inch, 4 inch];
      GetIcon;
      Space;
      Quote;
      Plain;
      Quote;
      Tab;
      Language;
      ColonSpace;
      Cognate.GetTitle;
    };
    super.GetLayoutFact;
  };
}

//======================================================================

class ConceptClass: FactClass {
  field Name,
        Confidence;
  var   Variable,
        WordType,
        WordGroup;

  Constructor(variable) {
    super.Constructor(variable.GetVariableFullName);
    Variable   = variable;
    Name       = variable.GetVariableName;
    Confidence = variable.Confidence;
    WordType   = variable.WordType;
    WordGroup  = variable.WordGroup;

    System.Assert(Confidence > 0);
    System.Assert(WordType != WordTypes.None);
    System.Assert(WordGroup != WordGroups.None);
  }

  override IconClass GetIcon = Icons.category;

  override GetLayoutTip = Span {Name; "-"; Confidence};

  override Compare(c, options) {
    return Name.Compare(c.Name);
  }
}
//======================================================================

class CognateClass: FactClass {
  field        Name;
  DataSetClass Data;
  ConceptClass Concept;
  WordClass[]  Words;
  var          MaxLength,
               Variable;

  Constructor(DataSetClass data, ConceptClass concept, variable) {
    super.Constructor(variable.GetVariableFullName);

    Name       = variable.GetVariableName;
    Data       = data;
    Concept    = concept;
    Variable   = variable;
    MaxLength  = 0;

    Link.Connect(this, concept);
  }

  override IconClass GetIcon = Icons.format_list_bulleted;

  GetSource = Concept.Name + '-' + Name;

  GetTitle = Span {
    Concept.Name; '-'; Name;
    TipAction: this;
  };

//  override GetLayoutTip = AllWords.ShowConceptTable(Data, this);

  override Compare(c, options) {
    var i = Concept.Compare(c.Concept, options);
    if (i == 0)
      return Name.Compare(c.Name, options);
    return i;
  }
}
//======================================================================

class TaxonClass {
  var           Variable,
                Index,
                WordCount;
  LanguageClass Language;

  Constructor(LanguageClass language) {
    Index     = each0;
    Language  = language;
    Variable  = language.GetVariableName;
    WordCount = 0;
  }

  override GetLayoutTip = Span {
    Style.TaxonFormat;
    Variable;
    TipAction: Language;
  };
}
//======================================================================

class WordPairClass {
  var       Index;
  WordClass Word1,
            Word2;

  Constructor(index, WordClass w1, WordClass w2) {
    Index = index;
    Word1 = w1;
    Word2 = w2;
  }

  ShowDescription(textheight) = Frame {
    Border: 0.25 pts;
    TextHeight: textheight;
    Paragraph {
      ParBackground: 90%;
      Bold;
      Word1.Cognate.Variable.GetVariableFullName[9..];
    };

    Word1.ShowPaddedBlocks(textheight, Index);
    Word2.ShowPaddedBlocks(textheight, Index);
  };

  override GetLayoutTip = ShowDescription(12 pts);
}
//======================================================================

class ResultsClass {
  ExperimentClass   Experiment;
  DataSetClass      Data;
  RuleClass         Rule;
  AlignIndexClass[] Alignments;
  StatClass[][]     TransitionStats;
  var               Output,
                    AlignmentCutoff,
                    EquilibriumFrequencies;

  Constructor(ExperimentClass experiment) {
    Experiment = experiment;
    Data       = experiment.Data;
    Rule       = experiment.Rule;

    Output                 = IO.ReadScript(experiment.MainRun.Alignments).Root;
    TransitionStats        = Output.TransitionStats;
    EquilibriumFrequencies = Output.EquilibriumFrequencies;
    AlignmentCutoff        = Output.AlignmentCutoff;
    Alignments             = Output.Alignments;

    var alist = new ListClass<AlignIndexClass>(1024);
    foreach (var a in Alignments) {
      foreach (var c in Data.UsedCognates) {
        if (c.Concept.Name == a.ConceptName and c.Name == a.CognateName) {
          a.Cognate = c;
          alist.Add(a);
          break;
        }
      }
    }
    Alignments = alist.Values.Sort(false, ref CompareAlignment);
  }

  static CompareAlignment(AlignIndexClass a0, AlignIndexClass a1, options) {
    var c = a0.Alignments.Length.Compare(a1.Alignments.Length);
    if (c == 0)
      return a0.ConceptName.Compare(a1.ConceptName);
    return c;
  }
}
//======================================================================

class DataSetClass {
  LanguageClass[]             Languages;
  SegmentClass[]              UniqueSegments;
  CognateClass[]              UsedCognates,
                              SortedCognates;
  ConceptClass[]              UsedConcepts;
  TaxonClass[]                Taxa;
  DictionaryClass<TaxonClass> TaxonSet;
  VectorClass                 WordList;
  var                         MaxLanguageName,
                              WordCount,
                              SegmentCount,
                              WordCutoff,
                              ExampleConcept,
                              FigureConcept,
                              DataConcept;

  Constructor(concepts, includewords, LanguageClass[] languages, cutoff=-1) {
    ExampleConcept  = concepts.Stone;
    FigureConcept   = concepts.What;
    DataConcept     = concepts.Mountain;
    Languages       = languages;
    WordCount       = 0;
    SegmentCount    = 0;
    MaxLanguageName = 0;
    WordCutoff      = cutoff < 0 ? languages.Length : cutoff;
    TaxonSet        = new(languages.Length);
    ListClass<TaxonClass> tlist = new(languages.Length);

    foreach (var l in languages) {
      var taxon = new TaxonClass(l);
      tlist.Add(taxon);
      TaxonSet.Add(taxon, taxon.Variable);
      if (taxon.Variable.Length > MaxLanguageName)
        MaxLanguageName = taxon.Variable.Length;
    }
    Taxa     = tlist.Values;
    WordList = new(Taxa.Length, null);

    // Build a dictionary with IPA text as the key
    var dictionary = new SegmentDictionary(256);
    foreach (var segment in IPASegments) {
      if (valid segment.Ipa)
        dictionary.Add(segment, segment.Ipa);
    }

    var clist       = new ListClass<CognateClass>(1024);
    var conceptlist = new ListClass<ConceptClass>(256);

    foreach (var conceptvar in concepts) {
      var good = exists conceptvar.?Confidence and
                 exists conceptvar.?WordType and
                 exists conceptvar.?WordGroup;
      System.Assert(good, "Improper concept", conceptvar);

      if (good and conceptvar.Confidence > 0 and conceptvar.WordGroup.HasFlag(includewords)) {
        foreach (var cognate in conceptvar) {
          var vname = cognate.GetVariableName();
          var inc   = true;

          switch (vname) {
            case "Confidence":
            case "WordType":
            case "WordGroup":
              inc = false;
              break;
          }

          if (inc) {
            var count = 0;
            foreach (var word in cognate) {
              if (valid word) {
                var taxon = TaxonSet.FindKey(word.GetVariableName);
                if (valid taxon) {
                  ++taxon.WordCount;
                  ++count;
                }
              }
            }

            if (count >= WordCutoff) {
              var concept = new ConceptClass(conceptvar);
              conceptlist.Add(concept);


              WordCount += count;
              var c = new CognateClass(this, concept, cognate);
              clist.Add(c);
            }
          }
        }
      }
    }


    UsedConcepts = conceptlist.Values.Sort(false);
    UsedCognates = clist.Values;

    foreach (var cognate in UsedCognates)
      ComputeCognate(dictionary, cognate);

    UniqueSegments = GetUniqueSegments;
    foreach (var segment in UniqueSegments) {
      segment.Index         = each0;
      segment.UsedFrequency = Real(segment.UsedCount) / SegmentCount;
    }
  }

  Coverage(TaxonClass taxon) {
    var index = taxon.Index;
    var count = 0.0;
    var used  = 0.0;
    foreach (var c in UsedCognates) {
      var word = c.Words[index];
      if (valid word && valid word.Text)
        ++used;

      ++count;
    }
    return used / count;
  }

  CoverageByLanguages {
    var count = new VectorClass(Taxa.Length+1, 0.0);
    foreach (var c in UsedCognates) {
      var used = 0;
      foreach (var word in c.Words) {
        if (valid word && valid word.Text)
          ++used;
      }
      count.AddValue(used, 1.0);
    }
    return count;
  }

  CognateClass[] GetSortedCognates {
    if (invalid SortedCognates)
      SortedCognates = UsedCognates.Sort(false);
    return SortedCognates;
  }

  CognateClass GetCognate(concept) = UsedCognates.FindFirst(c => c.Concept.Variable == concept);

  SegmentClass[] GetUniqueSegments {
    var set = new SegmentSetClass(512);
    foreach (var cognate in UsedCognates) {
      foreach (var word in cognate.Words) {
        foreach (var segment in word.Segments) {
          if (!segment.Punctuation)
            set.Add(segment);
        }
      }
    }
    return set.Values;
  }

  LangNumber(LanguageClass language) = Languages.FindFirstIndex(language)+1;

  void ComputeCognate(SegmentDictionary dictionary, CognateClass cognate) {
    var defword = new WordClass(null, Taxa[0], null, Empty);

    WordList.SetAllValues(defword);
    var maxlength = 0;

    foreach (var langword in cognate.Variable) {
      var taxon = TaxonSet.FindKey(langword.GetVariableName);
      if (valid taxon) {
        var word = new WordClass(dictionary, taxon, cognate, langword);
        maxlength = Math.Max(maxlength, word.Aligned.Length);

        foreach (var s in word.Segments) {
          ++SegmentCount;
          ++s.UsedCount;
        }
        WordList.SetValue(taxon.Index, word);
      }
    }

    cognate.Words     = WordList.Values;
    cognate.MaxLength = maxlength;

    foreach (var word in cognate.Words) {
      var a = word.Aligned;
      if (valid a) {
        if (a.Length < maxlength)
          word.Padded = a + [IPASegments.GapSegment] * (maxlength - a.Length);
        else
          word.Padded = a;
      }
      else
        word.Padded = a;
    }

    for (var i = 0; i < maxlength; ++i) {
      var count    = 0;
      var gapcount = 0;

      foreach (var word in cognate.Words) {
        if (valid word.Aligned) {
          ++count;
          if (word.Padded[i] == IPASegments.GapSegment)
            ++gapcount;
        }
      }
      System.Assert(gapcount < count, "Column with all gaps", cognate.Variable);
    }
  }

  ShowWord(SegmentClass segment) = Block {
    Paragraph {
      SpaceBefore: 10 pts;
      TextHeight: 14;
      Border: BorderB(1);
      "Words containing \"{0}\""(segment.Ipa);
    };
    Paragraph {
      Separator: Space;
      foreach (var cognate in UsedCognates) {
        foreach (var word in cognate.Words) {
          if (word.Segments.FindAny(segment))
            word.Plain;
        }
      }
    };
  };
}

//======================================================================

abstract class CountBaseClass {
  var            VFlags,
                 MaxDigits;
  SegmentClass[] PartSegments;

  Constructor(ExperimentClass experiment) {
    VFlags       = SegmentFeatures.Vowel | SegmentFeatures.Semivowel;
    PartSegments = experiment.Rule.PartSegments;
    MaxDigits    = 3;
  }

  PartitionBox(DocumentClass document) = Paragraph {
    Style.SansSerif;

    var grid   = 0.125 pts;
    var gcolor = 65%;
    var border = 0.5 pts;
    var size   = ExtentSize - border*2;
    var length = PartSegments.Length;
    var d      = size / (length+1);

    Canvas {
      TextHeight: Math.Min(d.Height * 0.7, d.Width * 1.8 / MaxDigits);
      Border: border;

      var y = d.Height;
      for (var i = 0; i < length; ++i) {
        var x = d.Width;
        for (var j = 0; j < length; ++j) {
          AddEntry(PartSegments[i], PartSegments[j], x, y, d);
          x += d.Width;
        }
        y += d.Height;
      }

      y = d.Height;
      var p = 0;
      foreach (var s in PartSegments) {
        Canvas(d.Width, d.Height) {
          Y: y;
          Background: s.Partition.Color;
          TextColor: s.Partition.TextColor;
          HAlign: HAligns.Center;
          VAlign: VAligns.Center;
          s.ShowSegment;
        };
        if (p != s.PartitionIndex) {
          Canvas(size.Width, grid) {
            Y: y;
            Background: gcolor;
          };
          p = s.PartitionIndex;
        }
        y += d.Height;
      }

      Canvas(size.Width, d.Height) {
        var x = d.Width;
        p = 0;
        foreach (var s in PartSegments) {
          Canvas(d.Width, d.Height) {
            X : x;
            Background: s.Partition.Color;
            TextColor: s.Partition.TextColor;
            HAlign: HAligns.Center;
            VAlign: VAligns.Center;
            s.ShowSegment;
          };
          if (p != s.PartitionIndex) {
            Canvas(grid, size.Height) {
              X: x;
              Background: gcolor;
            };
            p = s.PartitionIndex;
          }
          x += d.Width;
        }
      };
    };
  };

  abstract AddEntry(SegmentClass si, SegmentClass sj, x, y, SizeClass size);
}

//======================================================================

class PriorCountClass: CountBaseClass {
  MatrixClass TMatrix;
  var         Factor;

  Constructor(ExperimentClass experiment) {
    super.Constructor(experiment);
    MaxDigits = 4;

    var data  = experiment.Data;
    var count = data.UniqueSegments.Length;
    TMatrix = new MatrixClass(count, count, null);
    var tmax = 1;

    foreach (var cognate in data.UsedCognates) {
      var length = cognate.Words.Length;
      for (var i = 0; i < length; ++i) {
        var pi = cognate.Words[i].Padded;
        for (var j = 0; j < length; ++j) {
          if (i != j) {
            var pj = cognate.Words[j].Padded;
            var ml = Min(pi.Length, pj.Length);
            for (var index = 0; index < ml; ++index) {
              var si = pi[index];
              var sj = pj[index];
              if (si.Index != sj.Index and not si.Punctuation and not sj.Punctuation) {
                var list = TMatrix.GetValue(si.Index, sj.Index);
                var p    = new WordPairClass(index, cognate.Words[i], cognate.Words[j]);
                if (invalid list) {
                  list = new ListClass<WordPairClass>(128);
                  TMatrix.SetValue(si.Index, sj.Index, list);
                }
                list.Add(p);
                if (list.Length > tmax)
                  tmax = list.Length;
              }
            }
          }
        }
      }
    }
    Factor = 1.0 / tmax;
  }

  override AddEntry(SegmentClass si, SegmentClass sj, x, y, SizeClass size) {
    var value = TMatrix.GetValue(si.Index, sj.Index);
    if (invalid value)
      return null;

    return Canvas(size.Width, size.Height) {
      X: x;
      Y: y;
      HAlign: HAligns.Center;
      VAlign: VAligns.Center;
      TipAction: new TranActionClass(value.Values, value.Length*Factor);

      var count = 0;
      foreach (var e in value) {
        var c0 = e.Word1.Padded[e.Index];
        var c1 = e.Word2.Padded[e.Index];
        if (c0.Features.HasFlag(VFlags) != c1.Features.HasFlag(VFlags))
          ++count;
      }

      if (count > 0) {
        var f = Integer(255.0 * (1.0 - count / value.Length));
        if (f < 255)
          Background: new ColorClass(f, 255, f);
      }
      else {
        var f = Integer((1.0 - value.Length * Factor) * 255.0);
        if (f < 255)
          Background: new ColorClass(255, f, f);
      }

      value.Length;
    };
  }
}

//======================================================================

class AlignedCountClass: CountBaseClass {
  ListClass<AlignActionClass> ActionList;
  MatrixClass                 Actions;
  ResultsClass                Results;
  var                         Symmetric;
  AlignActionClass[]          SortedActions;

  Constructor(ResultsClass results, rates, maxrate, minrate, symmetric) {
    super.Constructor(results.Experiment);
    Symmetric = symmetric;
    Results   = results;

    var ordered = results.Data.UniqueSegments;
    var length  = PartSegments.Length;

    System.Assert(length == rates.Length);
    System.Assert(length == ordered.Length);


    Actions    = new MatrixClass(length, length, null);
    ActionList = new(length * length);

    for (var i = 0; i < length; ++i) {
      var jmax = symmetric ? i : length;

      for (var j = 0; j < jmax; ++j) {
        var rate    = rates[i][j];
        var reverse = rates[j][i];
        if (rate >= minrate or reverse > minrate) {
          var a = new AlignActionClass(results, ordered[i], ordered[j], rate, reverse, symmetric);
          ActionList.Add(a);
          Actions.SetValue(i, j, a);
        }
      }
    }

    var f = 1.0 / maxrate;
    foreach (var a in ActionList)
      a.Percent = a.Rate * f;

    SortedActions = ActionList.Sort(true);
  }

  override AddEntry(SegmentClass si, SegmentClass sj, x, y, SizeClass size) {
    var a = Actions.GetValue(si.Index, sj.Index);
    if (valid a) {
      return Canvas(size.Width, size.Height) {
        X: x;
        Y: y;
        HAlign: HAligns.Center;
        VAlign: VAligns.Center;
        TipAction: a;

        var f = Integer(2.55 * (100.0 - a.Percent));
        Background: new ColorClass(255, f, f);
        Span {a.Percent; TextDigits: 0};
      };
    }
    return null;
  }

  ShowLegend(AlignActionClass[] actions) = {
    // Show only partitions that are present in the chart
    var pmax = Results.Rule.Partitions.Length;
    var set  = new HashSetClass(pmax);
    var list = new ListClass<PartitionClass>(pmax);
    foreach (var s in actions) {
      var i = s.S0.Partition;
      if (set.Add(i))
        list.Add(i);
      i = s.S1.Partition;
      if (set.Add(i))
        list.Add(i);
    }

    Canvas(ExtentWidth) {
      HAlign: HAligns.Center;
      Experiment.Rule.ShowBlockLegend(list.Values, 11 pts);
    }
  };

  ShowChart(AlignActionClass[] actions) = Chart(100%, 4 inches) {
    Type: ChartTypes.Column;
    TextHeight: 10 pts;
    ValueLabel: HBox {
      TextHeight: 12 pts;
      Transform: Rotate(90 degrees);
      TransformFit: true;
      "Transition Rate %";
    };

    var fs = 200.0 / actions.Length;
    XAxis: ChartAxis {
      Rotation: 30 degrees;
      (each actions).ShowBox(fs);
    };

    ChartSeries {
      Fill: Colors.Green;
      Label: Tex.rightarrow;
      foreach (var a in actions)
        new DataPointClass(each0, a.Rate) {Reference: a};
    };
  };

  Most(top) = VBox {
    var actions = SortedActions.Slice(0..<top);
    ShowChart(actions);
    Separation: 20 pts;
    ShowLegend(actions);
  };

  Pairs(top, predicate) = VBox {
    var subset  = SortedActions.FindSlice(predicate);
    var actions = subset.Slice(0..<top);

    ShowChart(actions) {
      Type: ChartTypes.StackedColumn;

      Legend: ChartLegend {
        Vertical: true;
        Placement: Placements.Right;
      };
      ChartSeries {
        Fill: Colors.Red;
        Label: Tex.leftarrow;
        foreach (var a in actions)
          new DataPointClass(each0, a.Reverse);
      };
    };
    Separation: 20 pts;
    ShowLegend(actions);
  };

}

//======================================================================

class SegDataClass {
  PartitionClass Partition;
  SegmentClass   Segment;
  var            Value;

  Constructor(ResultsClass results, rates, i) {
    Segment   = results.Data.UniqueSegments[i];
    Partition = Segment.Partition;
    Value     = Math.Abs(rates[i][i]);
  }

  override GetLayoutTip = VBox {
    HAlign: HAligns.Center;

    Span {
      "Rate: ";
      TextDigits: 3;
      Value;
    };
    VBox(DocMetrics.SegmentWidth) {
      HAlign: HAligns.Center;
      Background: Partition.Color;
      HBox {
        Partition.Name;
      };
    };
    Segment.GetLayoutTip;
  };
}

//======================================================================

class DiagonalClass {
  SegDataClass[]   Data;
  SegmentClass[]   Segments;
  PartitionClass[] Partitions;

  Constructor(ResultsClass results, rates, max) {
    var data = new SegDataClass(results, rates, each 0..<rates.Length);
    Data     = data.Sort(true, ref CompareData);
    Segments = (each Data).Segment;

    var partitions = results.Rule.Partitions;
    var pmax        = partitions.Length;
    var set        = new HashSetClass(pmax);
    var list       = new ListClass<PartitionClass>(pmax);
    foreach (var s in Segments) {
      var i = s.PartitionIndex;
      if (set.Add(i))
        list.Add(partitions[i]);
    }
    Partitions = list.Values;
  }

  CompareData(SegDataClass d0, SegDataClass d1, options) = d0.Value.Compare(d1.Value);

  Display = VBox {
    HAlign: HAligns.Center;
    Style.SansSerif;

    Chart(ExtentWidth, 4 inches) {
      TextHeight: 11 pts;
      Type: ChartTypes.Column;

      ValueLabel: "Rate of Change" {
        Transform: Rotate(90 degrees);
        TransformFit: true;
      };

      XAxis: ChartAxis {
        TextHeight: DocMetrics.SegmentTextFactor * ExtentWidth / Data.Length;
        (each Segments).ShowSegment;
      };

      ValueAxis: ChartAxis;
      ChartSeries {
        foreach (var d in Data) {
          new DataPointClass(each0, d.Value) {
            Reference: d;
            Fill: d.Segment.Partition.Color;
          };
        }
      };
    };

    Experiment.Rule.ShowBlockLegend(Partitions, 9 pts);
  };
}

//======================================================================

class FrequencyClass {
  var Frequency,
      Index;

  Constructor(frequency) {
    Index     = each0;
    Frequency = frequency;
  }
}

//======================================================================

class RateDataClass {
  TaxonClass       Taxon;
  VectorClass      Count;
  FrequencyClass[] Frequency;
  var              TotalCount,
                   MaxFrequency,
                   Distance;

  Constructor(count, TaxonClass taxon) {
    Taxon        = taxon;
    TotalCount   = 0;
    MaxFrequency = 0;
    Count        = new VectorClass(count, 0);
  }
}

//======================================================================

class SegmentActionClass: ActionClass {
  RateDataClass Rate;
  SegmentClass  Segment;
  TaxonClass    Taxon;
  var           Count,
                Percent;

  Constructor(RateDataClass rate, SegmentClass segment, count, percent) {
    super.Constructor(Actions.RunQuery, null);
    Segment = segment;
    Taxon   = rate.Taxon;
    Count   = count;
    Percent = percent;
  }

  override GetQuery = MatchAll WordClass {
    MatchAny LanguageClass {
      Taxon.Language;
    };
    MatchAny SegmentClass {
      Segment;
    };
  };

  override GetLayoutTip = VBox {
    HAlign: HAligns.Center;
    Span {
      Lang.Occurrences(Count);
      Space;
      Span {
        "(";
        TextDigits: 1;
        Percent * 100.0;
        "%)";
      }
    };
    Segment.GetLayoutTip;
  };
}

//======================================================================

abstract class FrequencyChartClass {
  ExperimentClass  Experiment;
  PartitionClass[] Partitions;
  DataSetClass     Data;
  TaxonClass[]     Taxa;
  VectorClass      UsedCount,
                   UsedFrequency;
  FrequencyClass[] FirstRate;
  RateDataClass[]  Rates,
                   SortedRates;
  var              RateCount,
                   SortedIndexes,
                   MaxDistance;

 Constructor(ExperimentClass experiment, count) {
    Experiment = experiment;
    Partitions = experiment.Rule.Partitions;
    Data       = experiment.Data;
    Taxa       = Data.Taxa;
    RateCount  = count;
    Rates      = new RateDataClass(count, each Taxa);
  }

  CompareFrequency(i0, i1, options) {
    var f0 = FirstRate[i0];
    var f1 = FirstRate[i1];
    var d  = f0.Frequency.Compare(f1.Frequency);
    if (d == 0)
      return f0.Index - f1.Index;
    return d;
  }

  static CompareDistance(RateDataClass r0, RateDataClass r1, options) {
    return r0.Distance.Compare(r1.Distance);
  }

  void ComputeDistance(sortfunction) {
    // Compute the Euclidean distance between each language and the first language

    var fr = new VectorClass(RateCount, 0.0);
    foreach (var rate in Rates) {
      var mult = 100.0 / rate.TotalCount;
      for (var i = 0; i < RateCount; ++i) {
        var f = mult * rate.Count[i];
        fr.SetValue(i, f);
        if (f > rate.MaxFrequency)
          rate.MaxFrequency = f;
      }
      rate.Frequency = new FrequencyClass(each fr);
    }

    var max = 0.0;
    var r0  = Rates[0];
    foreach (var rate in Rates) {
      if (each0 > 0) {
        var sum = 0;
        for (var i = 0; i < RateCount; ++i) {
          var delta = rate.Frequency[i].Frequency - r0.Frequency[i].Frequency;
          sum += delta * delta;
        }
        rate.Distance = Math.Sqrt(sum);
        if (rate.Distance > max)
          max = rate.Distance;
      }
      else
        rate.Distance = 0.0;
    }

    MaxDistance = max;
    FirstRate   = r0.Frequency;
    var a = 0 ..< RateCount step 1;
    SortedIndexes = a.Sort(true, sortfunction);
    SortedRates   = Rates.Sort(false, ref CompareDistance);
  }

  abstract SegmentBar(RateDataClass rate, index, width, height);
  abstract OccurranceChart(SizeClass size);

  LangCanvas(RateDataClass rate, width, height) = HBox(null, height) {
    var cborder = 0.25 pts;

    VAlign: VAligns.Bottom;
    Border: BorderB(cborder);
    SegmentBar(rate, each SortedIndexes, width, height - cborder);
  };

  ShowChart = HBox {
    VAlign: VAligns.Center;
    Experiment.Rule.ShowLegend(10 pts, 1.4 inch, 5) {
      Border: 0.25 {Color: 80%};
      Margin: PadR(12 pts);
    };
    OccurranceChart(new(ExtentWidth - 2 inches, ExtentHeight));
  };
}
//======================================================================

class SegmentFrequencyClass: FrequencyChartClass {
  VectorClass PartitionMax;

  Constructor(ExperimentClass experiment, group) {
    super.Constructor(experiment, experiment.Data.UniqueSegments.Length);

    PartitionMax = new(experiment.Rule.Partitions.Length, 0);

    foreach (var cognate in Data.UsedCognates) {
      foreach (var word in cognate.Words) {
        var rate = Rates[word.Taxon.Index];
        foreach (var segment in word.Segments) {
          ++rate.TotalCount;
          rate.Count.AddValue(segment.Index, 1);
          PartitionMax.AddValue(segment.PartitionIndex, 1);
        }
      }
    }

    ComputeDistance(group ? ref CompareGroups : ref CompareFrequency);
  }

  CompareGroups(i0, i1, options) {
    var f0 = FirstRate[i0];
    var f1 = FirstRate[i1];
    var d  = PartitionMax[Data.UniqueSegments[f0.Index].PartitionIndex] - PartitionMax[Data.UniqueSegments[f1.Index].PartitionIndex];
    if (d == 0) {
      d = f0.Frequency.Compare(f1.Frequency);
      if (d == 0)
        return f0.Index - f1.Index;
    }
    return d;
  }

  override SegmentBar(RateDataClass rate, index, width, height) {
    var f = rate.Frequency[index].Frequency / rate.MaxFrequency;
    return Canvas(width-1, height * f) {
      Margin: PadR(1);
      var s = Data.UniqueSegments[index];
      Background: s.Partition.Color;
      TipAction: new SegmentActionClass(rate, s, rate.Count[index], f);
    };
  }

  SegmentLabel(SegmentClass[] segments, index, width, height) = HBox(width, height) {
    HAlign: HAligns.Center;
    segments[index].ShowSegment;
  };

  override OccurranceChart(SizeClass size) = MatrixBlock {
    var lw = 70 pts;
    var cw = size.Width - lw;
    var bw = cw / Data.UniqueSegments.Length;
    var bh = bw * 1.5;
    var h  = (size.Height - bh) / Taxa.Length;
    var r0 = SortedRates[0];

    TextHeight: 12 pts;
    VAlign: VAligns.Bottom;
    foreach (var rate in SortedRates) {
      Row {
        Cell(PadR(3 pts)) {
          Frame(lw) {
            rate.Taxon.Language;
          };
          if (rate.Distance > 0) {
            var frac = rate.Distance / MaxDistance;
            Canvas(lw * frac, 2) {
              Background: Colors.Red;
              Tip: new TipClass(String("{0}% different from {1}"(frac*100.0 {TextDigits: 1}, r0.Taxon.Language)));
            };
          }
        };
        LangCanvas(rate, bw, h);
      };
    }

    Row {
      Empty;
      TextHeight: 1.1 * bw;
      HBox {
        SegmentLabel(Data.UniqueSegments, each SortedIndexes, bw, bh);
      };
    }
  };
}

//======================================================================

class PartitionRateActionClass: ActionClass {
  RateDataClass  Rate;
  PartitionClass Partition;
  TaxonClass     Taxon;
  var            Count,
                 Percent;

  Constructor(RateDataClass rate, PartitionClass partition, count, percent) {
    super.Constructor(Actions.RunQuery, null);
    Partition = partition;
    Taxon     = rate.Taxon;
    Count     = count;
    Percent   = percent;
  }

  override GetQuery = MatchAll WordClass {
    MatchAny LanguageClass {
      Taxon.Language;
    };
    MatchAny SegmentClass {
      Partition.Segments;
    };
  };

  override GetLayoutTip = VBox {
    HAlign: HAligns.Center;
    Span {
      Lang.Occurrences(Count);
      Space;
      Span {
        "(";
        TextDigits: 1;
        Percent * 100.0;
        "%)";
      }
    };
  };
}

//======================================================================

class PartitionFrequencyClass: FrequencyChartClass {
  Constructor(ExperimentClass experiment) {
    super.Constructor(experiment, experiment.Rule.Partitions.Length);

    foreach (var cognate in Data.UsedCognates) {
      foreach (var word in cognate.Words) {
        var rate = Rates[word.Taxon.Index];
        foreach (var segment in word.Segments) {
          ++rate.TotalCount;
          rate.Count.AddValue(segment.PartitionIndex, 1);
        }
      }
    }

    ComputeDistance(ref CompareFrequency);
  }

  override SegmentBar(RateDataClass rate, index, width, height) {
    var f = rate.Frequency[index].Frequency / rate.MaxFrequency;
    return Canvas(width-1, height * f) {
      Margin: PadR(1);
      var partition = Partitions[index];
      Background: partition.Color;
      TipAction: new PartitionRateActionClass(rate, partition, rate.Count[index], f);
    };
  }

  PartitionLabel(index, width, height) = Frame(width, height) {
    ParAlignment: ParAlignments.Center;
    Partitions[index].Name;
  };

  override OccurranceChart(SizeClass size) = MatrixBlock {
    var lw = 60 pts;
    var cw = size.Width - lw;
    var bw = cw / Partitions.Length;
    var bh = 16 pts;
    var h  = (size.Height - bh) / Taxa.Length;
    var r0 = SortedRates[0];

    TextHeight: 11 pts;
    VAlign: VAligns.Bottom;
    foreach (var rate in SortedRates) {
      Row {
        Cell(PadR(3 pts)) {
          Frame(lw) {
            rate.Taxon.Language;
          };

          var frac = rate.Distance / MaxDistance;
          Canvas(lw * frac, 2) {
            Background: Colors.Red;
            Tip: new TipClass(String("{0}% different from {1}"(frac*100.0 {TextDigits: 1}, r0.Taxon.Language)));
          };
        };
        LangCanvas(rate, bw, h);
      };
    }

    Row {
      Empty;
      TextHeight: 9 pts;
      HBox {
        VAlign: VAligns.Top;
        PartitionLabel(each SortedIndexes, bw, bh);
      };
    }
  };
}

//======================================================================

