using Format, Units, Math, IO, Rev, LinkTypes;
//======================================================================

class LanguageClass: FactClass {
  field Name,
        Cases;
  var   Variable,
        MapImage,
        MapAttribution,
        Example;

  Constructor(id, name, cases=0) {
    super.Constructor(id);
    Name    = name;
    Cases   = cases;
    Example = false;
  }

  virtual Description = null;
  virtual Details = null;

  override GetLayoutDoc = Span {
    Hover: new HoverClass(this, HoverTypes.Tip);
    Name;
  };

  override GetLayoutTip = Block {
    Paragraph {
      Bold;
      TextHeight: 14 pts;
      Name;
    };
    if (valid Description) {
      Description {
        RightIndent: 3.5 inches;
      };
    }
    ShowMap(Size(5 inches, 3 inches));
  };

  LoadImage(name) = IO.Read(Info.ImageFolder FileName(name));

  ShowMap(size) {
    if (valid MapImage) {
      return VBox {
        Width: size.Width;
        HAlign: HAligns.Center;

        var h = 6 pts;
        MapImage {
          Size: Size(size.Width, size.Height - h);
          Proportional: true;
        };

        if (valid MapAttribution) {
          Span {
            TextHeight: h;
            TextColor: 80%;
            Lang.Credit;
            Hover: new HoverClass(MapAttribution, HoverTypes.Tip);
          }
        }
      };
    }
    return null;
  }
}
//======================================================================

class WordClass: FactClass {
  field          Plain,
                 Text,
                 SegmentCount;
  LanguageClass  Language;
  CognateClass   Cognate;
  SegmentClass[] Segments,
                 Aligned,
                 Padded;

  Constructor(dictionary, LanguageClass language, CognateClass cognate, text) {
    super.Constructor(cognate.Concept.Name+cognate.Name+language.Name);

    // IPA text and word text must be in the same unicode normaization form so comparisons are accurate
    Text       = text.GetString(NormalizationForms.FormC);
    Plain      = Text.FindSlice(c => c != IPA.Segments.GapSegment.Ipa and c != IPA.Segments.PrimaryStress.Ipa);
    Language   = language;
    Cognate    = cognate;

    if (valid Text) {
      var segments = dictionary.FindTokens(Text, IPA.NoSegment);
      Aligned      = segments.FindSlice(s => s.Gap or (not s.Punctuation));
      Segments     = segments.FindSlice(s => not s.Punctuation);
      SegmentCount = Segments.Length;

      // Test that the word's text is the same as the segments converted back into text
      var view = Span {(each segments).Ipa};
      System.Assert(Text == view.GetString(), "Round-trip error with text {0}-{1}"(Text, view), Text);

      Link.Connect(this, Segments);
      Link.Connect(this, cognate);
    }
    else {
      Segments     = [];
      Aligned      = [];
      SegmentCount = 0;
    }
  }

  ShowConcept = Span {
    Style.SansSerif;
    Hover: new HoverClass(this, HoverTypes.Tip);
    Cognate.GetTitle;
  };

  override GetLayoutDoc = Span {
    foreach (var s in Segments) {
      if (!s.Punctuation)
        s.Ipa;
    }
  };

  ShowPaddedBlocks(w, index=-1) = Table {
    Columns: [w]*Padded.Length;
    Row {
      foreach (var segment in Padded) {
        Cell {
          EdgeL: (0.125 pts) {Color: 80%};
          ParAlignment: ParAlignments.Center;
          if (index == EachIndex)
            Background: Colors.LightYellow;
          segment.ShowSegment;
        };
      }
    };
  };

  FieldPar(name) = Paragraph {
    TabStops: [0.5 inches];
    Bold name;
    Tab;
  };

  override GetLayoutTip = Block {
    FieldPar(Lang.Language) {
      Language;
    };
    FieldPar(Lang.Cognate) {
      Cognate.Title;
    };
    FieldPar(Lang.Segments) {
      Frame {
        Border: 0.5;
        TextHeight: 16 pts;
        ShowPaddedBlocks(20 pts);
      }
    }
  };

  override GetLayoutFact = Block {
    Paragraph {
      TabStops: [1 inch, 2, inch, 3 inch, 4 inch];
      Quote;
      Plain;
      Quote;
      Tab;
      Language;
      ColonSpace;
      Cognate.GetTitle;
    };
    super.GetLayoutFact;
  };
}
//======================================================================

class ConceptClass: FactClass {
  field Name,
        Confidence;
  var   Variable;

  Constructor(variable, confidence) {
    super.Constructor(variable.GlobalVariablePath);
    Name       = variable.GlobalVariableName;
    Confidence = confidence;
    Variable   = variable;
  }

  override GetLayoutTip = Span {Name; "-"; Confidence};
}
//======================================================================

class CognateClass: FactClass {
  field        Name;
  ConceptClass Concept;
  WordClass[]  Words;
  var          MaxLength,
               Variable;

  Constructor(ConceptClass concept, variable) {
    super.Constructor(variable.GlobalVariablePath);

    Name      = variable.GlobalVariableName;
    Concept   = concept;
    Variable  = variable;
    MaxLength = 0;
    Link.Connect(this, concept);
  }

  GetTitle {
    return Concept.Name + '-' + Name;
  }

  override GetLayoutTip = AllWords.ShowConceptTable(this);
}
//======================================================================

class TaxonClass {
  var           Variable,
                Index;
  LanguageClass Language;

  Constructor(LanguageClass language) {
    Index    = EachIndex;
    Language = language;
    Variable = language.GlobalVariableName;
  }

  override GetLayoutTip = Span {
    TaxonFormat;
    Variable;
    Hover: new HoverClass(Language, HoverTypes.Tip);
  };
}
//======================================================================

class WordPairClass {
  var       Index;
  WordClass Word1,
            Word2;

  Constructor(index, WordClass w1, WordClass w2) {
    Index = index;
    Word1 = w1;
    Word2 = w2;
  }

  ShowDescription(textheight) = Frame {
    Border: 0.25 pts;
    TextHeight: textheight;
    Paragraph {
      ParBackground: 90%;
      Bold; Word1.Cognate.Variable.GlobalVariablePath[9..]
    };

    textheight += 2 pts;
    Word1.ShowPaddedBlocks(textheight, Index);
    Word2.ShowPaddedBlocks(textheight, Index);
  };

  override GetLayoutTip = ShowDescription(12 pts);
}
//======================================================================

enum Models {
  JC,
  MK,
}

class ResultsClass {
  RuleClass       CharacterRule,
                  PartitionRule;
  SegmentClass[]  UniqueSegments,
                  SortedSegments,
                  PartSegments;
  CognateClass[]  UsedCognates;
  MatrixClass     TransitionCount;
  TaxonClass[]    Taxa;
  var             DisplaySegments,
                  UniqueCharacters,
                  ConceptCount,
                  TotalLength,
                  MaxLanguageName,
                  EXEName,
                  WordCount,
                  SegmentCount,
                  UniqueCount,
                  AddComma,
                  Model,
                  TransitionMax;
  CalcRatesClass  CalcExperiment,
                  CalcStatic;

  Constructor {
    WordCount       = 0;
    SegmentCount    = 0;
    MaxLanguageName = 0;
    Model           = Models.JC;
    EXEName         = Folders.Repository Folder("RevBayes") FileName("rb") Extensions.EXE;

    InitConcepts;

    // Here we assign a character letter to each unique segment from a set of possible Nexus file characters
    CharacterRule = new SingletonRuleClass(this);
    PartitionRule = new Partition2Class(this);


    CharacterRule.AssignCharacters(UniqueSegments);

    var max = 0;
    foreach (var segment in UniqueSegments) {
      segment.Index = EachIndex;
      if (segment.CharacterIndex > max)
        max = segment.CharacterIndex;
    }
    UniqueCharacters = max+1;


    PartitionRule.AssignPartitions(UniqueSegments);

    PartSegments = UniqueSegments.Sort(true, ref ComparePartSegments);

    GetFrequencies;
    var texperiment = new TransitionClass(PartitionRule);
    texperiment.ReadFrequencies;
    CalcExperiment = new CalcRatesClass(this, texperiment);

    var tstatic = new TransitionClass(PartitionRule);
    tstatic.StaticFrequencies(UniqueSegments, TransitionCount);
    CalcStatic = new CalcRatesClass(this, tstatic);
  }

  SegmentClass[] GetUniqueSegments {
    var set = new HashSetClass(512, SegmentClass);
    foreach (var cognate in UsedCognates) {
      foreach (var word in cognate.Words) {
        foreach (var segment in word.Segments) {
          if (!segment.Punctuation)
            set.Add(segment);
        }
      }
    }
    return set.Values;
  }

  ComparePartSegments(SegmentClass s0, SegmentClass s1) {
    var i = s1.PartitionIndex - s0.PartitionIndex;
    if (i == 0)
      return s0.UsedCount - s1.UsedCount;
    else
      return i;
  }

  void InitConcepts {
    // Build a dictionary with IPA text as the key
    var dictionary = new DictionaryClass(256, SegmentClass);
    foreach (var segment in IPA.Segments) {
      if (valid segment.Ipa)
        dictionary.Add(segment, segment.Ipa);
    }

    TotalLength  = 0;
    ConceptCount = 0;

    var set   = new DictionaryClass(1024);
    var clist = new ListClass(1024, CognateClass);
    var tlist = new ListClass(128, TaxonClass);

    foreach (var conceptvar in Concepts) {
      if (exists conceptvar.?Confidence and conceptvar.Confidence > 0) {
        ++ConceptCount;
        var concept = new ConceptClass(conceptvar, conceptvar.Confidence);

        foreach (var cognate in conceptvar) {
          var vname = cognate.GlobalVariableName();
          var inc   = true;

          switch (vname) {
            case "Confidence":
            case "Verb":
              inc = false;
              break;
          }

          if (inc) {
            var count = 0;
            foreach (var word in cognate) {
              var n = word.GlobalVariableName;
              if (set.Add(n, n)) {
                var language = Languages.GetField(n);
                if (valid language) {
                  if (n.Length > MaxLanguageName)
                    MaxLanguageName = n.Length;
                  tlist.Add(new TaxonClass(language));
                }
                else
                  System.Assert(false, "Invalid language: {0}"(n));
              }
              if (valid word)
                ++count;
            }
            if (count > 1) {
              WordCount += count;
              clist.Add(new CognateClass(concept, cognate));
            }
          }
        }
      }
    }
    UsedCognates = clist.Values;
    Taxa         = tlist.Values;

    foreach (var cognate in UsedCognates)
      ComputeCognate(dictionary, cognate);

    UniqueSegments  = GetUniqueSegments;
    DisplaySegments = UniqueSegments;  // Could be IPA.Segments if you want to see all possible segments in the debug tables
    SortedSegments  = UniqueSegments.Sort(true, ref AlphaOrder);
    UniqueCount     = UniqueSegments.Length;
  }

  void ComputeCognate(DictionaryClass dictionary, CognateClass cognate) {
    var words     = new ListClass(Taxa.Length);
    var maxlength = 0;

    foreach (var taxon in Taxa) {
      var word = null;
      foreach (var langword in cognate.Variable) {
        LinkTypes.Link.Connect(taxon.Language, cognate);

        if (langword.GlobalVariableName == taxon.Variable) {
          var w = new WordClass(dictionary, taxon.Language, cognate, langword);
          maxlength = Math.Max([maxlength, w.Aligned.Length]);

          foreach (var s in w.Segments) {
            ++SegmentCount;
            ++s.UsedCount;
          }

          word = w;
          break;
        }
      }
      words.Add(word ?? new WordClass(dictionary, taxon.Language, cognate, Empty));
    }

    cognate.Words     = words.Values;
    cognate.MaxLength = maxlength;

    foreach (var word in cognate.Words) {
      var a = word.Aligned;
      if (valid a) {
        if (a.Length < maxlength)
          word.Padded = a + [IPA.Segments.GapSegment] * (maxlength - a.Length);
        else
          word.Padded = a;
      }
      else
        word.Padded = a;
    }

    for (var i = 0; i < maxlength; ++i) {
      var count    = 0;
      var gapcount = 0;

      foreach (var word in cognate.Words) {
        if (valid word.Aligned) {
          ++count;
          if (word.Padded[i] == IPA.Segments.GapSegment)
            ++gapcount;
        }
      }
      System.Assert(gapcount < count, "Column with all gaps", cognate.Variable);
    }

    TotalLength += maxlength;
  }

  ShowWord(SegmentClass segment) = Block{
    Paragraph {
      SpaceBefore: 10 pts;
      TextHeight: 14;
      BorderB: 1;
      "Words containing \"{0}\""(segment.Ipa);
    };
    Paragraph {
      Separator: Space;
      foreach (var cognate in UsedCognates) {
        foreach (var word in cognate.Words) {
          if (word.Segments.FindAny(segment))
            word.Plain;
        }
      }
    };
  };

  GetConcept(concept) = UsedCognates.FindFirst(c => c.Concept.Variable == concept);

  GetTransitionsCount {
    TransitionMax = 1;
    var t = MatrixInit(null, UniqueCount, UniqueCount);

    foreach (var cognate in UsedCognates) {
      var length = cognate.Words.Length;
      for (var i = 0; i < length; ++i) {
        var p0 = cognate.Words[i].Padded;
        for (var j = 0; j < length; ++j) {
          if (i != j) {
            var p1 = cognate.Words[j].Padded;
            var ml = Min([p0.Length, p1.Length]);
            for (var index = 0; index < ml; ++index) {
              var s0 = p0[index];
              var s1 = p1[index];
              if (s0.Index != s1.Index and not s0.Punctuation and not s1.Punctuation) {
                var list = t.GetValue(s0.Index, s1.Index);
                var p    = new WordPairClass(index, cognate.Words[i], cognate.Words[j]);
                if (not exists list) {
                  list = new ListClass(16);
                  t.SetValue(s0.Index, s1.Index, list);
                }
                list.Add(p);
                if (list.Length > TransitionMax)
                  TransitionMax = list.Length;
              }
            }
          }
        }
      }
    }
    return t;
  }


  WordPairClass[] GetTransitions(SegmentClass segment0, SegmentClass segment1) {
    var list = new ListClass(TransitionMax, WordPairClass);

    foreach (var cognate in UsedCognates) {
      var length = cognate.Words.Length;
      for (var i = 0; i < length; ++i) {
        var p0 = cognate.Words[i].Padded;
        for (var j = 0; j < length; ++j) {
          if (i != j) {
            var p1 = cognate.Words[j].Padded;
            var ml = Min([p0.Length, p1.Length]);
            for (var index = 0; index < ml; ++index) {
              var s0 = p0[index];
              var s1 = p1[index];
              if (s0 == segment0 and s1 == segment1 && s0.Index != s1.Index and not s0.Punctuation and not s1.Punctuation)
                list.Add();
            }
          }
        }
      }
    }
    return list.Values;
  }

  void GetFrequencies {
    TransitionCount = GetTransitionsCount;

    var set = new DictionaryClass(1024);
    foreach (var sd in SegmentFrequencyData)
      set.Add(sd, sd.Text);

    var sum = 0.0;
    foreach (var s in UniqueSegments) {
      if (not s.Punctuation) {
        var f = set.FindKey(s.Ipa);
        if (valid f)
          s.Frequency = f.Frequency;
        sum += s.Frequency;
      }
    }
    if (sum > 0) {
      sum = 1.0 / sum;

      foreach (var s in UniqueSegments) {
        s.NormalFrequency = s.Frequency * sum * 100.0;
        s.UsedFrequency   = s.UsedCount / SegmentCount * 100.0;
      }
    }
  }

  AlphaOrder(SegmentClass x, SegmentClass y) {
    var cl = x.Ipa.Length.Compare(y.Ipa.Length);
    if (cl == 0)
      cl = -x.Ipa.Compare(y.Ipa);
    return cl;
  }

  SegmentCell(SegmentClass segment) = Cell {
    Edge: 0.25 pts {Color: Colors.LightGray};
    Padding: 2 pts;
    segment.Display(segment.GlobalVariablePath, 16 pts)
  };

  SegmentTable = Block {
    var c = DocMetrics.SegmentColumns;

    Style.TitleBar {Lang.IPAListing};
    Table {
      Columns: [DocMetrics.PageContent.Width / c] * c;
      foreach (var s in (SortedSegments / c)) {
        Row {
          SegmentCell(each s);
        }
      }
    };
    Style.TableNotes;
  };

  ShowFilterSegments(SegmentClass[] segments, FilterClass filter, align) = Frame {
    Width: 2 inches;
    Paragraph {
      ParAlignment: align;

      TextHeight: 18 pts;
      var matching = PartitionRule.GetMatching(segments, filter);
      if (valid matching) {
        Separator: Space;
        (each matching).ShowSegment;
      }
    }
  };

  ShowLanguageDetails = Block {
    foreach (var taxon in Taxa) {
      var language = taxon.Language;
      Style.Header2 {
        language.Name;
      };
      Block {
        Paragraph {
          ParAlignment: ParAlignments.Center;
          if (valid language.MapImage)
            language.ShowMap(Size(5 inches, 3 inches));
        };
        language.Description;
        language.Details;
      }
    }
  };

  ShowLanguages = Block {
    var rows      = 2;
    var cols      = (Taxa.Length + 1) div rows;
    var taxagroup = Taxa / cols;
    var h         = 14 pts;
    var space     = 5 pts;
    var size      = Size(DocMetrics.SlideContent.Width / cols - space, DocMetrics.SlideContent.Height / rows - space);

    foreach (var group in taxagroup) {
      HBox {
        PaddingT: space;
        VAlign: VAligns.Top;

        foreach (var taxon in group) {
          VBox {
            MarginR: space;
            Size: size;
            HAlign: HAligns.Center;

            Paragraph {
              TextHeight: h;
              Bold;
              taxon.Language;
            };

            HBox {
              VAlign: VAligns.Center;

              var s = Size(size.Width, size.Height - h);
              Size: s;
              Corner: 20 pts;
              BorderStroke: 1 pts {Color: 90%};
              BorderClip: true;

              Span {
                Hover: new HoverClass(taxon.Language, HoverTypes.Tip);
                taxon.Language.ShowMap(s);
              }
            };
          }
        }
      }
    }
  };

  void InitSource {
    CreateFolder(Info.BaseFolder);
    CreateFolder(Info.OutFolder);
    if (not CharacterRule.Numbers) {
      IO.Write(CharacterFile(1), Info.OutFolder Info.CharacterName);
      IO.Write(RevBayesSource, Info.OutFolder Info.RevSourceName);
    }
    IO.Write(RunBatchFile, Info.BaseFolder FileName("RunIndelly") Extension("bat"), FileFormats.ANSI);
    IO.Write(ConfigFile, Info.BaseFolder Info.ConfigFile, FileFormats.Text);

    var p = new RevProcessClass(EXEName, Info.OutFolder Info.RevSourceName) {
/*      CacheName: "RevBayes";
      CacheInput: [
        OutFolder CharacterName,
        OutFolder RevSourceName,
      ];
      CacheOutput: [
        OutFolder GammaTrees,
        OutFolder GammaConsensus,
        OutFolder GammaMAP,
        OutFolder GammaMCC,
        OutFolder GammaLog,
      ];
*/
      Directory: Info.OutFolder;
    };

//    var results = p.Run;
//    if (results.ExitCode != 0)
//      System.Assert(false, results.StandardOutput, p);
  }

  ShowLanguageTrees = Block {
    Style.ShowTree("Commonly Accepted Romance Tree", Lang.Years, LanguageBranches.Romance);
    Style.ShowTree("Priors", Lang.Years, Info.PriorTree);
    Style.ShowTree("Results", "Branches", Info.ConsensusTree);
  };

  ShowStats = Block {
//    var schema = new LogSchemaClass();
//    var view   = schema.ReadTextFile(Info.OutFolder Info.GammaLog, true, DB.ValueTypes.Double);

//    schema.GetHistogram(view, "alpha");
//    schema.LineChart(view, "Prior");
//    schema.LineChart(view, "Likelihood");
//    schema.LineChart(view, "Posterior");
//    schema.LineChart(view, "Tree Length", "TL");

//    schema.LineChart(view, null, each "bl[{0}]"(each 1..Concepts*2));
//    schema.LineChart(view, null, each "site_rates[{0}]"(each 1..Concepts));
  };

  RunBatchFile = TextBlock {
    Span {
      "\"../../Indelly/x64/Release/tonguetwister.exe\" -d ";
      "\""; Info.ConfigFile; "\"";
      " -o \"";
      Info.OutFolder FileName(Info.BaseFileName);
      "\"";
    }
  };

  CompareSegments(SegmentClass s1, SegmentClass s2) = s1.UsedCount.Compare(s2.UsedCount);

  FrequencyChart(SizeClass size) = Chart {
    TextHeight: 11 pts;

    var sorted = UniqueSegments.Sort(true, ref CompareSegments);
    Style.SansSerif;
    Size: size;
    Type: ChartTypes.Column;
    Legend: ChartLegend {Placement: Placements.Bottom};
    ValueLabel: "Frequency %" {
      Transform: Rotate(90 degrees);
      TransformFit: true;
    };
    XAxis: ChartAxis {
      TextHeight: 0.6 * size.Width / sorted.Length;
      (each sorted).ShowSegment;
    };
    ValueAxis: ChartAxis;
    ChartSeries {
      Label: "All Languages";
      (each sorted).NormalFrequency;
    };
    ChartSeries {
      Label: "Experiment";
      (each sorted).UsedFrequency;
    };
  };

  AddTree = TextBlock {
    Span {
      Variable("Tree");
      Quote;
      Newick(Info.PriorTree);
      ";"; Quote; ",";
    };
  };

  AddScope = TextBlock {
    IndentSpace: 2;
    Begin: "{";
    End: "}";
  };

  AddWord(WordClass word, last) = Span {
    "  {";
    Variable("Taxon");
    var n = word.Language.GlobalVariableName;
    ShowString(n);
    CommaSpace;
    Space*(MaxLanguageName - n.Length);
    Variable("Segments");
    "[";
    Span {
      Separator: CommaSpace;
      (each word.Padded).CharacterIndex;
    };
    Span {
      "]}";
      if (not last)
         ",";
    };
  };

  AddCognate(CognateClass cognate, last) = TextBlock {
    Span {
      "{";
      Variable("Name");
      ShowString(cognate.GetTitle);
      CommaSpace;
      Variable("Data"); "[";
    };

    TextBlock {
      var good = cognate.Words.FindSlice(w => valid w.Aligned);
      var lg   = good.Length-1;
      foreach (var word in good)
        AddWord(word, EachIndex == lg);
    };

    Span {
      "]}";
      if (not last)
        Comma;
    };
  };

  ConfigFile = AddScope {
    Style.MonoFamily;
    TextHeight: 9 pts;

    AddTree;
    TextBlock {
      Span {Variable("NumberOfStates"); UniqueCharacters; CommaSpace};

      Span {Variable("McmcSettings"); "{"};
        Span {Variable("OnlyCompleteWords"); ShowString("No"); Comma};
        Span {Variable("Model"); ShowString("Custom"); Comma};
        Span {Variable("CalcMarginal"); ShowString("No"); Comma};
        Span {Variable("UseEigenSystem"); ShowString("No"); Comma};
        Span {Variable("NumCycles"); Info.Generations; Comma};
        Span {Variable("PrintFreq"); Info.PrintFreq; Comma};
        Span {Variable("SampleFreq"); 100; Comma};
        Span {Variable("TreeLengthPriorVal"); 0.15};
      "},";
    };

    ArraySpan("Taxa") {
      Separator: CommaSpace;
      ShowString(each (each Taxa).Variable);
    };

    ArraySpan("PriorFrequencies") {
      Span {
        TextDigits: 6;
        Separator: Comma;
        (each UniqueSegments).NormalFrequency;
      };
    };

    ArraySpan("PartitionSets") {
      Span {
        Separator: Comma;
        foreach (var partition in PartitionRule.Partitions) {
          Span {
            "{";
            Variable("Name");
            ShowString(partition.Filter.Name);
            CommaSpace;
            Variable("Set");
            "[";
            Span {
              Separator: CommaSpace;
              (each partition.Segments).CharacterIndex;
            };
            "]}";
          }
        }
      };
    };

    Span {
      Variable("Words"); "[";
    };
    TextBlock {
      var last = UsedCognates.Length-1;
      foreach (var cognate in UsedCognates)
        AddCognate(cognate, EachIndex == last);
    };
    "]";
  };

  RevBayesSource = TextBlock {
    Style.MonoFamily;
    BlockComment("RevBayes Source File for Linguistomics Project");

    "clear()";
//    "setwd({0})"(ShowString(folder));
    "path = " ShowString(Info.OutFolder Folder("/"));
    "gammapath = {0}"(PathPlus(Info.GammaTrees));


    LineComment("Read in discrete character data");
    "data = readDiscreteCharacterData({0})"(PathPlus(Info.CharacterName));

    LineComment("Get some useful variables from the data. We need these later on");
    "num_taxa <- data.ntaxa()";

    LineComment("Number of branches in an rooted tree");
    "num_branches <- 2 * num_taxa - 2";

    "taxa <- data.taxa()";

    LineComment("Create helper variables");
    "moves    = VectorMoves()";
    "monitors = VectorMonitors()";

    BlockComment("Tree Model");
    LineComment("Outgroup is a clade consisting of one language");
    "out_group = clade({0})"(ShowString(Results.Taxa[0].Language));

    LineComment("Prior distribution on the tree topology");
    "topology ~ dnUniformTopology(taxa, outgroup=out_group, rooted=TRUE)";

    LineComment("These are moves that change the tree topology");
    "moves.append(mvNNI(topology, weight=num_taxa/2.0))";
    "moves.append(mvSPR(topology, weight=num_taxa/10.0))";

    LineComment("Branch length prior");

    "for (i in 1:num_branches) {";
    "  bl[i] ~ dnExponential(10.0)";
    "  moves.append(mvScale(bl[i]))";
    "}";
    Empty;
    "TL  := sum(bl)";
    Empty;
    "psi := treeAssembly(topology, bl)";
    Empty;

    BlockComment("Substitution Model");
    LineComment("This is the number of unique characters from the segment filters");
    "unique_chars = {0}"(UniqueCharacters);

    switch (Model) {
      case Models.JC:
        LineComment("Jukes-Cantor model");
        "Q <- fnJC(unique_chars)";
        break;

      case Models.MK:
        LineComment("Mk model");
        LineComment("I'm guessing completely with this number");
        "rate_pr <- 10.0";
        Empty;
        "rate_parameter ~ dnExponential(rate_pr)";
        Empty;
        Empty;
        "moves.append(mvScale(rate_parameter, weight=2))";
        Empty;
        "for (i in 1:unique_chars) {";
        "  for (j in 1:unique_chars) {";
        "    m[i][j] := rate_parameter";
        "  }";
        "}";
        Empty;
        "Q := fnFreeK(m, rescale=TRUE)";
        break;
    }

    BlockComment("Gamma model for among-site variation");

    "alpha ~ dnUniform(0, 10.0)";
    "moves.append(mvScale(alpha, weight=1))";

    "site_rates := fnDiscretizeGamma(alpha, alpha, 4)";

    BlockComment("PhyloCTMC Model");
    "seq ~ dnPhyloCTMC(tree=psi, Q=Q, type={0}, siteRates=site_rates)"(ShowString("Standard"));
    "seq.clamp(data)";

    BlockComment("Analysis");

    LineComment("You can use any node as the argument of model()");
    "mymodel = model(psi)";
    "n_gen   = {0}"(Math.Min([100, Math.Max([10, Info.Generations div 1000])]));

    LineComment("This prints monitors to the screen");
    Span {
      "monitors.append(mnScreen(TL, ";
      if (Model == Models.MK)
        "rate_parameter, ";
      "printgen=n_gen))";
    };

    LineComment("This monitors the trees and puts them in a file");
    "monitors.append(mnFile(psi, filename=gammapath, printgen=n_gen))";

    LineComment("Model monitor");
    "monitors.append(mnModel(filename={0}, printgen=n_gen))"(PathPlus(Info.GammaLog));

    "mymcmc = mcmc(mymodel, moves, monitors, nruns=1, combine={0})"(ShowString("mixed"));


//   "mymcmc.burnin(generations={0}, tuningInterval=200)"(Info.Generations);
    "mymcmc.run(generations={0})"(Info.Generations);

    LineComment("Summarizes the MCMC runs");
    "mymcmc.operatorSummary()";

    BlockComment("Post processing");
    "treetrace      = readTreeTrace(gammapath, outgroup=out_group)";
    "consensus_tree = consensusTree(treetrace, {0})"(PathPlus(Info.ConsensusName));
//    "map_tree       = mapTree(treetrace, {0})"(PathPlus(Info.MAPName));
//    "mcc_tree       = mccTree(treetrace, {0})"(PathPlus(Info.MCCName));

    LineComment("Exit the program");
    "q()";
  };

  CharacterFile(paper) = NexusFile {
    var maxlength = MaxNameLength;
    var ntax      = Taxa.Length;

    TabStops: [4 inches];

    Scope("taxa") {
      AddLine("dimensions") {
        AddValue("ntax", ntax);
      };
      AddLine("taxlabels") {
        AddTaxon(each Taxa);
      };
    };

    Scope("characters") {
      AddLine("dimensions") {
        AddValue("ntax", ntax);
        AddValue("nchar", TotalLength);
      };
      AddLine("format") {
        AddValue("datatype", "STANDARD");
        AddValue("interleave", "yes");
        AddValue("respectcase");
        AddValue("gap", IPA.Segments.GapSegment.Ipa);
        AddValue("missing", IPA.Segments.MissingSegment.Ipa);
        AddValue("symbols", Span {Quote; CharacterList[0..<Math.Min([UniqueCharacters, Rev.CharacterList.Length])]; Quote});
      };

      Empty;
      Keyword("matrix");

      foreach (var cognate in UsedCognates) {
        if (EachIndex > 0)
          Empty;

        Comment(cognate.Name);
        WriteTaxa(cognate, paper, maxlength);
      }
      EndMarker;
    };
  };

  MaxNameLength = Math.Max((each ((each Taxa).Variable)).Length) + 1;

  WriteTaxa(CognateClass cognate, paper, maxlength) = TextBlock {
    foreach (var taxon in Taxa) {
      var words = cognate.Words[taxon.Index];
      Span {
        taxon.Variable;
        Space * (maxlength - taxon.Variable.Length);
        foreach (var segment in words.Padded)
          segment.ShowCharacter;

        switch (paper) {
          case 0:
            break;

          case 1:
            break;

          case 2:
            Span {
              CommentFormat;
              Style.IPAFamily;
              Tab;
              foreach (var segment in words.Padded)
                segment.ShowBlock;
            };
            break;
        }
      };
    }
  };

  ShowWordsForEachSegment = Block {
    foreach (var segment in SortedSegments) {
      Paragraph {
        TabStops: [0.5 inches, DocMetrics.PageContent.Width {Type: TabTypes.Right}];
        KeepWithNext: true;
        TextHeight: 16 pts;
        ParBackground: 90%;

        segment.ShowSegment;
        Tab;
        segment.ShowCodePoint
        Tab;
        segment.ShowCharacter;
      };

      Paragraph {
        ParAlignment: ParAlignments.Justify;
        Style.IPAFamily;
        SpaceAfter: 10 pts;
        Span {
          Separator: Space*2;
          foreach (var cognate in UsedCognates) {
            foreach (var word in cognate.Words) {
              if (word.Segments.FindAny(segment)) {
                Span {
                  Hover: new HoverClass(word, HoverTypes.Tip);
                  word.Plain;
                }
              }
            }
          }
        };
      };
    }
  };
}
}
//======================================================================

