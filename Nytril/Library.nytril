using Format, Units, Math, IO, LinkTypes, WorldLanguages;

//======================================================================

class AlignDataClass {
  var Prob,
      WordSet;

  Constructor(prob, wordset) {
    Prob    = prob;
    WordSet = wordset;
  }

  override GetLayoutTip = Span {
    TextDigits: 2;
    "{0}% probability"(Prob*100);
  };
}

//======================================================================

class AlignIndexClass {
  var                  ConceptName,
                       CognateName;
  var CognateClass     Cognate;
  var AlignDataClass[] Alignments;

  Constructor(concept, cognate, AlignDataClass[] alignments) {
    ConceptName = concept;
    CognateName = cognate;
    Alignments  = alignments;
  }
}

//======================================================================

class StatClass {
  var Lower,
      Mean,
      Upper;

  Constructor(lower, mean, upper) {
    Lower = lower;
    Mean  = mean;
    Upper = upper;
  }

  ShowRight(number) = HBox {
    Space*2;
    TextHeight: 80%;
    TextColor: Colors.Gray;
    number;
  };

  ShowBox = VBox {
    Bracket: Brackets.Curly;
    TextDigits: 3;
    ShowRight(Upper * 100.0);
    Mean * 100.0;
    ShowRight(Lower * 100.0);
  };

  override GetLayoutTip = ShowBox;
}

//======================================================================

RateDescriptor(text) = Span {
  text;
//  Tex.Minus; "Log" sub 10; "("; text; ")";
};

//======================================================================

class AlignPairClass: DocumentClass {
  var DataSetClass    Data;
  var AlignIndexClass Cognate;
  var SizeClass       BoxSize;

  Constructor(DataSetClass data, AlignIndexClass cognate) {
    super.Constructor(guid.FromHash("Align" + cognate.CognateName), cognate.ConceptName);

    Data    = data;
    Cognate = cognate;
    BoxSize = new SizeClass(14 pts, 14 pts);
    if (cognate.CognateName != DefaultCognate)
      Name += "-" + cognate.CognateName;
  }

  Languages(data, height) = VBox {
    HAlign: HAligns.Right;
    HBox(null, height);

    foreach (var taxon in data.Taxa) {
      HBox(null, height) {
        VAlign: VAligns.Center;
        taxon.Language;
      };
    }
  };

  ShowBlock(prob, cumulative, wordset, boxheight) = VBox(null, null, new EdgeClass(0.125, 0, 50%)) {
    Margin: PadB(10 pts);
    HAlign: HAligns.Center;

    HBox(null, boxheight) {
      Span {
        TextSignificant: true;
        TextDigits: 3;
        prob * 100.0;
        if (prob != cumulative) {
          Tex.rightarrow;
          Span {
            TextColor: Colors.Gray;
            cumulative * 100.0;
          };
        }
      }
    };

    VBox {
      foreach (var taxon in Data.Taxa) {
        HBox(null, boxheight) {
          var word = wordset[each0];
          if (word is valid) {
            foreach (var c in word) {
              Canvas(BoxSize.Width, BoxSize.Height) {
                HAlign: HAligns.Center;
                SegPartClass part;
                if (c == -1)
                  part = IPAParts.Gap;
                else if (c >= 0 and c < Data.UniqueSegments.Length) {
                  part = Data.UniqueSegments[c];
                  Background: part.Partition.Color;
                  TextColor: part.Partition.TextColor;
                }
                else
                  part = IPAParts.Missing;
                part.ShowSegment(false);
              };
            }
          }
        };
      }
    };
  };

  override GetLayoutTip = ShowDetails(9, true, 10 pts);

  override GetDocument = ShowDetails(5000, true, 10 pts);

  GetChart(SizeClass size, max) = Chart(size.Width, size.Height) {
    Type: ChartTypes.Column;
    TextHeight: 6 pts;
    ValueLabel: "%";
    ChartSeries {
      foreach (var a in Cognate.Alignments) {
        new DataPointClass(each0, a.Prob * 100.0) {Reference: a.Prob};
        if (each1 >= max)
          break;
      }
    };
  };

  ShowDetails(max, tip, textheight) = Block {
    TextHeight: textheight;

    Paragraph(null, [3 inches]) {
      KeepWithNext: true;
      TextHeight: textheight + 4 pts;
      SpaceAfter: 10 pts;
      Name;
    };

    if (Cognate.Alignments.Length > 1)
      GetChart(new(3 inch, 0.75 inch), max);

    var langbox = Languages(Data, BoxSize.Height);
    var indent  = GetLayoutSize(langbox).Width;
    Paragraph {
      if (tip) {
        langbox;
        Space;
      }
      else {
        LeftIndent: indent;
        FirstIndent: -indent;
        Tab;
        langbox;
      }

      ShowBlocks(max, BoxSize.Height);
    }
  };

  ShowBlocks(max, boxheight) = Span {
    var cumulative = 0.0;
    foreach (var a in Cognate.Alignments) {
      var prob = a.Prob;
      cumulative += prob;
      var wordset = a.WordSet;
      if (wordset.Length > 0) {
        ShowBlock(prob, cumulative, wordset, boxheight);
        "   ";
        if (each1 >= max)
          break;
      }
    }
  };

  ShowFigureDetails(DataSetClass data, max) = Block {
    var h = 8 pts;
    BoxSize = new(BoxSize.Width, h);
    TextHeight: 7 pts;
    Frame(ExtentWidth - 1 inches) {
      Span {
        GetChart(new(1 inch, data.Taxa.Length * (9 pts)), max);
        Languages(Data, h);
        ShowBlocks(max, h);
      }
    };
  };

  ShowFigureData(AlignIndexClass index, AlignDataClass align) = Frame {
    var h = 8 pts;
    BoxSize = new(BoxSize.Width, h);
    Paragraph {
      SpaceBefore: 6 pts;
      TextHeight: 12 pts;
      index.Cognate.GetTitle;
    };

    Paragraph {
      TextHeight: 7 pts;
      Span {
        Languages(Data, h);
        ShowBlock(align.Prob, align.Prob, align.WordSet, h);
      }
    };
  };
}

//======================================================================

class CognateIdClass {
  var Concept,
      Cognate,
      Count;

  Constructor(concept, cognate, count) {
    Concept = concept;
    Cognate = cognate ?? DefaultCognate;
    Count   = count;
  }
}

//======================================================================

class AlignmentChartClass {
  var DataSetClass      Data;
  var AlignIndexClass[] Alignments;

 Constructor(ResultsClass results) {
    Data       = results.Data;
    Alignments = results.Alignments;
  }

  ShowChart(SizeClass size) = VBox(size.Width, size.Height, 0.5) {
    // Try to make proportional squares
    var xitems = size.Width / 130 as int;
    var yitems = Math.Floor((Alignments.Length + xitems - 1) / xitems);
    var bsize  = new SizeClass(size.Width / xitems, size.Height / yitems);
    AlignIndexClass[][] rows = Alignments / xitems;

    TextHeight: Math.Min(8 pts, bsize.Height - 3.2 pt);

    foreach (var row in rows) {
      HBox {
        foreach (var a in row) {
          VBox(bsize.Width, bsize.Height, new EdgeClass(0.25 pts, 1, 90%)) {
            HAlign: HAligns.Center;

            var ap = new AlignPairClass(Data, a);
            Paragraph {
              Span {
                ap.Name;
                TipAction: ap;
              };
            };
            Paragraph {
              TextColor: Colors.LightGray;
              a.Alignments.Length;
            };
          }
        }
      }
    }
  };

  ShowAll = Block {
    foreach (var a in Alignments) {
      new AlignPairClass(Data, a).ShowDetails(5, false, 10 pts);
      Paragraph(BorderT(1));
    }
  };

  ShowSet(DataSetClass data, CognateIdClass[] examples) = MatrixBlock {
    var alignments = Alignments;

    foreach (var e in examples) {
      var found = null;
      foreach (var a in alignments) {
        if (a.ConceptName == e.Concept && a.CognateName == e.Cognate) {
          found = a;
          break;
        }
      }

      if (found is valid) {
        var ap = new AlignPairClass(data, found);
        Row {
          VAlign: VAligns.Top;
          Frame(0.75 inch, null, PadR(10 pts)) {
            e.Concept;
            e.Cognate Italic;
          };
          Frame(ExtentWidth) {
            ap.ShowFigureDetails(data, e.Count);
          }
        }
      }
    }
  };
}

//======================================================================

class LanguageClass: FactClass {
  field string   Name;
  var ImageClass Image;
  var int        Cases;
  var string     ShortName;
  var int        LangIndex;
  var            ImagePath;

  Constructor(id, name, cases=0, imagepath=null) {
    super.Constructor(id);
    Name      = name;
    ShortName = name.Replace(" ", Empty);
    Cases     = cases;
    ImagePath = imagepath;
  }

  override IconClass GetIcon = Icons.language;

  virtual Description(ContentStyleClass style) = null;
  virtual Details(ContentStyleClass style) = null;

  override GetLayoutSpan = Span {
    TipAction: this;
    Name;
  };

  ShowMap(width, height) {
    if (ImagePath is null)
      return null;

    Image ??= new ImageClass(ImagePath);
    return FitBox(Image, width, height);
  }

  override GetLayoutTip = Block {
    Paragraph {
      Bold;
      TextHeight: 14 pts;
      Name;
      var r = FindFacts(ReferenceClass);
      if (r is valid)
        Citation {r};
    };
    Description(ContentStyleClass.TipStyle);
    ShowMap(4 inches, 2 inches);
  };
}

//======================================================================

class WordClass: FactClass {
  field string       Text;
  var LanguageClass  Language;
  var TaxonClass     Taxon;
  var CognateClass   Cognate;
  var SegPartClass[] Segments,
                     Aligned,
                     Padded;
  var                Variable;

  Constructor(id, text, TaxonClass taxon, CognateClass cognate) {
    super.Constructor(guid.FromHash(id));
    Text     = text;
    Taxon    = taxon;
    Language = taxon.Language;
    Cognate  = cognate;
  }

  void Init {
    Segments = [];
    Aligned  = [];
  }

  ShowPlain = Span {
    Action: new ActionClass(Actions.ToSource, Variable);
    foreach (var c in Text) {
      if (c != IPASegments.GapSegment.Ipa and c != IPASegments.PrimaryStress.Ipa)
        c;
    }
  };

  void InitRaw(variable, SegPartDictionary lookup) {
    // IPA text and word text must be in the same unicode normaization form so comparisons are accurate
    Variable = variable;

    if (Text is valid) {
      Text = (Text as string).Normalize(NormalizationForms.FormC);

      var segments = lookup.FindTokens(Text, IPA.NullSegment);
      Aligned  = segments.FindSlice(s => s.Segment.Gap or (not s.Punctuation));
      Segments = segments.FindSlice(s => not s.Punctuation);

      foreach (var s in Segments)
        s.Index = each0;

      // Test that the word's text is the same as the segments converted back into text
      var view = Span {(each segments).Ipa};
      System.Assert(Text == (view as string), "Round-trip error with text {0}-{1}"(Text, view), Text);
      Connect;
    }
    else
      Init;
  }

  void InitExperiment(variable, SegPartClass[] segments) {
    Variable  = variable;
    Aligned   = segments;
    Padded    = segments;
    Segments  = segments.FindSlice(s => not s.Punctuation);
    Connect;
  }

  void Connect {
    Link.Connect(this, Segments);
    Link.Connect(this, (each Segments).Segment);
    Link.Connect(this, Cognate);
    Link.Connect(this, Language);
    Link.Connect(Language, Cognate);
  }

  override IconClass GetIcon = Icons.text_snippet;

  override GetLayoutSpan = Span {
    foreach (var s in Segments) {
      if (!s.Punctuation)
        s.Ipa;
    }
  };

  ShowPaddedBlocks(textheight, index=-1) = HBox {
    TextHeight: textheight;

    foreach (var segment in Padded) {
      HBox(textheight*1.125, null, BorderL(new(0.125 pts, 0, 80%))) {
        HAlign: HAligns.Center;
        if (index == each0)
          Background: Colors.LightYellow;
        segment.ShowSegment;
      };
    }
  };

  FieldPar(name) = Paragraph(null, [0.5 inches]) {
    Bold name;
    Tab;
  };

  override GetLayoutTip = Block {
    FieldPar(Lang.Language) {
      Language;
    };
    FieldPar(Lang.Cognate) {
      Cognate.GetTitle;
    };
    FieldPar(Lang.Segments) {
      Frame(null, null, 0.5) {
        ShowPaddedBlocks(16 pts);
      }
    }
  };

  override GetLayoutFact = Block {
    Paragraph(null, [1 inch, 2 inch, 3 inch, 4 inch]) {
      GetIcon;
      Space;
      Quote;
      ShowPlain;
      Quote;
      Tab;
      Language;
      ColonSpace;
      Cognate.GetTitle;
    };
    super.GetLayoutFact;
  };
}

//======================================================================

class ConceptClass: FactClass {
  field string       Name;
  field double       Confidence;
  var AttributeClass Attribute;
  var                Variable;
  var WordTypes      WordType;
  var WordGroups     WordGroup;

  Constructor(AttributeClass a) {
    super.Constructor(guid.FromHash(a.FullName));
    Attribute = a;
    Variable  = a.Value;
    Name      = a.Name;
  }

  void CheckRaw {
    var v = Attribute.Value;
    Confidence = v.Confidence;
    WordType   = v.WordType;
    WordGroup  = v.WordGroup;

    System.Assert(Confidence > 0);
    System.Assert(WordType != WordTypes.None);
    System.Assert(WordGroup != WordGroups.None);
  }

  override IconClass GetIcon = Icons.category;

  override GetLayoutTip = Span {Name; "-"; Confidence};

  override int Compare(c) {
    return Name.Compare(c.Name);
  }
}
//======================================================================

class CognateClass: FactClass {
  field string       Name;
  var ConceptClass   Concept;
  var WordClass[]    Words;
  var                MaxLength;
  var AttributeClass Attribute;

  Constructor(ConceptClass concept, AttributeClass a) {
    super.Constructor(guid.FromHash(a.FullName));

    Name      = a.Name;
    Attribute = a;
    Concept   = concept;
    MaxLength = 0;

    Link.Connect(this, concept);
  }

  override IconClass GetIcon = Icons.format_list_bulleted;

  GetSource = Concept.Name + '-' + Name;

  GetTitle = Span {
    Concept.Name; '-'; Name;
    Action: new ActionClass(Actions.ToSource, Attribute);
  };

  override int Compare(c) {
    var i = Concept.Compare(c.Concept);
    if (i == 0)
      return Name.Compare(c.Name);
    return i;
  }
}
//======================================================================

class TaxonClass {
  var               ShortName,
                    Index,
                    WordCount,
                    SegmentCount;
  var LanguageClass Language;

  Constructor(LanguageClass language) {
    Index        = each0;
    Language     = language;
    ShortName    = language.ShortName;
    WordCount    = 0;
    SegmentCount = 0
  }

  override GetLayoutTip = Span {
    PaperStyle.TaxonFormat;
    Language.Name;
    TipAction: Language;
  };
}
//======================================================================

class WordPairClass {
  var           Index;
  var WordClass Word1,
                Word2;

  Constructor(index, WordClass w1, WordClass w2) {
    Index = index;
    Word1 = w1;
    Word2 = w2;
  }

  ShowDescription(textheight) = Frame(null, null, 0.25 pts) {
    TextHeight: textheight;
    Paragraph {
      ParBackground: 90%;
      Bold;
      Span {
        Word1.Cognate.Attribute.FullName[9..];
        Action: new ActionClass(Actions.ToSource, Word1.Cognate.Attribute);
      }
    };

    Word1.ShowPaddedBlocks(textheight, Index);
    Word2.ShowPaddedBlocks(textheight, Index);
  };

  override GetLayoutTip = ShowDescription(12 pts);
}

//======================================================================

class DataSetClass {
  var LanguageClass[]             LanguageSet;
  var SegPartClass[]              UniqueSegments;
  var CognateClass[]              SortedCognates;
  var ListClass<ConceptClass>     UsedConcepts;
  var ListClass<CognateClass>     UsedCognates;
  var TaxonClass[]                Taxa;
  var StringDictionaryClass<TaxonClass> TaxonSet;
  var VectorClass                 WordList;
  var RuleClass                   Rule;
  var WordClass                   DefWord;
  var TreeSetClass[]              TreeSets;
  var ListClass                   PlainBuffer,
                                  TextBuffer;
  var ListClass<SegPartClass>     SegmentBuffer;
  var RunExperimentClass          MainRun;
  var AttributeClass              ExampleConcept,
                                  FigureConcept,
                                  DataConcept;
  var                             WordCutoff,
                                  RootFolder,
                                  Name,
                                  MaxLanguageName,
                                  WordCount,
                                  SegmentCount,
                                  WordFile;
  var bool                        RawData;

  Constructor(config, name, rootfolder, runindex) {
    Name            = name;
    RootFolder      = Folder(rootfolder);
    WordFile        = RootFolder Info.WordFileName;
    WordCount       = 0;
    SegmentCount    = 0;
    MaxLanguageName = 0;
    TextBuffer      = new(64);
    PlainBuffer     = new(64);
    SegmentBuffer   = new(64);
    Rule            = new NaturalPartitionClass;
    TreeSets        = AddTree(config, each PriorTrees);
    MainRun         = TreeSets[0].Custom.Run[runindex];

    if (config is null)
      ReadExperiment;
  }

  TreeSetClass AddTree(config, NodeClass root) = new(config, "Tree"+each1, RootFolder, root);

  void ReadRawWords(AttributeClass concepts, includewords, LanguageClass[] languageset, cutoff=-1) {
    RawData = true;

    if (cutoff < 0)
      cutoff = languageset.Length;
    WordCutoff = cutoff;

    AddLanguageSet(languageset);
    UsedCognates = new(1024);
    UsedConcepts = new(256);

    foreach (var cvar in concepts.Children) {
      var conceptvar = cvar.Value;
      var good       = exists conceptvar.?Confidence and
                       exists conceptvar.?WordType and
                       exists conceptvar.?WordGroup;
      System.Assert(good, "Improper concept", conceptvar);

      if (good and conceptvar.Confidence > 0 and conceptvar.WordGroup.HasFlag(includewords)) {
        foreach (var cc in cvar.Children) {
          var vname = cc.Name;
          if (vname != "Confidence" && vname != "WordType" && vname != "WordGroup") {
            var count = 0;
            foreach (var wc in cc.Children) {
              var word = wc.Value;
              if (word is valid) {
                var taxon = TaxonSet.GetValue(wc.Name);
                if (taxon is valid)
                  ++count;
              }
            }

            if (count >= cutoff) {
              var concept = new ConceptClass(cvar);
              concept.CheckRaw;
              UsedConcepts.Add(concept);
              UsedCognates.Add(new(concept, cvar));
            }
          }
        }
      }
    }

    UsedConcepts.Sort(false);

    var lookup = new SegPartDictionary(IPASegments.Length);
    foreach (var segment in IPASegments) {
      if (segment.Ipa is valid)
        lookup.Add(new SegPartClass(segment), segment.Ipa);
    }

    foreach (var cognate in UsedCognates)
      ComputeRawCognate(lookup, cognate);

    var set = new SegmentSetClass(512);
    foreach (var cognate in UsedCognates) {
      foreach (var word in cognate.Words) {
        foreach (var segment in word.Segments) {
          if (!segment.Punctuation)
            set.Add(segment);
        }
      }
    }
    UniqueSegments = set.ToArray;

    GetConceptExamples(concepts);
    CompletedRead;
  }

  void ReadExperiment {
    var run = ReadScript(Info.ExperimentRoot WordFile).Root;

    WordCutoff  = run.Info.WordCutoff;
    AddLanguageSet(run.LanguageSet);

    var slist  = new ListClass<SegPartClass>(run.Segments.Length);
    var lookup = new StringDictionaryClass<SegmentClass>(IPASegments.Length);
    foreach (var segment in IPASegments) {
      if (segment.Ipa is valid)
        lookup.Add(segment, segment.Ipa);
    }

    foreach (var text in run.Segments) {
      var s = lookup.GetValue(text);
      if (s is valid)
        slist.Add(new SegPartClass(s));
      else
        System.Assert(false, "Missing Segment " + text);
    }

    UniqueSegments = slist.ToArray;

    var concepts = attribute(run.Concepts);
    UsedConcepts = new(concepts.Length);
    UsedCognates = new(concepts.Length * 2);

    foreach (var cvar in concepts.Children) {
      var concept = new ConceptClass(cvar);
      UsedConcepts.Add(concept);

      foreach (var cognatevar in cvar.Children) {
        var cognate = new CognateClass(concept, cognatevar);
        UsedCognates.Add(cognate);
        ComputeExperimentCognate(cognate, cognatevar);
      }
    }

    GetConceptExamples(concepts);
    CompletedRead;
  }

  void AddLanguageSet(LanguageClass[] languageset) {
    LanguageSet = languageset;
    TaxonSet    = new(LanguageSet.Length);

    ListClass<TaxonClass> tlist = new(LanguageSet.Length);

    foreach (var l in LanguageSet) {
      l.LangIndex = each0;

      var taxon = new TaxonClass(l);
      var name  = l.ShortName;
      tlist.Add(taxon);
      TaxonSet.Add(taxon, name);
      if (name.Length > MaxLanguageName)
        MaxLanguageName = name.Length;
    }
    Taxa     = tlist.ToArray;
    WordList = new(Taxa.Length, null);
    DefWord  = new WordClass(#71f32657-a37c-4f1d-abba-87b928e9d80b#, Empty, Taxa[0], null);
    DefWord.Init;
  }

  virtual void GetConceptExamples(AttributeClass concepts) {
    ExampleConcept = concepts.FindChild("Stone");
    FigureConcept  = concepts.FindChild("What");
    DataConcept    = concepts.FindChild("Mountain");
  }

  void CompletedRead {
    var factor = 1.0 / SegmentCount;
    foreach (var segment in UniqueSegments) {
      segment.Index         = each0;
      segment.UsedFrequency = factor * segment.UsedCount;
    }

    Rule.Init(UniqueSegments);
  }

  Coverage(TaxonClass taxon) {
    var index = taxon.Index;
    var count = 0.0;
    var used  = 0.0;
    foreach (var c in UsedCognates) {
      var word = c.Words[index];
      if (word is valid and word.Text is valid)
        ++used;

      ++count;
    }
    return used / count;
  }

  CoverageByLanguages {
    var count = new VectorClass(Taxa.Length+1, 0.0);
    foreach (var c in UsedCognates) {
      var used = 0;
      foreach (var word in c.Words) {
        if (word is valid and word.Text is valid)
          ++used;
      }
      count.AddValue(used, 1.0);
    }
    return count;
  }

  CognateClass[] GetSortedCognates {
//    SortedCognates ??= UsedCognates.ToSortedArray(false);

    SortedCognates ??= UsedCognates.ToArray;
    return SortedCognates;
  }

  CognateClass GetCognate(AttributeClass concept) = UsedCognates.FindFirst(c => c.Concept.Name == concept.Name);

  void ComputeRawCognate(SegPartDictionary lookup, CognateClass cognate) {
    WordList.SetAllValues(DefWord);
    var maxlength = 0;
    foreach (var cvar in cognate.Attribute.Children) {
      foreach (var tvar in cvar.Children) {
        var text  = tvar.Value;
        var taxon = TaxonSet.GetValue(tvar.Name);
        if (taxon is valid) {
          var word = new WordClass(text+cognate.Concept.Name+cognate.Name+taxon.ShortName, text, taxon, cognate);
          word.InitRaw(text, lookup);
          maxlength = Math.Max(maxlength, word.Aligned.Length);

          int count = 0;
          foreach (var s in word.Segments) {
            if (s.Index >= 0)
              ++count;
          }

          SegmentCount       += count;
          taxon.SegmentCount += count;
          WordList.SetValue(taxon.Index, word);
        }
      }
    }

    cognate.Words     = WordList.ToArray;
    cognate.MaxLength = maxlength;

    foreach (var word in cognate.Words) {
      var a = word.Aligned;
      if (a is valid) {
        if (a.Length < maxlength)
          word.Padded = a + [IPAParts.Gap] * (maxlength - a.Length);
        else
          word.Padded = a;
      }
      else
        word.Padded = a;
    }

    for (var i = 0; i < maxlength; ++i) {
      var count    = 0;
      var gapcount = 0;

      foreach (var word in cognate.Words) {
        if (word.Aligned is valid) {
          ++count;
          if (word.Padded[i] == IPAParts.Gap)
            ++gapcount;
        }
      }
      System.Assert(gapcount < count, "Column with all gaps", cognate.Attribute);
    }
  }

  void ComputeExperimentCognate(CognateClass cognate, AttributeClass cognatevar) {
    WordList.SetAllValues(DefWord);

    var maxlength = 0;
    foreach (var word in cognatevar.Value) {
      if (word is valid) {
        var taxon = Taxa[each0];
        if (taxon is valid) {
          ++taxon.WordCount;
          ++WordCount;

          TextBuffer.Clear();
          PlainBuffer.Clear();
          SegmentBuffer.Clear();

          var gs    = IPAParts.Gap;
          var gap   = gs.Ipa[0];
          var count = 0;
          foreach (var index in word) {
            if (index < 0) {
              TextBuffer.Add(gap);
              SegmentBuffer.Add(gs);
            }
            else {
              var s = UniqueSegments[index];
              SegmentBuffer.Add(s);
              foreach (var c in s.Ipa) {
                TextBuffer.Add(c);
                PlainBuffer.Add(c);
              }
              ++s.UsedCount;
              ++count;
            }
          }

          SegmentCount       += count;
          taxon.SegmentCount += count;


          var text = Span {TextBuffer.ToArray} as string;
          var w    = new WordClass(text+cognate.Concept.Name+cognate.Name+taxon.ShortName, text, taxon, cognate);
          w.InitExperiment(word, SegmentBuffer.ToArray);
          if (w.Aligned.Length > maxlength)
            maxlength = w.Aligned.Length;
          WordList.SetValue(taxon.Index, w);
        }
      }
    }

    cognate.Words     = WordList.ToArray;
    cognate.MaxLength = maxlength;
  }

  ShowWord(SegPartClass segment) = Block {
    Paragraph(BorderB(1)) {
      SpaceBefore: 10 pts;
      TextHeight: 14;
      "Words containing \"{0}\""(segment.Ipa);
    };
    Paragraph {
      Separator: Space;
      foreach (var cognate in UsedCognates) {
        foreach (var word in cognate.Words) {
          if (word.Segments.FindElementIndex(segment) >= 0)
            word.ShowPlain;
        }
      }
    };
  };

  virtual NodeClass PortugueseClade    = new Leaf(Portuguese);
  virtual NodeClass PortugueseNumbered = new NLeaf(Portuguese, 2);

  CatalanClade = new Branch {
    new Leaf(Catalan);
    new Branch {
      new Leaf(French);
      new Leaf(Walloon);
    };
  };

  NodeClass NumberedTree = new NBranch(19) {
    new NLeaf(Latin, 7);
    new NBranch(18) {
      new NLeaf(Romanian, 6);
      new NBranch(17) {
        new NBranch(16) {
          new NBranch(15) {
            new NLeaf(Walloon, 3);
            new NLeaf(French, 3);
          };
          new NBranch(14) {
            new NBranch(13) {
              PortugueseNumbered;
              new NLeaf(Spanish, 2);
            };
            new NLeaf(Catalan, 3);
          }
        };
        new NBranch(11) {
          new NLeaf(Friulian, 4);
          new NLeaf(Italian, 4);
        };
      }
    }
  };

/*
  NodeClass Tree0 = new Branch {
    new Leaf(Languages.Latin);
    new Branch {
      new Leaf(Languages.Italian);
      new Branch {
        new Branch {
          new Leaf(Languages.Spanish);
          PortugueseLeaf;
        };
        new Branch {
          new Branch {
            new Leaf(Languages.Friulian);
            CatalanClade;
          };
          new Leaf(Languages.Romanian);
        };
      }
    }
  };
*/

  virtual NodeClass[] PriorTrees = [
    // (Latin,(Romanian,(Italian,(Friulian,((Spanish,Portuguese),(Catalan,(French,Walloon)))))));
    new Branch {
      new Leaf(Latin);
      new Branch {
        new Leaf(Romanian);
        new Branch {
          new Leaf(Italian);
          new Branch {
            new Leaf(Friulian);
            new Branch {
              new Branch {
                new Leaf(Spanish);
                PortugueseClade;
              };
              CatalanClade;
            };
          }
        }
      }
    },

    // (Latin,(Romanian,((Italian,Friulian),((Spanish,Portuguese),(Catalan,(French,Walloon))))));
    new Branch {
      new Leaf(Latin);
      new Branch {
        new Leaf(Romanian);
        new Branch {
          new Branch {
            new Leaf(Italian);
            new Leaf(Friulian);
          };
          new Branch {
            new Branch {
              new Leaf(Spanish);
              PortugueseClade;
            };
            CatalanClade;
          };
        };
      };
    },

    // (Latin,(Romanian,((Spanish,Portuguese),((Catalan,(French,Walloon)),(Italian,Friulian)))));
    new Branch {
      new Leaf(Latin);
      new Branch {
        new Leaf(Romanian);
        new Branch {
          new Branch {
            new Leaf(Spanish);
            PortugueseClade;
          };
          new Branch {
            CatalanClade;
            new Branch {
              new Leaf(Italian);
              new Leaf(Friulian);
            };
          };
        };
      };
    },
  ];

  override IconClass GetIcon = Icons.science;
}

//======================================================================

typedef StatMatrix MatrixClass<StatClass>;

class ResultsClass {
  var DataSetClass      Data;
  var RuleClass         Rule;
  var AlignIndexClass[] Alignments;
  var StatMatrix        TransitionStats;
  var AlignedCountClass QRates /*,
                        AverageRates */;
  var                   AlignmentCutoff,
                        EquilibriumFrequencies;
  var                   InsertionRate, InsertionRateLow, InsertionRateHigh;
  var                   DeletionRate, DeletionRateLow, DeletionRateHigh;

  Constructor(DataSetClass data) {
    Data = data;
    Rule = data.Rule;


    var align = IO.ReadScript(data.MainRun.AlignmentFile).Root;

    QRates                 = new(this, align.QRates, false);
//    AverageRates           = new(this, align.AverageRates, true);
    EquilibriumFrequencies = align.EquilibriumFrequencies;
    AlignmentCutoff        = align.AlignmentCutoff;
    InsertionRate          = align.InsertionRateMean;
    InsertionRateLow       = align.InsertionRateLow;
    InsertionRateHigh      = align.InsertionRateHigh;
    DeletionRate           = align.DeletionRateMean;
    DeletionRateLow        = align.DeletionRateLow;
    DeletionRateHigh       = align.DeletionRateHigh;

    var ts = align?.TransitionStats;
    if (ts is not null)
      TransitionStats = StatMatrix.Convert(ts);
    else {
      var length = QRates.Length;
      var bs     = new StatClass(0, 0.5, 1);
      TransitionStats = new(length, length, bs, bs);
    }

    var alignments = new ListClass<AlignIndexClass>(1024);
    foreach (var a in align.Alignments) {
      foreach (var c in Data.UsedCognates) {
        if (c.Concept.Name == a.ConceptName and c.Name == a.CognateName) {
          a.Cognate = c;
          alignments.Add(a);
          break;
        }
      }
    }
    Alignments = alignments.ToSortedArray(false, @CompareAlignment);
  }

  static int CompareAlignment(AlignIndexClass a0, AlignIndexClass a1) {
    var c = a0.Alignments.Length.Compare(a1.Alignments.Length);
    if (c == 0)
      return a0.ConceptName.Compare(a1.ConceptName);
    return c;
  }
}

//======================================================================

abstract class CountBaseClass {
  var                VFlags,
                     MaxDigits;
  var SegPartClass[] LegendSegments;

  Constructor(DataSetClass data) {
    VFlags         = SegmentFeatures.Vowel | SegmentFeatures.Semivowel;
    LegendSegments = data.Rule.Segments;
    MaxDigits      = 3;
  }

  PartitionBox(SizeClass extentsize) = Paragraph {
    PaperStyle.SansSerif;

    var grid   = 0.125 pts;
    var gcolor = 65%;
    var border = 0.5 pts;
    var size   = extentsize - border*2;
    var length = LegendSegments.Length;
    var d      = size / (length+1);

    Canvas(null, null, border) {
      TextHeight: Math.Min(d.Height * 0.7, d.Width * 1.7 / MaxDigits);

      var y = d.Height;
      for (var i = 0; i < length; ++i) {
        var x = d.Width;
        for (var j = 0; j < length; ++j) {
          AddEntry(LegendSegments[i], LegendSegments[j], x, y, d);
          x += d.Width;
        }
        y += d.Height;
      }

      y = d.Height;
      var p = 0;
      foreach (var s in LegendSegments) {
        Canvas(d.Width, d.Height) {
          Y: y;
          Background: s.Partition.Color;
          TextColor: s.Partition.TextColor;
          HAlign: HAligns.Center;
          VAlign: VAligns.Center;
          s.ShowSegment;
        };
        if (p != s.PartitionIndex) {
          Canvas(size.Width, grid) {
            Y: y;
            Background: gcolor;
          };
          p = s.PartitionIndex;
        }
        y += d.Height;
      }

      Canvas(size.Width, d.Height) {
        var x = d.Width;
        p = 0;
        foreach (var s in LegendSegments) {
          Canvas(d.Width, d.Height) {
            X : x;
            Background: s.Partition.Color;
            TextColor: s.Partition.TextColor;
            HAlign: HAligns.Center;
            VAlign: VAligns.Center;
            s.ShowSegment;
          };
          if (p != s.PartitionIndex) {
            Canvas(grid, size.Height) {
              X: x;
              Background: gcolor;
            };
            p = s.PartitionIndex;
          }
          x += d.Width;
        }
      };
    };
  };

  abstract AddEntry(SegPartClass si, SegPartClass sj, x, y, SizeClass size);
}

//======================================================================

class PriorCountClass: CountBaseClass {
  typedef WordPairList ListClass<WordPairClass>;

  var MatrixClass<WordPairList> TMatrix;
  var                           Factor;

  Constructor(DataSetClass data) {
    super.Constructor(data);

    var count = data.UniqueSegments.Length;
    TMatrix   = new(count, count, null);
    MaxDigits = 4;

    var tmax = 1;

    foreach (var cognate in data.UsedCognates) {
      var length = cognate.Words.Length;
      for (var i = 0; i < length; ++i) {
        var pi = cognate.Words[i].Padded;
        for (var j = 0; j < length; ++j) {
          if (i != j) {
            var pj = cognate.Words[j].Padded;
            var ml = Min(pi.Length, pj.Length);
            for (var index = 0; index < ml; ++index) {
              var si = pi[index];
              var sj = pj[index];
              if (si != sj and not si.Punctuation and not sj.Punctuation) {
                var list = TMatrix[si.Index, sj.Index];
                var p    = new WordPairClass(index, cognate.Words[i], cognate.Words[j]);
                if (list is null) {
                  list = new WordPairList(128);
                  TMatrix.SetValue(si.Index, sj.Index, list);
                }
                list.Add(p);
                if (list.Length > tmax)
                  tmax = list.Length;
              }
            }
          }
        }
      }
    }
    Factor = 1.0 / tmax;
  }

  override AddEntry(SegPartClass si, SegPartClass sj, x, y, SizeClass size) {
    var value = TMatrix[si.Index, sj.Index];
    if (value is null)
      return null;

    return Canvas(size.Width, size.Height) {
      X: x;
      Y: y;
      HAlign: HAligns.Center;
      VAlign: VAligns.Center;
      TipNoPublish: true;
      TipAction: new TranActionClass(si, sj, value.ToArray, value.Length*Factor);

      var count = 0;
      foreach (var e in value) {
        var c0 = e.Word1.Padded[e.Index];
        var c1 = e.Word2.Padded[e.Index];
        if (c0.Features.HasFlag(VFlags) != c1.Features.HasFlag(VFlags))
          ++count;
      }

      var bf = count > 0 ? 0.5 * count / value.Length : 0.5 + 0.5 * value.Length * Factor;
      var bc = ColorClass.HeatMap(bf);

      Background: bc;
      TextColor: bc.TextCompliment;
      if (value.Length > 0)
        value.Length;
    };
  }
}

//======================================================================

class AlignedCountClass: CountBaseClass {
  delegate bool FindRateDelegate(RateClass r);

  var ListClass<RateClass>   RateList;
  var MatrixClass<RateClass> Matrix;
  var ResultsClass           Results;
  var RuleClass              Rule;
  var PartitionClass[]       Partitions;
  var RateClass[]            SortedRates,
                             SortByDirection;
  var double                 DiagFactor,
                             RateFactor,
                             DirFactor;
  var bool                   Symmetric;

  Constructor(ResultsClass results, rates, bool symmetric) {
    super.Constructor(results.Data);
    Results    = results;
    Symmetric  = symmetric;
    Rule       = results.Rule;
    Partitions = Rule.Partitions;

    var matrix  = MatrixClass.Convert(rates);
    var ordered = results.Data.UniqueSegments;
    var length  = LegendSegments.Length;

    System.Assert(length == matrix.Rows);
    System.Assert(length == matrix.Cols);
    System.Assert(length == ordered.Length);

    Matrix   = new(length, length, null);
    RateList = new(length * length);

    double min  = 100.0;
    double max  = -100.0;
    double dmin = 100.0;
    double dmax = -100.0;

    for (var i = 0; i < length; ++i) {
//      var jmax = symmetric ? i : length;
      for (var j = 0; j < length; ++j) {
        var r = new RateClass(this, ordered[i], ordered[j], matrix[i, j], matrix[j, i], symmetric, i == j);
        Matrix.SetValue(i, j, r);
        if (i == j) {
          dmax = Math.Max(dmax, r.Rate);
          dmin = Math.Min(dmin, r.Rate);
        }
        else {
          RateList.Add(r);
          max = Math.Max(max, r.Rate);
          min = Math.Min(min, r.Rate);
        }
      }
    }


    DiagFactor      = 1.0 / Math.Abs(Math.Max(dmin, dmax));
    RateFactor      = 1.0 / Math.Abs(Math.Max(min, max));
    DirFactor       = 1.0 / Math.Abs(max - min);
    var rl = RateList.ToArray;
    SortedRates     = rl.ToSortedArray(RateClass.SortDescending, @RateClass.CompareRate);
    SortByDirection = rl.ToSortedArray(RateClass.SortDescending, @RateClass.CompareDirection);
  }

  override AddEntry(SegPartClass si, SegPartClass sj, x, y, SizeClass size) {
    if (si.Index == sj.Index)
      return null;

    var rate = Matrix[si.Index, sj.Index];
    if (rate is not null) {
      return Canvas(size.Width, size.Height) {
        X: x;
        Y: y;
        HAlign: HAligns.Center;
        VAlign: VAligns.Center;
        TipNoPublish: true;
        TipAction: rate;
        var c = rate.RateColor;
        Span {
          TextDigits: 0;
          TextHeight: 5 pts;
          TextColor: c.TextCompliment;
          rate.Rate;
        };
        Background: c;
      };
    }
    return null;
  }

  ShowLegend(RateClass[] rates) = {
    // Show only partitions that are present in the chart
    var pmax = Partitions.Length;
    var set  = new HashSetClass(pmax);
    var list = new ListClass<PartitionClass>(pmax);
    foreach (var s in rates) {
      var i = s.S0.Partition;
      if (set.Add(i))
        list.Add(i);
      i = s.S1.Partition;
      if (set.Add(i))
        list.Add(i);
    }

    Canvas(ExtentWidth) {
      HAlign: HAligns.Center;
      Rule.ShowBlockLegend(list.ToArray, 11 pts);
    }
  };

  ShowChart(RateClass[] rates) = Chart(100%, 4 inches) {
    Type: ChartTypes.Column;
    TextHeight: 12 pts;
    ValueLabel: HBox {
      Transform: TransformClass.Rotate(90 degrees);
      TransformFit: true;
      Lang.RateFactor;
    };

    var fs = Math.Min(160.0 / rates.Length, 10 pts);
    XAxis: ChartAxis {
      Rotation: 30 degrees;
      (each rates).ShowBox(fs);
    };

    ChartSeries(Colors.Green) {
      Label: Tex.rightarrow;
      foreach (var a in rates)
        new DataPointClass(each0, a.Rate) {Reference: a};
    };
  };

  Extrema(number, top) = VBox {
    var actions = SortedRates.Slice(top ? 0..<number : (SortedRates.Length - number)..<SortedRates.Length);
    ShowChart(actions);
    Separation: 20 pts;
    ShowLegend(actions);
  };

  ShowAllRates = VBox {
    Chart(100%, ExtentHeight - 48 pts) {
      Type: ChartTypes.Scatter;
      TextHeight: 12 pts;
      TipNoPublish: true;

      ValueLabel: HBox {
        Transform: TransformClass.Rotate(90 degrees);
        TransformFit: true;
        RateDescriptor(Lang.RateFactor);
      };

      XAxis: ChartAxis {
        Rotation: 90 degrees;
        TextHeight: 7 pts;
        foreach (var sa in LegendSegments) {
          var p = Partitions[sa.PartitionIndex];
          HBox(15 pts) {
            HAlign: HAligns.Center;
            Background: p.Color;
            TextColor: p.TextColor;
            sa.Segment.Ipa;
          }
        }
      };

      ChartSeries {
        Marker: Markers.Dot;

        foreach (var si in LegendSegments) {
          var i = each0;

          foreach (var sj in LegendSegments) {
            if (si.Index != sj.Index) {
              var a = Matrix[si.Index, sj.Index];
              if (a is not null) {
                new DataPointClass(i, a.Rate) {
                  Reference: a;
                  Fill: a.S1.Partition.Color;
                };
              }
            }
          }
        }
      };
    };

    Separation: 20 pts;
    Canvas(ExtentWidth) {
      HAlign: HAligns.Center;
      Rule.ShowBlockLegend(Partitions, 10 pts);
    }
  };

  ShowRateDirected = VBox {
    Chart(100%, ExtentHeight - 48 pts) {
      TipNoPublish: true;
      Type: ChartTypes.Scatter;
      TextHeight: 12 pts;

      XLabel: RateDescriptor(Lang.RateFactor);

      ValueLabel: HBox {
        Transform: TransformClass.Rotate(90 degrees);
        TransformFit: true;
        RateDescriptor("Direction");
      };

      ChartSeries {
        TextHeight: 6 pts;
        Marker: Markers.Dot;
        foreach (var si in LegendSegments) {
          foreach (var sj in LegendSegments) {
            if (si.Index < sj.Index) {
              var a = Matrix[si.Index, sj.Index];
              new DataPointClass(a.Rate, a.Direction) {
                Reference: a;
                Marker: Canvas(4 pts, 4 pts) {
                  HAlign: HAligns.Center;
                  VAlign: VAligns.Center;
                  Background: a.S0.Partition.Color;
                  BorderRadius: 2 pts;
                  a.S1.Partition.Marker;
                };
              };
            }
          }
        }
      };
    };

    Separation: 20 pts;
    Canvas(ExtentWidth) {
      HAlign: HAligns.Center;
      Rule.ShowBlockLegend(Partitions, 10 pts);
    }
  };

  ShowDirection = VBox {
    Chart(100%, ExtentHeight - 48 pts) {
      TipNoPublish: true;
      Type: ChartTypes.Scatter;
      TextHeight: 12 pts;

      XLabel: "Transitions";

      ValueLabel: HBox {
        Transform: TransformClass.Rotate(90 degrees);
        TransformFit: true;
        RateDescriptor("Direction");
      };

      var group   = Markers.TriangleUp(Colors.Green) {TextHeight: 8 pts};
      var special = Markers.Square(Colors.Red) {TextHeight: 10 pts};
      ChartSeries {
        TextHeight: 6 pts;
        Marker: Markers.Dot;
        foreach (var a in SortByDirection) {
          new DataPointClass(each0, a.Direction) {
            Reference: a;
            if (a.S0.Segment.Ipa == "p")
              Marker: a.S1.Segment.Ipa == "b" or a.S1.Segment.Ipa == "f" ? special : group;
            else
              Marker: a.S0.Partition.Marker;
          }
        }
      };
    };

    Separation: 20 pts;
    Canvas(ExtentWidth) {
      HAlign: HAligns.Center;
      Rule.ShowBlockLegend(Partitions, 10 pts);
    }
  };

  ShowChartPairs(top, RateClass[] rates) = VBox {
    var subset = top < 0 ? rates : rates.Slice(0..<top);

    ShowChart(subset) {
      Type: ChartTypes.StackedColumn;

      Legend: ChartLegend {
        Direction: Directions.Vertical;
        Placement: Placements.Right;
      };
      ChartSeries(Colors.Red) {
        Label: Tex.leftarrow;
        foreach (var a in subset)
          new DataPointClass(each0, a.Reverse);
      };
    };
    Separation: 20 pts;
    ShowLegend(subset);
  };

  Pairs(top, FindRateDelegate predicate) = ShowChartPairs(top, SortedRates.FindSlice(predicate));
}

//======================================================================

class SegDataClass {
  var RateClass Rate;
  var double    Value;

  Constructor(RateClass rate) {
    Rate  = rate;
    Value = -rate.Original;
  }

  override GetLayoutTip = VBox(PaperStyle.SegmentWidth) {
    HAlign: HAligns.Center;

    Span {
      TextBackground: Rate.S0.Partition.Color;
      Rate.S0.Partition.Name;
    };
    Span {
      "Value"; ColonSpace;
      Value;
    };
    if (not Rate.Diagonal) {
      Span {
        Lang.RateFactor; ColonSpace;
        TextDigits: 2;
        Rate.Rate;
      };
    }

    Rate.S0.GetLayoutTip;
  };

}

//======================================================================

class DiagonalClass {
  var ListClass<SegDataClass> Diagonal;
  var ResultsClass            Results;

  Constructor(ResultsClass results, AlignedCountClass rates) {
    Results = results;
    var m      = rates.Matrix;
    var length = m.Cols;

    Diagonal = new(length);
    for (int i = 0; i < length; ++i) {
      var r = m[i, i];
      if (r is not null)
        Diagonal.Add(new(r));
    }
    Diagonal.Sort(true, @CompareData);
  }

  static int CompareData(SegDataClass d0, SegDataClass d1) = d0.Value.Compare(d1.Value);

  Display = VBox {
    HAlign: HAligns.Center;
    PaperStyle.SansSerif;

    Chart(ExtentWidth, 4 inches) {
      TextHeight: 11 pts;
      Type: ChartTypes.Column;

      ValueLabel: HBox {
        Span {Tex.Minus; Lang.Rate};
        Transform: TransformClass.Rotate(90 degrees);
        TransformFit: true;
      };

      XAxis: ChartAxis {
        TextHeight: PaperStyle.SegmentTextFactor * ExtentWidth / Diagonal.Length;
        foreach (var d in Diagonal)
          d.Rate.S0.ShowSegment;
      };

      ValueAxis: ChartAxis;
      ChartSeries {
        foreach (var d in Diagonal) {
          new DataPointClass(each0, d.Value) {
            Reference: d;
            Fill: d.Rate.S0.Partition.Color;
          };
        }
      };
    };

    Results.Data.Rule.ShowBlockLegend(Results.Rule.Partitions, 9 pts);
  };
}

//======================================================================

class FrequencyClass {
  var Frequency,
      Index;

  Constructor(frequency) {
    Index     = each0;
    Frequency = frequency;
  }
}

//======================================================================

class RateDataClass {
  var TaxonClass       Taxon;
  var VectorClass      Count;
  var FrequencyClass[] Frequency;
  var                  TotalCount,
                       MaxFrequency,
                       Distance;

  Constructor(count, TaxonClass taxon) {
    Taxon        = taxon;
    TotalCount   = 0;
    MaxFrequency = 0;
    Count        = new VectorClass(count, 0);
  }
}

//======================================================================

class SegmentActionClass: ActionClass {
  var RateDataClass Rate;
  var SegPartClass  Segment;
  var TaxonClass    Taxon;
  var               Count,
                    Percent;

  Constructor(RateDataClass rate, SegPartClass segment, count, percent) {
    super.Constructor(Actions.RunQuery, null);
    Segment = segment;
    Taxon   = rate.Taxon;
    Count   = count;
    Percent = percent;
  }

  override GetQuery = MatchAll(WordClass) {
    MatchAny(LanguageClass) {
      Taxon.Language;
    };
    MatchAny(SegPartClass) {
      Segment;
    };
  };

  override GetLayoutTip = VBox {
    HAlign: HAligns.Center;
    Span {
      Lang.Occurrences(Count);
      Space;
      Span {
        "(";
        TextDigits: 1;
        Percent * 100.0;
        "%)";
      }
    };
    Segment.GetLayoutTip;
  };
}

//======================================================================

abstract class FrequencyChartClass {
  var PartitionClass[] Partitions;
  var RuleClass        Rule;
  var TaxonClass[]     Taxa;
  var VectorClass      UsedCount,
                       UsedFrequency;
  var FrequencyClass[] FirstRate;
  var RateDataClass[]  Rates,
                       SortedRates;
  var                  RateCount,
                       SortedIndexes,
                       MaxDistance;

 Constructor(DataSetClass data, count) {
    Partitions = data.Rule.Partitions;
    Rule       = data.Rule;
    Taxa       = data.Taxa;
    RateCount  = count;
    Rates      = new RateDataClass(count, each Taxa);
  }

  int CompareFrequency(i0, i1) {
    var f0 = FirstRate[i0];
    var f1 = FirstRate[i1];
    var d  = f0.Frequency.Compare(f1.Frequency);
    return d == 0 ? f0.Index - f1.Index : d;
  }

  static int CompareDistance(RateDataClass r0, RateDataClass r1) {
    return r0.Distance.Compare(r1.Distance);
  }

  void ComputeDistance(sortfunction) {
    // Compute the Euclidean distance between each language and the first language

    var fr = new VectorClass(RateCount, 0.0);
    foreach (var rate in Rates) {
      var mult = 100.0 / rate.TotalCount;
      for (var i = 0; i < RateCount; ++i) {
        var f = mult * rate.Count[i];
        fr.SetValue(i, f);
        if (f > rate.MaxFrequency)
          rate.MaxFrequency = f;
      }
      rate.Frequency = new FrequencyClass(each fr);
    }

    var max = 0.0;
    var r0  = Rates[0];
    foreach (var rate in Rates) {
      if (each0 > 0) {
        var sum = 0.0;
        for (var i = 0; i < RateCount; ++i) {
          var delta = rate.Frequency[i].Frequency - r0.Frequency[i].Frequency;
          sum += delta * delta;
        }
        rate.Distance = Math.Sqrt(sum);
        if (rate.Distance > max)
          max = rate.Distance;
      }
      else
        rate.Distance = 0.0;
    }

    MaxDistance = max;
    FirstRate   = r0.Frequency;
    var a = 0 ..< RateCount step 1;
    SortedIndexes = a.ToSortedArray(true, sortfunction);
    SortedRates   = Rates.ToSortedArray(false, @CompareDistance);
  }

  abstract SegmentBar(RateDataClass rate, index, width, height);
  abstract OccurranceChart(SizeClass size);

  LangCanvas(RateDataClass rate, width, height) = HBox(null, height, BorderB(0.25 pts)) {
    VAlign: VAligns.Bottom;
    SegmentBar(rate, each SortedIndexes, width, ExtentHeight);
  };

  ShowChart = HBox {
    VAlign: VAligns.Center;
    Rule.ShowLegend(10 pts, 1.4 inch, new EdgeClass(0.25 pts, 5, 80%)) {
      Margin: PadR(12 pts);
    };
    OccurranceChart(new(ExtentWidth - 2 inches, ExtentHeight));
  };
}
//======================================================================

class SegmentFrequencyClass: FrequencyChartClass {
  var VectorClass    PartitionMax;
  var SegPartClass[] Segments;

  Constructor(DataSetClass data, group) {
    super.Constructor(data, data.UniqueSegments.Length);

    Segments     = data.UniqueSegments;
    PartitionMax = new(data.Rule.Partitions.Length, 0);

    foreach (var cognate in data.UsedCognates) {
      foreach (var word in cognate.Words) {
        var rate = Rates[word.Taxon.Index];
        foreach (var segment in word.Segments) {
          ++rate.TotalCount;
          rate.Count.AddValue(segment.Index, 1);
          PartitionMax.AddValue(segment.PartitionIndex, 1);
        }
      }
    }

    ComputeDistance(group ? @CompareGroups : @CompareFrequency);
  }

  int CompareGroups(i0, i1) {
    var f0 = FirstRate[i0];
    var f1 = FirstRate[i1];
    var d  = PartitionMax[Segments[f0.Index].PartitionIndex] - PartitionMax[Segments[f1.Index].PartitionIndex];
    if (d == 0) {
      d = f0.Frequency.Compare(f1.Frequency);
      if (d == 0)
        return f0.Index - f1.Index;
    }
    return d;
  }

  override SegmentBar(RateDataClass rate, index, width, height) {
    var f = rate.Frequency[index].Frequency / rate.MaxFrequency;
    return Canvas(width-1, height * f) {
      Margin: PadR(1);
      var s = Segments[index];
      Background: s.Partition.Color;
      TipAction: new SegmentActionClass(rate, s, rate.Count[index], f);
    };
  }

  SegmentLabel(SegPartClass[] segments, index, width, height) = HBox(width, height) {
    HAlign: HAligns.Center;
    segments[index].ShowSegment;
  };

  override OccurranceChart(SizeClass size) = MatrixBlock {
    var lw     = 70 pts;
    var cw     = size.Width - lw;
    var bw     = cw / Segments.Length;
    var bh     = bw * 1.5;
    var h      = (size.Height - bh) / Taxa.Length;
    var r0     = SortedRates[0];
    var factor = 1.0 / MaxDistance;

    TextHeight: 12 pts;
    VAlign: VAligns.Bottom;
    foreach (var rate in SortedRates) {
      Row {
        Cell(PadR(3 pts)) {
          Frame(lw) {
            rate.Taxon.Language;
          };
          if (rate.Distance > 0) {
            var frac = factor * rate.Distance;
            Canvas(lw * frac, 2) {
              Background: Colors.Red;
              Tip: new TipClass("{0}% different from {1}"(frac*100.0 {TextDigits: 1}, r0.Taxon.Language));
            };
          }
        };
        LangCanvas(rate, bw, h);
      };
    }

    Row {
      Empty;
      TextHeight: 0.8 * bw;  // Magic number to fit the segment glyphs underneath the bars
      HBox {
        SegmentLabel(Segments, each SortedIndexes, bw, bh);
      };
    }
  };
}

//======================================================================

class PartitionRateActionClass: ActionClass {
  var RateDataClass  Rate;
  var PartitionClass Partition;
  var TaxonClass     Taxon;
  var                Count,
                     Percent;

  Constructor(RateDataClass rate, PartitionClass partition, count, percent) {
    super.Constructor(Actions.RunQuery, null);
    Partition = partition;
    Taxon     = rate.Taxon;
    Count     = count;
    Percent   = percent;
  }

  override GetQuery = MatchAll(WordClass) {
    MatchAny(LanguageClass) {
      Taxon.Language;
    };
    MatchAny(SegPartClass) {
      Partition.Segments;
    };
  };

  override GetLayoutTip = VBox {
    HAlign: HAligns.Center;
    Span {
      Lang.Occurrences(Count);
      Space;
      Span {
        "(";
        TextDigits: 1;
        Percent * 100.0;
        "%)";
      }
    };
  };
}

//======================================================================

class PartitionFrequencyClass: FrequencyChartClass {
  Constructor(DataSetClass data) {
    super.Constructor(data, data.Rule.Partitions.Length);

    foreach (var cognate in data.UsedCognates) {
      foreach (var word in cognate.Words) {
        var rate = Rates[word.Taxon.Index];
        foreach (var segment in word.Segments) {
          ++rate.TotalCount;
          rate.Count.AddValue(segment.PartitionIndex, 1);
        }
      }
    }

    ComputeDistance(@CompareFrequency);
  }

  override SegmentBar(RateDataClass rate, index, width, height) {
    var f = rate.Frequency[index].Frequency / rate.MaxFrequency;
    return Canvas(width-1, height * f) {
      Margin: PadR(1);
      var partition = Partitions[index];
      Background: partition.Color;
      TipAction: new PartitionRateActionClass(rate, partition, rate.Count[index], f);
    };
  }

  PartitionLabel(index, width, height) = Frame(width, height) {
    ParAlignment: ParAlignments.Center;
    Partitions[index].Name;
  };

  override OccurranceChart(SizeClass size) = MatrixBlock {
    var lw = 60 pts;
    var cw = size.Width - lw;
    var bw = cw / Partitions.Length;
    var bh = 16 pts;
    var h  = (size.Height - bh) / Taxa.Length;
    var r0 = SortedRates[0];

    TextHeight: 11 pts;
    VAlign: VAligns.Bottom;

    var factor = 1.0 / MaxDistance;
    foreach (var rate in SortedRates) {
      Row {
        Cell(PadR(3 pts)) {
          Frame(lw) {
            rate.Taxon.Language;
          };

          var frac = factor * rate.Distance;
          Canvas(lw * frac, 2) {
            Background: Colors.Red;
            Tip: new TipClass("{0}% different from {1}"(frac*100.0 {TextDigits: 1}, r0.Taxon.Language));
          };
        };
        LangCanvas(rate, bw, h);
      };
    }

    Row {
      Empty;
      TextHeight: 9 pts;
      HBox {
        VAlign: VAligns.Top;
        PartitionLabel(each SortedIndexes, bw, bh);
      };
    }
  };
}

//======================================================================

