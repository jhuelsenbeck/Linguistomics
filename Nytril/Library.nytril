using Format, Units, Math, IO, LinkTypes;
//======================================================================

class LanguageClass: FactClass {
  field Name,
        Cases;
  var   MapImage,
        MapAttribution;

  Constructor(id, name, cases=0) {
    super.Constructor(id);
    Name    = name;
    Cases   = cases;
  }

  override GetIcon = Icons.language;

  virtual Description = null;
  virtual Details = null;

  override GetLayoutSpan = Span {
    TipAction: this;
    Name;
  };

  override GetLayoutTip = Block {
    Paragraph {
      Bold;
      TextHeight: 14 pts;
      Name;
    };
    if (valid Description) {
      Description {
        RightIndent: 3.5 inches;
      };
    }
    ShowMap(new SizeClass(5 inches, 3 inches));
  };

  LoadImage(name) = IO.Read(Info.ImageFolder FileName(name));

  ShowMap(size) {
    if (valid MapImage) {
      return VBox {
        Width: size.Width;
        HAlign: HAligns.Center;

        var h = 6 pts;
        MapImage {
          Size: new SizeClass(size.Width, size.Height - h);
          Proportional: true;
        };

        if (valid MapAttribution) {
          Span {
            TextHeight: h;
            TextColor: 80%;
            Lang.Credit;
            MapAttribution;
          }
        }
      };
    }
    return null;
  }
}

//======================================================================

typedef SegmentDictionary DictionaryClass<SegmentClass>;

class WordClass: FactClass {
  field          Plain,
                 Text;
  LanguageClass  Language;
  TaxonClass     Taxon;
  CognateClass   Cognate;
  SegmentClass[] Segments,
                 Aligned,
                 Padded;

  Constructor(SegmentDictionary dictionary, TaxonClass taxon, CognateClass cognate, text) {
    super.Constructor(valid cognate ? text+cognate.Concept.Name+cognate.Name+taxon.Variable : #71f32657-a37c-4f1d-abba-87b928e9d80b#);

    // IPA text and word text must be in the same unicode normaization form so comparisons are accurate
    Text     = text.GetString(NormalizationForms.FormC);
    Plain    = Text.FindSlice(c => c != IPASegments.GapSegment.Ipa and c != IPASegments.PrimaryStress.Ipa);
    Taxon    = taxon;
    Language = taxon.Language;
    Cognate  = cognate;

    if (valid Text) {
      var segments = dictionary.FindTokens(Text, IPA.NullSegment);
      Aligned  = segments.FindSlice(s => s.Gap or (not s.Punctuation));
      Segments = segments.FindSlice(s => not s.Punctuation);

      // Test that the word's text is the same as the segments converted back into text
      var view = Span {(each segments).Ipa};
      System.Assert(Text == view.GetString(), "Round-trip error with text {0}-{1}"(Text, view), Text);

      Link.Connect(this, Segments);
      Link.Connect(this, cognate);
      Link.Connect(this, Language);
      Link.Connect(Language, cognate);
    }
    else {
      Segments = [];
      Aligned  = [];
    }
  }

  override GetIcon = Icons.text_snippet;

  ShowConcept = Span {
    Style.SansSerif;
    TipAction: this;
    Cognate.GetTitle;
  };

  override GetLayoutSpan = Span {
    foreach (var s in Segments) {
      if (!s.Punctuation)
        s.Ipa;
    }
  };

  ShowPaddedBlocks(w, index=-1) = Table {
    Columns: [w]*Padded.Length;
    Row {
      foreach (var segment in Padded) {
        Cell {
          EdgeL: (0.125 pts) {Color: 80%};
          ParAlignment: ParAlignments.Center;
          if (index == each0)
            Background: Colors.LightYellow;
          segment.ShowSegment;
        };
      }
    };
  };

  FieldPar(name) = Paragraph {
    TabStops: [0.5 inches];
    Bold name;
    Tab;
  };

  override GetLayoutTip = Block {
    FieldPar(Lang.Language) {
      Language;
    };
    FieldPar(Lang.Cognate) {
      Cognate.GetTitle;
    };
    FieldPar(Lang.Segments) {
      Frame {
        Border: 0.5;
        TextHeight: 16 pts;
        ShowPaddedBlocks(20 pts);
      }
    }
  };

  override GetLayoutFact = Block {
    Paragraph {
      TabStops: [1 inch, 2, inch, 3 inch, 4 inch];
      GetIcon;
      Space;
      Quote;
      Plain;
      Quote;
      Tab;
      Language;
      ColonSpace;
      Cognate.GetTitle;
    };
    super.GetLayoutFact;
  };
}

//======================================================================

class ConceptClass: FactClass {
  field Name,
        Confidence;
  var   Variable,
        WordType,
        WordGroup;

  Constructor(variable) {
    super.Constructor(variable.GlobalVariablePath);
    Variable   = variable;
    Name       = variable.GlobalVariableName;
    Confidence = variable.Confidence;
    WordType   = variable.WordType;
    WordGroup  = variable.WordGroup;

    System.Assert(Confidence > 0);
    System.Assert(WordType != WordTypes.None);
    System.Assert(WordGroup != WordGroups.None);
  }

  override GetIcon = Icons.category;

  override GetLayoutTip = Span {Name; "-"; Confidence};

  override Compare(c, options) {
    return Name.Compare(c.Name);
  }
}
//======================================================================

class CognateClass: FactClass {
  field        Name;
  DataSetClass Data;
  ConceptClass Concept;
  WordClass[]  Words;
  var          MaxLength,
               Variable;

  Constructor(DataSetClass data, ConceptClass concept, variable) {
    super.Constructor(variable.GlobalVariablePath);

    Name      = variable.GlobalVariableName;
    Data      = data;
    Concept   = concept;
    Variable  = variable;
    MaxLength = 0;
    Link.Connect(this, concept);
  }

  override GetIcon = Icons.format_list_bulleted;

  GetTitle {
    return Concept.Name + '-' + Name;
  }

  override GetLayoutTip = AllWords.ShowConceptTable(Data, this);

  override Compare(c, options) {
    var i = Concept.Compare(c.Concept, options);
    if (i == 0)
      return Name.Compare(c.Name, options);
    return i;
  }
}
//======================================================================

class TaxonClass {
  var           Variable,
                Index;
  LanguageClass Language;

  Constructor(LanguageClass language) {
    Index    = each0;
    Language = language;
    Variable = language.GlobalVariableName;
  }

  override GetLayoutTip = Span {
    Style.TaxonFormat;
    Variable;
    TipAction: Language;
  };
}
//======================================================================

class WordPairClass {
  var       Index;
  WordClass Word1,
            Word2;

  Constructor(index, WordClass w1, WordClass w2) {
    Index = index;
    Word1 = w1;
    Word2 = w2;
  }

  ShowDescription(textheight) = Frame {
    Border: 0.25 pts;
    TextHeight: textheight;
    Paragraph {
      ParBackground: 90%;
      Bold;
      Word1.Cognate.Variable.GlobalVariablePath[9..];
    };

    textheight += 2 pts;
    Word1.ShowPaddedBlocks(textheight, Index);
    Word2.ShowPaddedBlocks(textheight, Index);
  };

  override GetLayoutTip = ShowDescription(12 pts);
}
//======================================================================

class DataSetClass {
  LanguageClass[]             Languages;
  SegmentClass[]              UniqueSegments,
                              SortedSegments,
                              DisplaySegments;
  CognateClass[]              UsedCognates,
                              SortedCognates;
  ConceptClass[]              UsedConcepts;
  TaxonClass[]                Taxa;
  MatrixClass                 TransitionCount;
  DictionaryClass<TaxonClass> TaxonSet;
  VectorClass                 WordList;
  var                         Description,
                              MaxLanguageName,
                              WordCount,
                              SegmentCount,
                              UniqueCount,
                              TransitionMax;

  Constructor(includewords, LanguageClass[] languages, description) {
    Languages       = languages;
    Description     = description;
    WordCount       = 0;
    SegmentCount    = 0;
    MaxLanguageName = 0;


    TaxonSet = new(languages.Length);
    ListClass<TaxonClass> tlist = new(languages.Length);

    foreach (var l in languages) {
      var taxon = new TaxonClass(l);
      tlist.Add(taxon);
      TaxonSet.Add(taxon, taxon.Variable);
      if (taxon.Variable.Length > MaxLanguageName)
        MaxLanguageName = taxon.Variable.Length;
    }
    Taxa     = tlist.Values;
    WordList = new VectorClass(Taxa.Length, null);

    // Build a dictionary with IPA text as the key
    var dictionary = new SegmentDictionary(256);
    foreach (var segment in IPASegments) {
      if (valid segment.Ipa)
        dictionary.Add(segment, segment.Ipa);
    }

    var clist       = new ListClass<CognateClass>(1024);
    var conceptlist = new ListClass<ConceptClass>(256);

    foreach (var conceptvar in Concepts) {
      var good = exists conceptvar.?Confidence and
                 exists conceptvar.?WordType and
                 exists conceptvar.?WordGroup;
      System.Assert(good, "Improper concept", conceptvar);

      if (good and conceptvar.Confidence > 0 and conceptvar.WordGroup.HasFlag(includewords)) {
        var concept = new ConceptClass(conceptvar);
        conceptlist.Add(concept);

        foreach (var cognate in conceptvar) {
          var vname = cognate.GlobalVariableName();
          var inc   = true;

          switch (vname) {
            case "Confidence":
            case "WordType":
            case "WordGroup":
              inc = false;
              break;
          }

          if (inc) {
            var count = 0;
            foreach (var word in cognate) {
              if (valid word and TaxonSet.Contains(word.GlobalVariableName))
                ++count;
            }
            if (count > 1) {
              WordCount += count;
              clist.Add(new CognateClass(this, concept, cognate));
            }
          }
        }
      }
    }

    UsedConcepts   = conceptlist.Values.Sort(false);
    UsedCognates   = clist.Values;

    foreach (var cognate in UsedCognates)
      ComputeCognate(dictionary, cognate);

    UniqueSegments = GetUniqueSegments;
    UniqueCount    = UniqueSegments.Length;
    foreach (var segment in UniqueSegments) {
      segment.Index         = each0;
      segment.UsedFrequency = Real(segment.UsedCount) / SegmentCount;
    }

    DisplaySegments = UniqueSegments;  // Could be IPA.Segments if you want to see all possible segments in the debug tables
    SortedSegments  = UniqueSegments.Sort(true, ref CompareAlpha);
    TransitionCount = GetTransitionsCount;
  }

  CognateClass[] GetSortedCognates {
    if (not valid SortedCognates)
      SortedCognates = UsedCognates.Sort(false);
    return SortedCognates;
  }

  static CompareAlpha(SegmentClass s0, SegmentClass s1, options) {
    var i = s0.Ipa.Length.Compare(s1.Ipa.Length);
    if (i == 0)
      i = -s0.Ipa.Compare(s1.Ipa);
    return i;
  }

  CognateClass GetCognate(concept) = UsedCognates.FindFirst(c => c.Concept.Variable == concept);

  SegmentClass[] GetUniqueSegments {
    var set = new SegmentSetClass(512);
    foreach (var cognate in UsedCognates) {
      foreach (var word in cognate.Words) {
        foreach (var segment in word.Segments) {
          if (!segment.Punctuation)
            set.Add(segment);
        }
      }
    }
    return set.Values;
  }

  void ComputeCognate(SegmentDictionary dictionary, CognateClass cognate) {
    var defword = new WordClass(null, Taxa[0], null, Empty);

    WordList.SetAllValues(defword);
    var maxlength = 0;

    foreach (var langword in cognate.Variable) {
      var taxon = TaxonSet.FindKey(langword.GlobalVariableName);
      if (valid taxon) {
        var word = new WordClass(dictionary, taxon, cognate, langword);
        maxlength = Math.Max([maxlength, word.Aligned.Length]);

        foreach (var s in word.Segments) {
          ++SegmentCount;
          ++s.UsedCount;
        }
        WordList.SetValue(taxon.Index, word);
      }
    }

    cognate.Words     = WordList.Values;
    cognate.MaxLength = maxlength;

    foreach (var word in cognate.Words) {
      var a = word.Aligned;
      if (valid a) {
        if (a.Length < maxlength)
          word.Padded = a + [IPASegments.GapSegment] * (maxlength - a.Length);
        else
          word.Padded = a;
      }
      else
        word.Padded = a;
    }

    for (var i = 0; i < maxlength; ++i) {
      var count    = 0;
      var gapcount = 0;

      foreach (var word in cognate.Words) {
        if (valid word.Aligned) {
          ++count;
          if (word.Padded[i] == IPASegments.GapSegment)
            ++gapcount;
        }
      }
      System.Assert(gapcount < count, "Column with all gaps", cognate.Variable);
    }
  }

  ShowWord(SegmentClass segment) = Block {
    Paragraph {
      SpaceBefore: 10 pts;
      TextHeight: 14;
      BorderB: 1;
      "Words containing \"{0}\""(segment.Ipa);
    };
    Paragraph {
      Separator: Space;
      foreach (var cognate in UsedCognates) {
        foreach (var word in cognate.Words) {
          if (word.Segments.FindAny(segment))
            word.Plain;
        }
      }
    };
  };

  GetTransitionsCount {
    TransitionMax = 1;
    var t = new MatrixClass(UniqueCount, UniqueCount, null);

    foreach (var cognate in UsedCognates) {
      var length = cognate.Words.Length;
      for (var i = 0; i < length; ++i) {
        var p0 = cognate.Words[i].Padded;
        for (var j = 0; j < length; ++j) {
          if (i != j) {
            var p1 = cognate.Words[j].Padded;
            var ml = Min([p0.Length, p1.Length]);
            for (var index = 0; index < ml; ++index) {
              var s0 = p0[index];
              var s1 = p1[index];
              if (s0.Index != s1.Index and not s0.Punctuation and not s1.Punctuation) {
                var list = t.GetValue(s0.Index, s1.Index);
                var p    = new WordPairClass(index, cognate.Words[i], cognate.Words[j]);
                if (not valid list) {
                  list = new ListClass<WordPairClass>(128);
                  t.SetValue(s0.Index, s1.Index, list);
                }
                list.Add(p);
                if (list.Length > TransitionMax)
                  TransitionMax = list.Length;
              }
            }
          }
        }
      }
    }
    return t;
  }
}
//======================================================================

class RateDataClass {
  TaxonClass  Taxon;
  VectorClass Count,
              Frequency;
  var         TotalCount,
              MaxFrequency,
              Distance;

  Constructor(count, TaxonClass taxon) {
    Taxon        = taxon;
    TotalCount   = 0;
    MaxFrequency = 0;
    Count        = new VectorClass(count, 0);
    Frequency    = new VectorClass(count, 0.0);
  }
}

//======================================================================

class SegmentActionClass: ActionClass {
  RateDataClass Rate;
  SegmentClass   Segment;
  TaxonClass     Taxon;
  var            Count,
                 Percent;

  Constructor(RateDataClass rate, SegmentClass segment, count, percent) {
    super.Constructor(Actions.RunQuery, null);
    Segment = segment;
    Taxon   = rate.Taxon;
    Count   = count;
    Percent = percent;
  }

  override GetQuery = MatchAll WordClass {
    MatchAny LanguageClass {
      Taxon.Language;
    };
    MatchAny SegmentClass {
      Segment;
    };
  };

  override GetLayoutTip = VBox {
    HAlign: HAligns.Center;
    Span {
      Lang.Occurrences(Count);
      Space;
      Span {
        "(";
        TextDigits: 1;
        Percent * 100.0;
        "%)";
      }
    };
    Segment.GetLayoutTip;
  };
}

//======================================================================

abstract class FrequencyChartClass {
  ExperimentClass  Experiment;
  PartitionClass[] Partitions;
  DataSetClass     Data;
  TaxonClass[]     Taxa;
  VectorClass      UsedCount,
                   UsedFrequency,
                   FirstRate;
  RateDataClass[]  Rates,
                   SortedRates;
  var              RateCount,
                   SortedIndexes,
                   MaxDistance;

 Constructor(ExperimentClass experiment, count) {
    Experiment = experiment;
    Partitions = experiment.Rule.Partitions;
    Data       = experiment.Data;
    Taxa       = Data.Taxa;
    RateCount  = count;
    Rates      = new RateDataClass(count, each Taxa);
  }

  CompareFrequency(i0, i1, options) {
    return FirstRate[i0].Compare(FirstRate[i1]);
  }

  static CompareDistance(RateDataClass r0, RateDataClass r1, options) {
    return r0.Distance.Compare(r1.Distance);
  }

  void ComputeDistance(sortfunction) {
    // Compute the Euclidean distance between each language and the first language

    foreach (var rate in Rates) {
      var mult = 100.0 / rate.TotalCount;
      for (var i = 0; i < RateCount; ++i) {
        var f = mult * rate.Count[i];
        rate.Frequency.SetValue(i, f);
        if (f > rate.MaxFrequency)
          rate.MaxFrequency = f;
      }
    }

    var max = 0.0;
    var r0  = Rates[0];
    foreach (var rate in Rates) {
      if (each0 > 0) {
        var sum = 0;
        for (var i = 0; i < RateCount; ++i) {
          var delta = rate.Frequency[i] - r0.Frequency[i];
          sum += delta * delta;
        }
        rate.Distance = Math.Sqrt(sum);
        if (rate.Distance > max)
          max = rate.Distance;
      }
      else
        rate.Distance = 0.0;
    }

    MaxDistance = max;
    FirstRate   = r0.Frequency;
    var a = 0 ..< RateCount step 1;
    SortedIndexes = a.Sort(true, sortfunction);
    SortedRates   = Rates.Sort(false, ref CompareDistance);
  }

  abstract SegmentBar(RateDataClass rate, index, width, height);
  abstract OccurranceChart(SizeClass maxsize);

  LangCanvas(RateDataClass rate, width, height) = HBox {
    var cborder = 0.25 pts;

    VAlign: VAligns.Bottom;
    Height: height;
    BorderB: cborder;
    SegmentBar(rate, each SortedIndexes, width, height - cborder);
  };

  ShowChart(SizeClass maxsize) = Paragraph {
    Experiment.Rule.ShowLegend(10 pts, 1.1 inch) {Border: 0.25 {Color: 80%}; MarginR: 12 pts; Padding: 5};
    OccurranceChart(new SizeClass(maxsize.Width - 2 inches, maxsize.Height));
  };
}
//======================================================================

class SegmentFrequencyClass: FrequencyChartClass {
  Constructor(ExperimentClass experiment, group) {
    super.Constructor(experiment, experiment.Data.UniqueCount);

    foreach (var cognate in Data.UsedCognates) {
      foreach (var word in cognate.Words) {
        var rate = Rates[word.Taxon.Index];
        foreach (var segment in word.Segments) {
          ++rate.TotalCount;
          rate.Count.AddValue(segment.Index, 1);
        }
      }
    }

    ComputeDistance(group ? ref CompareGroups : ref CompareFrequency);
  }

  CompareGroups(i0, i1, options) {
    var s0 = Data.UniqueSegments[i0];
    var s1 = Data.UniqueSegments[i1];
    var d  = s0.PartitionIndex - s1.PartitionIndex;
    if (d == 0)
      return FirstRate[s1].Compare(FirstRate[s0]);
    return d;
  }

  override SegmentBar(RateDataClass rate, index, width, height) = Canvas {
    var f = rate.Frequency[index] / rate.MaxFrequency;
    Size: new SizeClass(width-1, height * f);
    MarginR: 1;
    var s = Data.UniqueSegments[index];
    Background: ChartColor(s.PartitionIndex);
    TipAction: new SegmentActionClass(rate, s, rate.Count[index], f);
  };

  SegmentLabel(SegmentClass[] segments, index, width, height) = HBox {
    Width: width;
    Height: height;
    HAlign: HAligns.Center;
    segments[index].ShowSegment;
  };

  override OccurranceChart(SizeClass maxsize) = MatrixBlock {
    var lw = 60 pts;
    var cw = maxsize.Width - lw;
    var bw = cw / Data.UniqueCount;
    var bh = bw * 1.5;
    var h  = (maxsize.Height - bh) / Taxa.Length;
    var r0 = SortedRates[0];

    TextHeight: 12 pts;
    VAlign: VAligns.Bottom;
    foreach (var rate in SortedRates) {
      Row {
        Cell {
          PaddingR: 3 pts;
          Frame {
            Width: lw;
            rate.Taxon.Language;
          };
          Canvas {
            Background: Colors.Red;
            var frac = rate.Distance / MaxDistance;
            Size: new SizeClass(lw * frac, 2);
            Tip: new TipClass(String("{0}% different from {1}"(frac*100.0 {TextDigits: 1}, r0.Taxon.Language)));
          };
        };
        LangCanvas(rate, bw, h);
      };
    }

    Row {
      Empty;
      TextHeight: 1.1 * bw;
      HBox {
        SegmentLabel(Data.UniqueSegments, each SortedIndexes, bw, bh);
      };
    }
  };
}

//======================================================================

class PartitionRateActionClass: ActionClass {
  RateDataClass  Rate;
  PartitionClass Partition;
  TaxonClass     Taxon;
  var            Count,
                 Percent;

  Constructor(RateDataClass rate, PartitionClass partition, count, percent) {
    super.Constructor(Actions.RunQuery, null);
    Partition = partition;
    Taxon     = rate.Taxon;
    Count     = count;
    Percent   = percent;
  }

  override GetQuery = MatchAll WordClass {
    MatchAny LanguageClass {
      Taxon.Language;
    };
    MatchAny PartitionClass {
      Partition;
    };
  };

  override GetLayoutTip = VBox {
    HAlign: HAligns.Center;
    Span {
      Lang.Occurrences(Count);
      Space;
      Span {
        "(";
        TextDigits: 1;
        Percent * 100.0;
        "%)";
      }
    };
  };
}

//======================================================================

class PartitionFrequencyClass: FrequencyChartClass {
  Constructor(ExperimentClass experiment) {
    super.Constructor(experiment, experiment.Rule.Partitions.Length);

    foreach (var cognate in Data.UsedCognates) {
      foreach (var word in cognate.Words) {
        var rate = Rates[word.Taxon.Index];
        foreach (var segment in word.Segments) {
          ++rate.TotalCount;
          rate.Count.AddValue(segment.PartitionIndex, 1);
        }
      }
    }

    ComputeDistance(ref CompareFrequency);
  }

  override SegmentBar(RateDataClass rate, index, width, height) = Canvas {
    var f = rate.Frequency[index] / rate.MaxFrequency;
    Size: new SizeClass(width-1, height * f);
    MarginR: 1;
    var partition = Partitions[index];
    Background: ChartColor(partition.Index);
    TipAction: new PartitionRateActionClass(rate, partition, rate.Count[index], f);
  };

  PartitionLabel(index, width, height) = Frame {
    Width: width;
    Height: height;
    ParAlignment: ParAlignments.Center;
    Partitions[index].Name;
  };

  override OccurranceChart(SizeClass maxsize) = MatrixBlock {
    var lw = 60 pts;
    var cw = maxsize.Width - lw;
    var bw = cw / Partitions.Length;
    var bh = 16 pts;
    var h  = (maxsize.Height - bh) / Taxa.Length;
    var r0 = SortedRates[0];

    TextHeight: 12 pts;
    VAlign: VAligns.Bottom;
    foreach (var rate in SortedRates) {
      Row {
        Cell {
          PaddingR: 3 pts;
          Frame {
            Width: lw;
            rate.Taxon.Language;
          };
          Canvas {
            Background: Colors.Red;
            var frac = rate.Distance / MaxDistance;
            Size: new SizeClass(lw * frac, 2);
            Tip: new TipClass(String("{0}% different from {1}"(frac*100.0 {TextDigits: 1}, r0.Taxon.Language)));
          };
        };
        LangCanvas(rate, bw, h);
      };
    }

    Row {
      Empty;
      TextHeight: 9 pts;
      HBox {
        VAlign: VAligns.Top;
        PartitionLabel(each SortedIndexes, bw, bh);
      };
    }
  };

}

//======================================================================

