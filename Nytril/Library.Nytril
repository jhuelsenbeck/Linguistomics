using Format, Units, Math, IO
//======================================================================

with RevBayes
  let TreeFile      = Info.OutputFolder FileName("ieo_fifty") Extensions.Nexus
  let Comment(text) = Span {TextColor: Colors.Green, LineBreak, "# " text}
  let String(text)  = Span {TextColor: Colors.Red, text.QuoteString}

  let CognateNumber(group) = Span {
    group.Variable,
    " := ",
    group.Members.Length
  }

  let SourceFile = Style.SourceCodeBlock {
    "clear()",
//    "morph = readDiscreteCharacterData({0})"(String(Nexus.SourcePath))
    Empty,
    "moves = VectorMoves()",
    "monitors = VectorMonitors()",
    "trees = readTrees({0})"(String(TreeFile)),
    "treetrace = treeTrace(trees)",
  }
end
//======================================================================
/*
with Nexus {
  let SourcePath = Info.OutputFolder FileName("Articles") Extensions.Nexus

  let LanguageLine(lang) = {
    "    " lang.SymbolName
  }

  let CharState(lang, group) = AnyContains(lang, group) ? PossibleSymbols[EachIndex+1] : PossibleSymbols[0]

  let CharStates(lang) {
    CharState(lang, each CognateGroup)
  }

  let MatrixLine(lang) = Span {
    "  ",
    lang.SymbolName,
    " " * (20 - lang.SymbolName.Length),
    CharStates(lang)
  }

  let Comment(text) = Span {TextColor: Colors.Green, "# " text}

  let PossibleSymbols = ('0'..'9' step 1) + ('A'..'Z' step 1) + ('a'..'z' step 1)

  let UsedSymbols = Span {
    Separator: Space,
    each PossibleSymbols[0..<CognateGroup.Length]
  }

  let ClassComment(cc) = "  {0} '{1}' / ,"(EachIndex+1, cc.Description)

  let SourceFile = Style.SourceCodeBlock {
    Comment("This does not include demonstratives with article-like functions but it does code for Baltic definite adjectives and Iraninian specificity DOM"),
    Comment("NEXUS"),
    Empty,
    Comment("I added the taxa information"),
    "BEGIN TAXA;",
    "  DIMENSIONS NTAX={0};"(LanguageList.Length),
    "  TAXLABELS",
    LanguageLine(each LanguageList),
    ";",
    "END;",
    Empty,
    Empty,
    "BEGIN CHARACTERS;",
    "DIMENSIONS NewTaxa NTAX={0} NCHAR={1};"(LanguageList.Length, CognateGroup.Length),
    "FORMAT DATATYPE=STANDARD SYMBOLS=\"{0}\" MISSING=? GAP=-;"(UsedSymbols),
    "CHARSTATELABELS",
    "  0 'None' / ,",
    ClassComment(each CognateGroup),
    "  ;",
    Empty,
    "MATRIX"
    Empty,
    MatrixLine(each LanguageList),
  }
}
*/
//======================================================================

with TreeLib
  let GetNodeLabel(node) = node.Data?.SymbolName

  let VisitNodeTaxa(set, node) begin
    if (node.Data)
      set.AddReference(node.Data);
    end;
    VisitNodeTaxa(set, each node);
  end

  let GetTaxaLabels(tree) begin
    var set = Type.Dictionary(256);
    VisitNodeTaxa(set, tree);
    return (each set).SymbolName;
  end

  let Newick(node) = Span {
    if (node.Length > 0)
      "(",
      Span {
        Separator: ",",
        Newick(each node)
      },
      ")",
    end,
    GetNodeLabel(node),
    ":",
    node.Branch
  }

  let ShowTreeLine(ref tree) = Span {
    "  tree ",
    tree.SymbolName,
    " = ",
    Newick(tree),
    ";"
  }

  let NexusFile(ref tree) = TreeCode(tree, GetTaxaLabels(tree))

  let TreeCode(ref tree, taxa) = TextBlock {
    "#NEXUS",
    "BEGIN TAXA;",
    "  Dimensions ntax={0};"(taxa.Length),
    Span {
      "  TAXLABELS ",
      Span {
        Separator: Space,
        taxa,
      },
      ";",
    },
    "END;",
    Empty,
    "BEGIN trees;",
    ShowTreeLine(tree),
    "END;"
  }
end
//======================================================================

