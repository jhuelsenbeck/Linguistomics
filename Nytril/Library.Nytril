using Format, Units, Math, IO, Genetics;
//======================================================================

class WordClass {
  var Language,
      Cognate,
      Concept,
      Text,
      AlignedSegments,
      Segments;

  Constructor(language, cognate, text) {
    Language = language;
    Cognate  = cognate;
    Concept  = cognate.Concept;
    Text     = text;
    if (text.Length > 0) {
      var segments = IPA.SegmentDictionary.FindTokens(text, IPA.NoSegment);
      AlignedSegments  = Math.FindSlice(segments, s => s.Gap or (not s.Punctuation));
      Segments         = Math.FindSlice(segments, s => not s.Punctuation);

      // Test that the word's text is the same as the segments converted back into text
      var view = String(Span {(each segments).Ipa});
      System.Assert(text == view, "Round-trip error with text {0}-{1}"(text, view), text);
    }
    else {
      Segments        = [];
      AlignedSegments = [];
    }
  }

  CleanText = Span {
    (each Segments).ShowSegment;
  };

  ShowConcept = Span {
    Style.SansSerif;
    Popup: this;
    Cognate.Name;
  };

  override GetPopup = Frame {
    AllWords.ShowConceptTable(Cognate);
  };
}
//======================================================================

class CognateClass {
  var Name,
      Concept,
      AncestralClass;

  Constructor(concept, aclass) {
    Name           = concept.GlobalVariableName;
    Concept        = concept;
    AncestralClass = aclass;
  }
}
//======================================================================

class LanguageClass {
  var Name,
      Cases,
      Words;

  Constructor(name, cases=0) {
    Name  = name;
    Cases = cases;
  }

  GetWord(cognate) {
    foreach (var w in Words) {
      if (w.Cognate == cognate)
        return w;
    }
    return null;
  }

  void GetWords(id) {
    var list = new ListClass(32);
    foreach (var cognate in UsedCognates) {
      foreach (var word in cognate.AncestralClass) {
        if (id == word.GlobalVariableName)
          list.Add(new WordClass(this, cognate, word[0]));
      }
    }
    Words = list.ToArray();
  }
}
//======================================================================

class ConceptRecord {
  var Cells,
      MaxLength,
      Cognate,
      AccestralClass;

  Constructor(cognate) {
    Cognate   = cognate;
    Cells     = new ListClass(128);
    MaxLength = 0;

    foreach (var language in Results.UsedLanguages) {
      var found = false;
      foreach (var word in language.Words) {
        if (word.Cognate == cognate) {
          Cells.Add(word);
          var l = word.Segments.Length;
          if (l > MaxLength)
            MaxLength = l;
          found = true;
          break;
        }
      }
      if (!found)
        Cells.Add(new WordClass(language, cognate, Empty));
    }
  }
}
//======================================================================

class TaxonClass {
  var Name,
      Language,
      MaxLength,
      SegmentList,
      BaseAlignList,
      AlignedList;

  Constructor(lang, langindex) {
    Language      = lang;
    Name          = lang.GlobalVariableName;
    MaxLength     = 0;
    SegmentList   = new ListClass(Results.WordConceptArray.Length);
    BaseAlignList = new ListClass(Results.WordConceptArray.Length);
    foreach (var concept in Results.WordConceptArray) {
      var word = concept.Cells[langindex];
      SegmentList.Add(word.Segments);
      var aligned = word.AlignedSegments;
      BaseAlignList.Add(aligned);
      var wl = aligned.Length;
      if (wl > MaxLength)
        MaxLength = wl;
    }
  }
}
//======================================================================

with Results {
  GetTaxaArray(lang) = new TaxonClass(lang, EachIndex);

  ComputeTaxa() {
    var taxa     = GetTaxaArray(each UsedLanguages);
    var concepts = WordConceptArray.Length;


    foreach (var taxon in taxa) {
      var aligned = new ListClass(concepts);
      for (var concept = 0; concept < concepts; ++concept) {
        var a = taxon.BaseAlignList[concept];
        if (a.Length < taxon.MaxLength)
          a += [IPA.Segments.GapSegment] * (taxon.MaxLength - a.Length);
        aligned.Add(a);
      }
      taxon.AlignedList = aligned;
    }
    return taxa;
  }

  GetUsedLanguages {
    var set = new DictionaryClass(64);
    foreach (var cognate in UsedCognates) {
      foreach (var word in cognate.AncestralClass) {
        var langname = word.GlobalVariableName;
        if (set.FindKey(langname) == null) {
          var lang = Languages.GetField(langname);
          if (exists lang) {
            lang.GetWords(langname);
            set.Add(lang, langname);
          }
        }
      }
    }
    return set.Values;
  }

  WordConceptArray = new ConceptRecord(each UsedCognates);
  TaxaArray        = ComputeTaxa;
  UsedLanguages    = GetUsedLanguages;
  UniqueSegments   = DisplayCharacters.FindUniqueSegments;
  UsedSegments     = UniqueSegments;//IPA.Segments;
}
//======================================================================

with Nexus {
  TaxonFormat   = {TextColor: Colors.DarkBlue};
  CommentFormat = {TextColor: Colors.Green};
  CharacterList = ('A'..'Z' step 1) + ('a'..'z' step 1) + ('0'..'9' step 1) + ['!', '$', '_', '~', '^'];
  EndMarker     = ";";
  Missing       = "?";
  Quote         = "\"";

  Keyword(name) = Span {
    CommentFormat;
    name;
  };

  Comment(text) = Span {
    TextColor: Colors.Green;
    "[ ";
    text;
    " ]";
  };

  AddLine(name) = Span {
    Keyword(name);
    End: EndMarker;
  };

  AddValue(name, value=null) = Span {
    Space;
    Keyword(name);
    if (exists value) {
      "=";
      value;
    }
  };

  AddTaxon(taxon) = Span {
    TaxonFormat;
    Space;
    taxon.Name;
  };

  Scope(name) = TextBlock {
    IndentSpace: 2;
    Begin: Span {
      Keyword("begin");
      Space;
      name;
      EndMarker;
    };
    End: Span {
      Keyword("end");
      EndMarker;
      LineBreak;
    };
  };

  NexusFile = TextBlock {
    Style.MonoFamily;
    Span {
      TextColor: Colors.DarkBlue;
      "#NEXUS";
    };
  };

  Newick(node) = Span {
    if (node.Length > 0) {
      "(";
      Span {
        Separator: ",";
        Newick(each node)
      };
      ")";
    }
    node.Label;
    ":";
    node.BranchLength
  };

  ShowTreeLine(tree) = Span {
    "tree ";
    tree.GlobalVariableName;
    " = ";
    Newick(tree);
    EndMarker
  };

  GetTaxaLabels(tree) {
    var set = new DictionaryClass(256);
    VisitNodeTaxa(set, tree);
    return (each set).Name;
  }

  void VisitNodeTaxa(set, node) {
    var name = exists node.Language ? node.Name : null;
    if (valid name)
      set.Add(node, name);
    VisitNodeTaxa(set, each node);
  }

  MaxNameLength = Math.Max((each ((each Results.TaxaArray).Name)).Length) + 1;

  WriteTaxa(index, cognate, paper, maxlength) = TextBlock {
    foreach (var taxon in Results.TaxaArray) {
      Span {
        Span {
          Nexus.TaxonFormat;
          taxon.Name;
          Link: cognate;
        };
        Space * (maxlength - taxon.Name.Length);
        foreach (var segment in taxon.AlignedList[index])
          segment.SegmentToCharacter.ShowLetter;

        switch (paper) {
          case 0:
            break;

          case 1:
            Space*4;
            Comment( Span{each (each taxon.AlignedList[index]).Ipa});
            break;

          case 2:
            Span {
              CommentFormat;
              Style.IPAFamily;
              Tab;
              foreach (var segment in taxon.AlignedList[index])
                segment.GetBlock;
            };
            break;
        }
      };
    }
  };

  TKFFile(index, cognate, paper) = TextBlock {
    if (paper > 0)
      Comment(cognate.Name);

    Span {
      Results.TaxaArray.Length;
      Space;
      Results.TaxaArray[0].AlignedList[index].Length;
      Space;
      Results.UniqueSegments.Length;
    };
    WriteTaxa(index, cognate, paper, MaxNameLength);
  };

  TKFFiles = TextBlock {
    Style.MonoFamily;
    TabStops: [3 inches];

    foreach (var cognate in UsedCognates) {
      TKFFile(EachIndex, cognate, 2);
      Empty;
    }
  };

  CharacterFile(paper) = NexusFile {
    var maxlength = MaxNameLength;
    var ntax      = Results.TaxaArray.Length;

    TabStops: [3 inches];

    Scope("taxa") {
      AddLine("dimensions") {
        AddValue("ntax", ntax);
      };
      AddLine("taxlabels") {
        AddTaxon(each Results.TaxaArray);
      };
    };

    Scope("data") {
      AddLine("dimensions") {
        AddValue("ntax", ntax);
        AddValue("nchar", Sum((each Results.TaxaArray[0].AlignedList).Length));
      };
      AddLine("format") {
        AddValue("datatype", "STANDARD");
        AddValue("interleave", "yes");
        AddValue("respectcase");
        AddValue("gap", IPA.Segments.GapSegment.Ipa);
        AddValue("missing", Missing);
        AddValue("symbols", Span {Quote; CharacterList[Results.UniqueSegments.IndexRange]; Quote});
      };
      Empty;
      Keyword("matrix");

      foreach (var cognate in UsedCognates) {
        if (EachIndex > 0)
          Empty;

        Comment(cognate.Name);
        WriteTaxa(EachIndex, cognate, paper, maxlength);
      }
      EndMarker;
    };

//    Scope("trees") {
//      ShowTreeLine(tree);
//    };
  };
}
//======================================================================

