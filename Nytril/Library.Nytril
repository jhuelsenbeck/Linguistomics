using Format, Units, Math, IO, Genetics;
//======================================================================

class LanguageClass {
  var Name,
      Cases,
      Variable,
      MapImage,
      MapAttribution;

  Constructor(name, cases=0) {
    Name  = name;
    Cases = cases;
  }

  virtual Description = null;
  virtual Details = null;

  override GetLayout = Span {
    Popup: this;
    Name;
  };

  override GetPopup = Block {
    Paragraph {
      Bold;
      TextHeight: 14 pts;
      Name;
    };
    Description {
      RightIndent: 3.5 inches;
    };
    ShowMap(Size(5 inches, 3 inches));
  };

  LoadImage(name) = IO.Read(Info.ImageFolder FileName(name));

  ShowMap(size) {
    if (valid MapImage) {
      return VBox {
        var h = 6 pts;

        HAlign: HAligns.Center;

        MapImage {
          Size: Size(size.Width, size.Height - h);
          Proportional: true;
        };

        Span {
          TextHeight: h;
          TextColor: 80%;
          Lang.Credit;
          Popup: MapAttribution;
        }
      };
    }
    return null;
  }
}
//======================================================================

class CognateClass {
  var Name,
      Title,
      Words,
      Concept,
      Cognate,
      MaxLength;

  Constructor(concept, cognate) {
    Name = concept.GlobalVariableName;
    var n = cognate.GlobalVariableName;
    if (n[..6] == "Primary")
      Title = Name;
    else
      Title = Span {Name; '-'; n};
    Concept    = concept;
    Cognate    = cognate;
    MaxLength  = 0;
  }
}
//======================================================================

class WordClass {
  var Language,
      Cognate,
      Text,
      Segments,
      Aligned,
      Padded;

  Constructor(language, cognate, text) {
    Language = language;
    Cognate  = cognate;
    Text     = text;
    if (text.Length > 0) {
      var segments = IPA.SegmentDictionary.FindTokens(text, IPA.NoSegment);
      Aligned  = Math.FindSlice(segments, s => s.Gap or (not s.Punctuation));
      Segments = Math.FindSlice(segments, s => not s.Punctuation);

      // Test that the word's text is the same as the segments converted back into text
      var view = String(Span {(each segments).Ipa});
      System.Assert(text == view, "Round-trip error with text {0}-{1}"(text, view), text);
    }
    else {
      Segments = [];
      Aligned  = [];
    }
  }

  ShowConcept = Span {
    Style.SansSerif;
    Popup: this;
    Cognate.Title;
  };

  override GetLayout = Span {
    foreach (var s in Segments) {
      if (!s.Punctuation)
        s.Ipa;
    }
  };

  override GetPopup = Frame {
    AllWords.ShowConceptTable(Cognate);
  };
}
//======================================================================

class TaxonClass {
  var Variable,
      Language,
      Index;

  Constructor(lang) {
    Index    = EachIndex;
    Language = lang;
    Variable = lang.GlobalVariableName;
  }

  override GetLayout = Span {
    Nexus.TaxonFormat;
    Variable;
    Popup: Language;
  };
}
//======================================================================

class ResultsClass {
  var Rule,
      UsedCognates,
      Taxa,
      DisplaySegments,
      UniqueSegments,
      UniqueCharacters,
      TotalLength,
      Compute;

  Constructor(folder) {
    GetConcepts;
    foreach (var cognate in UsedCognates)
      ComputeCognate(cognate);

    // Here we assign a character letter to each unique segment from a set of possible Nexus file characters
    Rule = new DiphthongPairRuleClass;
//    Rule = new DiphthongRuleClass;
//    Rule = new VowelsSeparatedRuleClass;
//    Rule = new SegmentTypesRuleClass;

    GetUniqueSegments;
    Rule.AssignCharacters(UniqueSegments);

    var max = 0;
    foreach (var segment in UniqueSegments) {
      if (segment.Character > max)
        max = segment.Character;
    }
    UniqueCharacters = max+1;
    Compute          = new RevProgramClass(Models.CustomQ, folder);
  }

  void GetUniqueSegments {
    var set = new DictionaryClass(256);
    foreach (var cognate in UsedCognates) {
      foreach (var word in cognate.Words) {
        foreach (var segment in word.Segments) {
          if (!segment.Punctuation)
            set.Add(segment, segment.Ipa);
        }
      }
    }
    UniqueSegments  = set.Values;
    DisplaySegments = UniqueSegments;  // Could be IPA.Segments if you want to see all possible segments in the debug tables
  }

  void GetConcepts {
    var set = new DictionaryClass(256);

    TotalLength = 0;
    var clist = new ListClass(256);
    foreach (var concept in Concepts) {
      if (exists concept.?Done and (Info.IncludeVerbs or not exists concept.?Verb)) {
        foreach (var cognate in concept) {
          var vname = cognate.GlobalVariableName();
          if (vname != "Done" and vname != "Verb") {
            var count = 0;
            foreach (var t in cognate) {
              var tn = t.GlobalVariableName();
              set.Add(tn, tn);
              if (t[0].Length > 0)
                ++count;
            }
            if (count > 1)
              clist.Add(new CognateClass(concept, cognate));
          }
        }
      }
    }
    UsedCognates = clist.ToArray;

    var nameset = set.Values;
    var tlist   = new ListClass(nameset.Length);

    foreach (var ln in nameset) {
      var lang = Languages.GetField(ln);
      if (valid lang)
        tlist.Add(new TaxonClass(lang));
      else
        System.Assert(false);
    }
    Taxa = tlist.ToArray;
  }

  TransitionRuleFile = TextBlock {
    Style.MonoFamily;
    "Num_Symbols:{0}"(UniqueSegments.Length);
    Rule.ShowFile;
  };

  ShowLanguageDetails = Block {
    foreach (var taxon in Taxa) {
      var language = taxon.Language;
      Style.Header1(language.Name);
      Block {
        language.Description;
        language.Details;

        if (valid language.MapImage)
          language.ShowMap(Size(5 inches, 3 inches));
      }
    }
  };

  void ComputeCognate(cognate) {
    var words     = new ListClass(Taxa.Length);
    var maxlength = 0;

    foreach (var taxon in Taxa) {
      var word = null;
      foreach (var langword in cognate.Cognate) {
        if (langword.GlobalVariableName == taxon.Variable) {
          var t = langword[0];
          word      = new WordClass(taxon.Language, cognate, t);
          maxlength = Math.Max([maxlength, word.Aligned.Length]);
          break;
        }
      }
      if (word == null)
        word = new WordClass(taxon.Language, cognate, Empty);
      words.Add(word);
    }

    cognate.Words     = words.ToArray;
    cognate.MaxLength = maxlength;

    foreach (var w in cognate.Words) {
      var a = w.Aligned;
      if (a.Length > 0) {
        if (a.Length < maxlength)
          w.Padded = a + [IPA.Segments.GapSegment] * (maxlength - a.Length);
        else
          w.Padded = a;
      }
      else
        w.Padded = [IPA.Segments.GapSegment] * maxlength;
    }

    TotalLength += maxlength;
  }

  ShowLanguages = Block {
    var rows      = 2;
    var cols      = (Taxa.Length + 1) div rows;
    var taxagroup = Taxa / cols;
    var h         = 14 pts;
    var space     = 5 pts;
    var size      = Size(DocMetrics.SlideContent.Width / cols - space, DocMetrics.SlideContent.Height / rows);

    foreach (var group in taxagroup) {
      HBox {
        VAlign: VAligns.Top;

        foreach (var taxon in group) {
          VBox {
            MarginR: space;
            Size: size;
            HAlign: HAligns.Center;

            Paragraph {
              TextHeight: h;
              Bold;
              taxon.Language;
            };

            HBox {
              VAlign: VAligns.Center;

              var s = Size(size.Width, size.Height - h);
              Size: s;
              Corner: 20 pts;
              BorderStroke: 1 pts {Color: 90%};
              BorderClip: true;

              Span {
                Popup: taxon.Language;
                taxon.Language.ShowMap(s);
              }
            };
          }
        }
      }
    }
  };
}
//======================================================================

with Nexus {
  TaxonFormat   = {TextColor: Colors.DarkBlue};
  CommentFormat = {TextColor: Colors.Green};
  KeywordFormat = {TextColor: Colors.Blue};
  EndMarker     = ";";
  Quote         = "\"";

    // This is the set of characters used for the nexus file
  CharacterList = ('A'..'Z' step 1) + ('a'..'z' step 1) + ('0'..'9' step 1) + ['!', '$', '%', '&', '`', '+', ',', '.', '/', '<', '_', '=', '@', '*'];

  Keyword(name) = Span {
    KeywordFormat;
    name;
  };

  Comment(text) = Span {
    CommentFormat;
    "[ ";
    text;
    " ]";
  };

  AddLine(name) = Span {
    Keyword(name);
    End: EndMarker;
  };

  AddValue(name, value=null) = Span {
    Space;
    Keyword(name);
    if (exists value) {
      "=";
      value;
    }
  };

  AddTaxon(taxon) = Span {
    TaxonFormat;
    Space;
    taxon.Variable;
  };

  Scope(name) = TextBlock {
    IndentSpace: 2;
    Begin: Span {
      Keyword("begin");
      Space;
      name;
      EndMarker;
    };
    End: Span {
      Keyword("end");
      EndMarker;
      LineBreak;
    };
  };

  NexusFile = TextBlock {
    Style.MonoFamily;
    Keyword("#NEXUS");
  };

  Newick(node) = Span {
    if (node.Length > 0) {
      "(";
      Span {
        Separator: ",";
        Newick(each node)
      };
      ")";
    }
    node.Label;
    ":";
    node.BranchLength
  };

  ShowTreeLine(tree) = Span {
    "tree ";
    tree.GlobalVariableName;
    " = ";
    Newick(tree);
    EndMarker
  };

  GetTaxaLabels(tree) {
    var set = new DictionaryClass(256);
    VisitNodeTaxa(set, tree);
    return (each set).Name;
  }

  void VisitNodeTaxa(set, node) {
    var name = exists node.Language ? node.Name : null;
    if (valid name)
      set.Add(node, name);
    VisitNodeTaxa(set, each node);
  }

  MaxNameLength = Math.Max((each ((each Results.Taxa).Variable)).Length) + 1;

  WriteTaxa(cognate, paper, maxlength) = TextBlock {
    foreach (var taxon in Results.Taxa) {
      var words = cognate.Words[taxon.Index];
      Span {
        taxon.Variable;
        Space * (maxlength - taxon.Variable.Length);
        foreach (var segment in words.Padded)
          segment.ShowCharacter;

        switch (paper) {
          case 0:
            break;

          case 1:
//            Space*4;
//            Comment( Span{each (each taxon.AlignedList[index]).Ipa});
            break;

          case 2:
            Span {
              CommentFormat;
              Style.IPAFamily;
              Tab;
              foreach (var segment in words.Aligned)
                segment.ShowBlock;
            };
            break;
        }
      };
    }
  };

  TKFFile(cognate, paper) = TextBlock {
    if (paper > 0)
      Comment(cognate.Name);

    Span {
      Results.Taxa.Length;
      Space;
      cognate.Words[0].Padded.Length;
      Space;
      Results.UniqueCharacters;
    };
    WriteTaxa(cognate, paper, MaxNameLength);
  };

  TKFFiles = TextBlock {
    Style.MonoFamily;
    TabStops: [4 inches];

    foreach (var cognate in Results.UsedCognates) {
      TKFFile(cognate, 2);
      Empty;
    }
  };

  CharacterFile(paper) = NexusFile {
    var maxlength = MaxNameLength;
    var ntax      = Results.Taxa.Length;

    TabStops: [4 inches];

    Scope("taxa") {
      AddLine("dimensions") {
        AddValue("ntax", ntax);
      };
      AddLine("taxlabels") {
        AddTaxon(each Results.Taxa);
      };
    };

    Scope("characters") {
      AddLine("dimensions") {
        AddValue("ntax", ntax);
        AddValue("nchar", Results.TotalLength);
      };
      AddLine("format") {
        AddValue("datatype", "STANDARD");
        AddValue("interleave", "yes");
        AddValue("respectcase");
        AddValue("gap", IPA.Segments.GapSegment.Ipa);
        AddValue("missing", IPA.Segments.MissingSegment.Ipa);
        AddValue("symbols", Span {Quote; CharacterList[0..<Math.Min([Results.UniqueCharacters, CharacterList.Length])]; Quote});
      };

      Empty;
      Keyword("matrix");

      foreach (var cognate in Results.UsedCognates) {
        if (EachIndex > 0)
          Empty;

        Comment(cognate.Name);
        WriteTaxa(cognate, paper, maxlength);
      }
      EndMarker;
    };
  };
}
//======================================================================

