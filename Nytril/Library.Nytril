using Format, Units, Math, IO
//======================================================================

with TreeLib
  let GetNodeLabel(node) = node.Data?.SymbolName

  let VisitNodeTaxa(set, node) begin
    set.AddReference(node.Data);
    VisitNodeTaxa(set, each node);
  end

  let GetTaxaLabels(tree) begin
    var set = Type.Dictionary(256);
    VisitNodeTaxa(set, tree);
    return (each set.ValueList).SymbolName;
  end
end
//======================================================================

with Nexus
  let CharacterList = ('A'..'Z' step 1) + ('a'..'z' step 1) + ('0'..'9' step 1)
  let EndLine       = ";"
  let Missing       = "?"
  let Gap           = '-'
  let Quote         = "\""

  let Keyword(name) = Span {
    TextColor: Colors.Blue,
    name
  }

  let Comment(text) = Span {
    TextColor: Colors.Green,
    "#"
    text
  }

  let AddLine(name) = Span {
    Keyword(name)
  }

  let AddValue(name, value) = Span {
    Space,
    Keyword(name),
    "=",
    value,
  }

  let BeginScope(name) = TextBlock {
    IndentSpace: 2,
    Begin: Span {
      Keyword("begin"),
      Space,
      name,
      EndLine,
    },
    End: Span {
      Keyword("end"),
      EndLine,
    },
  }


  let SourceFile = TextBlock {
    Comment("NEXUS"),
    Empty,
  }

  let Newick(node) = Span {
    if (node.Length > 0)
      "(",
      Span {
        Separator: ",",
        Newick(each node)
      },
      ")",
    end,
    TreeLib.GetNodeLabel(node),
    ":",
    node.Branch
  }

  let ShowTreeLine(ref tree) = Span {
    "tree ",
    tree.SymbolName,
    " = ",
    Newick(tree),
    EndLine
  }

  let TreeFormat(taxa) = SourceFile {
    BeginScope("taxa") {
      AddLine("dimensions") {
        AddValue("ntax", taxa.Length),
        EndLine
      },
      AddLine("taxlabels") {
        Space,
        Span {
          Separator: Space,
          taxa,
        },
        EndLine,
      },
    }
  }

  let TreeFile(ref tree) = TreeFormat(TreeLib.GetTaxaLabels(tree)) {
    BeginScope("trees") {
      ShowTreeLine(ref tree),
    }
  }

/*
  let GetGene(langindex, meaning) begin
    var ma   = WordMeaningArray[EachIndex];
    var cell = ma.Cells[langindex];
    return Span {
      if (EachIndex mod 2 == 0)
        TextBackground: 90%
      else
        TextColor: Colors.White,
        TextBackground: 50%
      end,
      Popup: CharacterPopup(cell.Word),
      cell.Characters,
      "-" * (ma.MaxLength - cell.Count),
    };
  end
*/

  let ShowTaxon(maxlength, taxon, range) = Span {
    taxon.Name,
    Space * (maxlength - taxon.Name.Length),
    taxon.Characters[range]
  }

  let ShowTaxonSet(maxlength, taxa, range) = {
    ShowTaxon(maxlength, each taxa, range),
    Empty,
  }

  let CharacterFile(taxa, charmax) begin
    var maxlength = Math.Max((each taxa).Name.Length)+1;
    return SourceFile {
      BeginScope("DATA") {
        AddLine("dimensions") {
          AddValue("ntax", taxa.Length),
          AddValue("nchar", charmax),
          EndLine
        },
        AddLine("format") {
          AddValue("datatype", "STANDARD"),
          AddValue("gap", Gap),
          AddValue("missing", Missing),
          AddValue("symbols", Span {Quote, CharacterList[0..<charmax], Quote}),
          EndLine
        },
        Keyword("matrix"),
        ShowTaxonSet(maxlength, taxa, each ((0..<(taxa[0].Characters.Length)) / (70 - maxlength))),
        EndLine,
      }
    }
  end
end
//======================================================================

