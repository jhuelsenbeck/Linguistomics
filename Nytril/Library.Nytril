using Format, Units, Math, IO, Genetics;
//======================================================================

class TaxonClass {
  var Name,
      SegmentList,
      AlignedList;

  Constructor(lang, langindex) {
    var count = Results.WordConceptArray.Length;
    SegmentList = new ListClass(count);
    AlignedList = new ListClass(count);
    Name        = lang.GlobalVariableName;

    foreach (var concept in Results.WordConceptArray)
      SegmentList.Add(concept.Cells[langindex].Segments);
  }
}
//======================================================================

with Results {
  GetTaxaArray(lang) = new TaxonClass(lang, EachIndex);

  ComputeTaxa() {
    var taxa = GetTaxaArray(each UsedLanguages);
    for (var concept = 0; concept < WordConceptArray.Length; ++concept) {
      var wordlist = new ListClass(WordConceptArray.Length);
      foreach (var taxon in taxa)
        wordlist.Add(taxon.SegmentList[concept]);

      var align = new AlignClass(wordlist) {
        Gap: IPA.GapSegment;
      };
      var run = align.Run;
      if (valid run) {
        var i = 0;
        foreach (var taxon in taxa)
          taxon.AlignedList.Add(run.Results[i++]);
      }
      else {
        var max = Max((each wordlist).Length);
        foreach (var taxon in taxa) {
          var segs = taxon.SegmentList[concept];
          taxon.AlignedList.Add(segs + [IPA.GapSegment] * (max - segs.Length));
        }
      }
    }
    return taxa;
  }

  AddConceptRecord(concept) = new ConceptRecord(concept);
  WordConceptArray = AddConceptRecord(each ConceptsList);

  TaxaArray      = ComputeTaxa;

  UsedLanguages  = Math.FindSlice(Languages, lang => lang.Words != null);
  UniqueSegments = DisplayCharacters.FindUniqueSegments;
  UsedSegments   = UniqueSegments;//IPA.Segments;
}
//======================================================================

with Nexus {
  TaxonFormat   = {TextColor: Colors.DarkBlue};
  CommentFormat = {TextColor: Colors.Green};
  CharacterList = ('A'..'Z' step 1) + ('a'..'z' step 1) + ('0'..'9' step 1);
  EndMarker     = ";";
  Missing       = "?";
  Quote         = "\"";

  Keyword(name) = Span {
    CommentFormat;
    name;
  };

  Comment(text) = Span {
    TextColor: Colors.Green;
    "[ ";
    text;
    " ]";
  };

  AddLine(name) = Span {
    Keyword(name);
    End: EndMarker;
  };

  AddValue(name, value=null) = Span {
    Space;
    Keyword(name);
    if (exists value) {
      "=";
      value;
    }
  };

  AddTaxon(taxon) = Span {
    TaxonFormat;
    Space;
    taxon.Name;
  };

  Scope(name) = TextBlock {
    IndentSpace: 2;
    Begin: Span {
      Keyword("begin");
      Space;
      name;
      EndMarker;
    };
    End: Span {
      Keyword("end");
      EndMarker;
      LineBreak;
    };
  };

  NexusFile = TextBlock {
    Style.MonoFamily;
    Span {
      TextColor: Colors.DarkBlue;
      "#NEXUS";
    };
  };

  Newick(node) = Span {
    if (node.Length > 0) {
      "(";
      Span {
        Separator: ",";
        Newick(each node)
      };
      ")";
    }
    node.Label;
    ":";
    node.BranchLength
  };

  ShowTreeLine(tree) = Span {
    "tree ";
    tree.GlobalVariableName;
    " = ";
    Newick(tree);
    EndMarker
  };

  GetTaxaLabels(tree) {
    var set = new DictionaryClass(256);
    VisitNodeTaxa(set, tree);
    return (each set).Name;
  }

  void VisitNodeTaxa(set, node) {
    var name = exists node.Language ? node.Name : null;
    if (valid name)
      set.Add(node, name);
    VisitNodeTaxa(set, each node);
  }

  MaxNameLength = Math.Max((each ((each Results.TaxaArray).Name)).Length) + 1;

  WriteTaxa(paper, concept, maxlength) = TextBlock {
    foreach (var taxon in Results.TaxaArray) {
      Span {
        Span {
          Nexus.TaxonFormat;
          taxon.Name;
        };
        Space * (maxlength - taxon.Name.Length);
        foreach (var segment in taxon.AlignedList[concept])
          segment.SegmentToCharacter.ShowLetter;

        switch (paper) {
          case 0:
            break;

          case 1:
            Space*4;
            Comment( Span{each (each taxon.AlignedList[concept]).Ipa});
            break;

          case 2:
            Span {
              CommentFormat;
              Style.IPAFamily;
              Tab;
              foreach (var segment in taxon.AlignedList[concept]) {
                Canvas {
                  Width: 10 pts;
                  Height: 8 pts;
                  segment.ShowSegment;
                }
              }
            };
            break;
        }
      };
    }
  };

  TKFFile(concept, paper) = TextBlock {
    if (paper > 0)
      Comment(ConceptsList[concept].GlobalVariableName);

    Span {
      Results.TaxaArray.Length;
      Space;
      Results.TaxaArray[0].AlignedList[concept].Length;
      Space;
      Results.UniqueSegments.Length;
    };
    WriteTaxa(paper, concept, MaxNameLength);
  };

  TKFFiles = TextBlock {
    Style.MonoFamily;
    TabStops: [3 inches];

    for (var concept = 0; concept < ConceptsList.Length; ++concept) {
      TKFFile(concept, 2);
      Empty;
    }
  };

  CharacterFile(paper) = NexusFile {
    var maxlength = MaxNameLength;
    var ntax      = Results.TaxaArray.Length;

    TabStops: [3 inches];

    Scope("taxa") {
      AddLine("dimensions") {
        AddValue("ntax", ntax);
      };
      AddLine("taxlabels") {
        AddTaxon(each Results.TaxaArray);
      };
    };

    Scope("data") {
      AddLine("dimensions") {
        AddValue("ntax", ntax);
        AddValue("nchar", Sum((each Results.TaxaArray[0].AlignedList).Length));
      };
      AddLine("format") {
        AddValue("datatype", "STANDARD");
        AddValue("interleave", "yes");
        AddValue("respectcase");
        AddValue("gap", IPA.GapSegment.Ipa);
        AddValue("missing", Missing);
        AddValue("symbols", Span {Quote; CharacterList[Results.UniqueSegments.IndexRange]; Quote});
      };
      Empty;
      Keyword("matrix");

      for (var concept = 0; concept < ConceptsList.Length; ++concept) {
        if (EachIndex > 0)
          Empty;

        Comment(ConceptsList[concept].GlobalVariableName);
        WriteTaxa(paper, concept, maxlength);
      }
      EndMarker;
    };

//    Scope("trees") {
//      ShowTreeLine(tree);
//    };
  };
}
//======================================================================

